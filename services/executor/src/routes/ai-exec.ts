// services/executor/src/routes/ai-exec.ts
import type { FastifyInstance } from 'fastify';

interface Action {
  action: string;
  params?: any;
  dryRun?: boolean;
  confirm_required?: boolean;
  reason?: string;
}

interface ExecRequest {
  action: Action;
}

/**
 * Execute action locally by calling internal routes
 */
async function executeActionLocally(
  app: FastifyInstance,
  action: Action
): Promise<any> {
  // Parse the action path
  const path = action.action.replace(/^https?:\/\/[^/]+/, '');
  const params = action.params || {};

  // Determine HTTP method based on path
  const method = path.includes('/ws.') || path.includes('/order.') || path.includes('/canary/')
    ? 'POST'
    : 'GET';

  try {
    // Make internal request
    const response = await app.inject({
      method,
      url: path,
      payload: method === 'POST' ? params : undefined,
      query: method === 'GET' ? params : undefined,
    });

    return {
      statusCode: response.statusCode,
      body: response.json(),
    };
  } catch (err: any) {
    app.log.error({ err, action }, 'Action execution error');
    throw err;
  }
}

/**
 * AI action execution routes
 * Executes actions generated by Copilot AI
 */
export async function aiExecRoutes(app: FastifyInstance) {
  /**
   * Execute action with guardrails
   */
  app.post<{ Body: ExecRequest }>(
    '/ai/exec',
    async (request, reply) => {
      const { action } = request.body;

      if (!action || !action.action) {
        return reply.code(400).send({
          error: 'ValidationError',
          message: 'Action is required',
        });
      }

      app.log.info({
        action: action.action,
        params: action.params,
        dryRun: action.dryRun,
        confirm_required: action.confirm_required,
      }, 'AI action execution request');

      // Guardrail 1: confirm_required check
      if (action.confirm_required && action.dryRun === false) {
        app.log.warn({ action }, 'Action requires confirmation but dryRun=false');
        return reply.send({
          ok: false,
          blocked: true,
          reason: 'ConfirmRequired',
          suggestion: 'Bu işlem onay gerektirir. Önce dry-run yapın veya manuel onaylayın.',
          action,
        });
      }

      // Guardrail 2: Force dry-run for high-risk operations
      const highRiskPaths = ['/futures/order.place', '/futures/order.cancel'];
      const isHighRisk = highRiskPaths.some(p => action.action.includes(p));
      
      if (isHighRisk && action.dryRun !== false) {
        app.log.info({ action }, 'High-risk operation defaulting to dry-run');
      }

      try {
        // Execute action
        const startTime = Date.now();
        const result = await executeActionLocally(app, action);
        const duration = Date.now() - startTime;

        // Generate evidence
        const evidence = {
          timestamp: new Date().toISOString(),
          route: action.action,
          params: action.params,
          dryRun: action.dryRun !== false,
          duration,
          statusCode: result.statusCode,
          requestId: request.id,
        };

        app.log.info({
          action: action.action,
          duration,
          statusCode: result.statusCode,
        }, 'AI action executed successfully');

        return reply.send({
          ok: true,
          result: result.body,
          evidence,
          action,
        });
      } catch (err: any) {
        app.log.error({ err, action }, 'AI action execution failed');

        return reply.code(500).send({
          ok: false,
          error: 'ActionExecutionError',
          message: err.message,
          action,
          timestamp: new Date().toISOString(),
        });
      }
    }
  );

  /**
   * Get execution history (placeholder for future implementation)
   */
  app.get('/ai/exec/history', async (_request, reply) => {
    return reply.send({
      history: [],
      message: 'History feature coming soon',
    });
  });

  app.log.info('✅ AI execution routes registered');
}

