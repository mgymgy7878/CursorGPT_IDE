# v1.3 Mikro-ƒ∞nce Ayarlar - "Hemen Uygula" Paketi
**Spark Trading Platform - Son R√∂tu≈ülar**

**Version:** v1.3-micro-tweaks  
**Date:** 2025-01-16  
**Implementation Time:** 30 dakika (her biri)  
**Status:** üîß READY TO APPLY

---

## üéØ Felsefe

**"K√º√ß√ºk ama √∂ld√ºr√ºc√º"** k√∂≈üeleri kapat. Her biri 30 dakikalƒ±k k√º√ß√ºk patch, ama prod ortamƒ±nda **b√ºy√ºk fark yaratƒ±r**.

---

## 1Ô∏è‚É£ Delta-Threshold Sembol Matrisi (Hibrit Optimizasyon)

### Sorun
≈ûu anki `%0.05` sabit e≈üik:
- **BTC_TRY (‚Ç∫2.5M):** M√ºkemmel ‚Üí ‚Ç∫1,250 deƒüi≈üim = emit
- **XRP_TRY (‚Ç∫25):** √áok sƒ±kƒ± ‚Üí ‚Ç∫0.0125 deƒüi≈üim gerekir (√ßok sessiz)

### √á√∂z√ºm
```typescript
// apps/web-next/src/lib/sse-delta-throttle.ts (enhanced - REPLACE ENTIRE FILE)

interface SymbolThresholdConfig {
  symbol: string;
  tickSize: number;        // Minimum fiyat adƒ±mƒ±
  minChangePct: number;    // %deƒüi≈üim e≈üiƒüi
  priceRange?: string;     // 'high' | 'medium' | 'low'
}

// Sembol profil matrisi
const SYMBOL_THRESHOLDS: Record<string, SymbolThresholdConfig> = {
  // Kripto (y√ºksek fiyatlƒ±)
  'BTC_TRY': {
    symbol: 'BTC_TRY',
    tickSize: 1,           // ‚Ç∫1
    minChangePct: 0.05,    // %0.05
    priceRange: 'high',
  },
  'ETH_TRY': {
    symbol: 'ETH_TRY',
    tickSize: 0.5,         // ‚Ç∫0.5
    minChangePct: 0.05,
    priceRange: 'high',
  },
  'USDT_TRY': {
    symbol: 'USDT_TRY',
    tickSize: 0.01,        // ‚Ç∫0.01
    minChangePct: 0.1,     // %0.1 (stablecoin, daha gev≈üek)
    priceRange: 'medium',
  },
  
  // Kripto (d√º≈ü√ºk fiyatlƒ±)
  'XRP_TRY': {
    symbol: 'XRP_TRY',
    tickSize: 0.0001,      // ‚Ç∫0.0001 (tick size dominant)
    minChangePct: 0.2,     // %0.2 (√ßok gev≈üek)
    priceRange: 'low',
  },
  
  // BIST hisseleri
  'THYAO': {
    symbol: 'THYAO',
    tickSize: 0.02,        // BIST tick size
    minChangePct: 0.1,     // %0.1
    priceRange: 'medium',
  },
  'AKBNK': {
    symbol: 'AKBNK',
    tickSize: 0.02,
    minChangePct: 0.1,
    priceRange: 'medium',
  },
  'GARAN': {
    symbol: 'GARAN',
    tickSize: 0.02,
    minChangePct: 0.1,
    priceRange: 'medium',
  },
};

interface Tick {
  symbol: string;
  price: number;
  timestamp: number;
}

const lastEmittedTicks = new Map<string, Tick>();
const skipCountBySymbol = new Map<string, number>();

/**
 * Sembol-duyarlƒ± emit kararƒ± (Hibrit: tick-size VE %deƒüi≈üim)
 */
export const shouldEmitTick = (tick: Tick): boolean => {
  const config = SYMBOL_THRESHOLDS[tick.symbol];
  
  // Bilinmeyen sembol i√ßin default behavior (gev≈üek)
  if (!config) {
    const lastTick = lastEmittedTicks.get(tick.symbol);
    if (!lastTick || tick.timestamp - lastTick.timestamp > 250) {
      lastEmittedTicks.set(tick.symbol, tick);
      return true;
    }
    return false;
  }

  const lastTick = lastEmittedTicks.get(tick.symbol);
  
  // ƒ∞lk tick, emit et
  if (!lastTick) {
    lastEmittedTicks.set(tick.symbol, tick);
    return true;
  }

  const dt = tick.timestamp - lastTick.timestamp;
  const dp = Math.abs(tick.price - lastTick.price);
  const pct = lastTick.price ? (dp / lastTick.price) : 1;

  // √ú√ß emit kriteri (herhangi biri saƒülanƒ±rsa emit):
  // 1. Zaman delta >250ms
  // 2. Fiyat deƒüi≈üimi > minChangePct
  // 3. Fiyat deƒüi≈üimi > tickSize (mutlak)
  
  const timeThreshold = dt > 250;
  const pctThreshold = pct > (config.minChangePct / 100);
  const absThreshold = dp > config.tickSize;

  const shouldEmit = timeThreshold || pctThreshold || absThreshold;

  if (shouldEmit) {
    lastEmittedTicks.set(tick.symbol, tick);
  } else {
    // Skip count artƒ±r (metrics i√ßin)
    const currentSkip = skipCountBySymbol.get(tick.symbol) || 0;
    skipCountBySymbol.set(tick.symbol, currentSkip + 1);
  }

  return shouldEmit;
};

/**
 * Prometheus metrikleri i√ßin skip stats
 */
export const getSkipStats = (): Record<string, number> => {
  const stats: Record<string, number> = {};
  for (const [symbol, count] of skipCountBySymbol.entries()) {
    stats[symbol] = count;
  }
  return stats;
};

/**
 * Reset (test i√ßin)
 */
export const resetThrottle = () => {
  lastEmittedTicks.clear();
  skipCountBySymbol.clear();
};

/**
 * Metrics export
 */
export const getDeltaThrottleMetrics = (): string[] => {
  const metrics: string[] = [
    "# HELP sse_delta_throttle_skipped_total Total ticks skipped by delta throttle",
    "# TYPE sse_delta_throttle_skipped_total counter",
  ];
  
  for (const [symbol, count] of skipCountBySymbol.entries()) {
    metrics.push(`sse_delta_throttle_skipped_total{symbol="${symbol}"} ${count}`);
  }
  
  return metrics;
};
```

**Expected Impact:**
- **XRP_TRY:** Emit rate +%35 (tick-size dominant)
- **BTC_TRY:** Emit rate korunur (%deƒüi≈üim dominant)
- **Network egress:** Ortalama %15‚Üì (sembol karmasƒ± optimize)

---

## 2Ô∏è‚É£ SSE Kapalƒ± Devre Throttle (Self-Healing)

### Sorun
SSE queue depth %80 √ºst√ºne √ßƒ±ktƒ±ƒüƒ±nda drop-oldest √ßalƒ±≈üƒ±r ama throttle sabit kalƒ±r. Queue overflow loop'a girer.

### √á√∂z√ºm
```typescript
// apps/web-next/src/app/api/market/btcturk/stream/route.ts (enhanced - PARTIAL UPDATE)

// AdaptiveSSEQueue tanƒ±mƒ±nƒ± ekle (mevcut SSEQueue yerine)
interface AdaptiveSSEQueue {
  messages: any[];
  maxSize: number;
  droppedCount: number;
  throttleCoefficient: number; // 1.0 = normal, 4.0 = max throttle
  lastAdjustmentTime: number;
}

// Adaptive throttle adjustment
function adjustThrottleCoefficient(queue: AdaptiveSSEQueue) {
  const now = Date.now();
  const queueUtilization = queue.messages.length / queue.maxSize;

  // En az 10s'de bir ayarlama yap (thrashing √∂nleme)
  if (now - queue.lastAdjustmentTime < 10000) {
    return;
  }

  let adjusted = false;

  // Kuyruk %80'in √ºzerindeyse, throttle +0.5
  if (queueUtilization > 0.8 && queue.throttleCoefficient < 4.0) {
    queue.throttleCoefficient = Math.min(4.0, queue.throttleCoefficient + 0.5);
    console.log(`[SSE Adaptive] Throttle ‚Üë ${queue.throttleCoefficient.toFixed(1)}x (queue: ${queue.messages.length}/${queue.maxSize})`);
    adjusted = true;
  }

  // Kuyruk %40'ƒ±n altƒ±ndaysa, throttle -0.25
  if (queueUtilization < 0.4 && queue.throttleCoefficient > 1.0) {
    queue.throttleCoefficient = Math.max(1.0, queue.throttleCoefficient - 0.25);
    console.log(`[SSE Adaptive] Throttle ‚Üì ${queue.throttleCoefficient.toFixed(1)}x (queue: ${queue.messages.length}/${queue.maxSize})`);
    adjusted = true;
  }

  if (adjusted) {
    queue.lastAdjustmentTime = now;
  }
}

// Queue initialization (GET handler'da)
const queue: AdaptiveSSEQueue = {
  messages: [],
  maxSize: 100,
  droppedCount: 0,
  throttleCoefficient: 1.0,
  lastAdjustmentTime: Date.now(),
};

// Her interval'da throttle ayarƒ±nƒ± kontrol et
const interval = setInterval(() => {
  const queue = sseQueues.get(clientId);
  if (!queue) return;

  // Throttle ayarlamasƒ±
  adjustThrottleCoefficient(queue);

  // Throttle coefficient'e g√∂re mesaj g√∂nder
  const messagesToSend = Math.max(1, Math.floor(10 / queue.throttleCoefficient)); // Base 10 msg/interval
  
  for (let i = 0; i < messagesToSend && queue.messages.length > 0; i++) {
    const msg = queue.messages.shift();
    const sseData = `data: ${JSON.stringify(msg)}\n\n`;
    controller.enqueue(encoder.encode(sseData));
  }

  // Throttle bilgisi
  if (queue.messages.length > 0) {
    const info = `data: ${JSON.stringify({ 
      type: 'info',
      queueDepth: queue.messages.length,
      throttleCoefficient: queue.throttleCoefficient,
    })}\n\n`;
    controller.enqueue(encoder.encode(info));
  }
}, 250);
```

**Prometheus Metrics:**
```typescript
// apps/web-next/src/app/api/tools/metrics/route.ts (ADD)

// SSE queue depth (aggregate across clients)
const avgQueueDepth = Array.from(sseQueues.values())
  .reduce((sum, q) => sum + q.messages.length, 0) / (sseQueues.size || 1);

metrics.push("# HELP sse_queue_depth_avg_gauge Average SSE queue depth across clients");
metrics.push("# TYPE sse_queue_depth_avg_gauge gauge");
metrics.push(`sse_queue_depth_avg_gauge ${Math.round(avgQueueDepth)}`);

// SSE throttle coefficient (average)
const avgThrottle = Array.from(sseQueues.values())
  .reduce((sum, q) => sum + q.throttleCoefficient, 0) / (sseQueues.size || 1);

metrics.push("# HELP sse_throttle_coefficient_avg_gauge Average throttle coefficient");
metrics.push("# TYPE sse_throttle_coefficient_avg_gauge gauge");
metrics.push(`sse_throttle_coefficient_avg_gauge ${avgThrottle.toFixed(2)}`);
```

**Expected Impact:**
- **Queue overflow:** %80‚Üì (self-healing)
- **Drop events:** %60‚Üì (throttle devreye girer)
- **Dashboard latency:** Stabil (queue optimize)

---

## 3Ô∏è‚É£ ƒ∞zlenebilirlik: Trace-ID + Git SHA

### Sorun
Incident ZIP'lerde trace-ID ve kod versiyonu yok. Hangi kod versiyon-unda hangi incident olu≈ütu belli deƒüil.

### √á√∂z√ºm
```typescript
// apps/web-next/src/app/api/tools/incident/create/route.ts (NEW)

import { execSync } from 'child_process';
import path from 'path';
import fs from 'fs';
import crypto from 'crypto';

export async function POST(req: NextRequest) {
  const { reason } = await req.json();
  const traceId = (globalThis as any).__traceId || crypto.randomUUID();

  try {
    // Git SHA al
    const gitSha = execSync('git rev-parse --short HEAD', { 
      encoding: 'utf-8',
      cwd: process.cwd()
    }).trim();

    // Git branch al
    const gitBranch = execSync('git rev-parse --abbrev-ref HEAD', { 
      encoding: 'utf-8',
      cwd: process.cwd()
    }).trim();

    // Timestamp
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const evidenceDir = path.resolve(process.cwd(), `evidence/incident_${timestamp}`);
    fs.mkdirSync(evidenceDir, { recursive: true });

    // 1. Health snapshot
    const healthResponse = await fetch('http://localhost:3003/api/healthz', { cache: 'no-store' });
    const healthData = await healthResponse.json();
    fs.writeFileSync(
      path.join(evidenceDir, 'healthz.json'),
      JSON.stringify(healthData, null, 2)
    );

    // 2. Prometheus dump (son 15 dk)
    const metricsResponse = await fetch('http://localhost:3003/api/tools/metrics?format=prometheus');
    const metricsData = await metricsResponse.text();
    fs.writeFileSync(path.join(evidenceDir, 'prometheus_metrics.txt'), metricsData);

    // 3. Logs (WS, rate-limit, SSE)
    const logFiles = ['ws_client.log', 'rate_limiter.log', 'sse_stream.log', 'bist_quality.log'];
    for (const logFile of logFiles) {
      const logPath = path.resolve(process.cwd(), `logs/${logFile}`);
      if (fs.existsSync(logPath)) {
        const logContent = fs.readFileSync(logPath, 'utf-8');
        const recentLines = logContent.split('\n').slice(-200).join('\n'); // Son 200 satƒ±r
        fs.writeFileSync(path.join(evidenceDir, logFile), recentLines);
      }
    }

    // 4. Config snapshot
    const configSnapshot = {
      env: {
        SPARK_REAL_DATA: process.env.SPARK_REAL_DATA || '0',
        NEXT_PUBLIC_EXECUTOR_URL: process.env.NEXT_PUBLIC_EXECUTOR_URL || 'unknown',
        NODE_ENV: process.env.NODE_ENV || 'unknown',
      },
      git: {
        sha: gitSha,
        branch: gitBranch,
      },
      deployment: {
        version: '1.2.0',
        timestamp,
      },
    };
    fs.writeFileSync(
      path.join(evidenceDir, 'config_snapshot.json'),
      JSON.stringify(configSnapshot, null, 2)
    );

    // 5. Incident metadata
    const incidentMeta = {
      id: `inc-${crypto.randomUUID()}`,
      traceId,
      timestamp,
      reason,
      triggeredBy: 'user', // Auth'dan √ßekilecek
      git: { sha: gitSha, branch: gitBranch },
      health: {
        status: healthData.status,
        latencyP95: healthData.slo?.latencyP95,
        errorRate: healthData.slo?.errorRate,
      },
    };
    fs.writeFileSync(
      path.join(evidenceDir, 'incident_meta.json'),
      JSON.stringify(incidentMeta, null, 2)
    );

    // 6. Reason text
    fs.writeFileSync(path.join(evidenceDir, 'reason.txt'), reason);

    // ZIP olu≈ütur
    const zipPath = path.resolve(process.cwd(), `evidence/incident_${timestamp}.zip`);
    execSync(`powershell Compress-Archive -Path "${evidenceDir}\\*" -DestinationPath "${zipPath}"`);

    // Cleanup temp dir
    fs.rmSync(evidenceDir, { recursive: true });

    return NextResponse.json({
      success: true,
      incidentId: incidentMeta.id,
      traceId,
      zipPath: `evidence/incident_${timestamp}.zip`,
      git: { sha: gitSha, branch: gitBranch },
    });
  } catch (error: any) {
    console.error('[Incident] Failed to create incident ZIP:', error);
    return NextResponse.json({
      success: false,
      error: error.message,
    }, { status: 500 });
  }
}
```

**Command Palette Integration:**
```typescript
// apps/web-next/src/lib/command-palette.ts (UPDATE)

export const collectIncidentZip: CommandAction = {
  id: "ops.collect-incident-zip",
  label: "Collect Incident ZIP & Slack Page",
  description: "Generate evidence ZIP with trace-ID and Git SHA",
  icon: "üö®",
  category: "ops",
  handler: async () => {
    const reason = prompt("Incident reason (min 10 chars):");
    if (!reason || reason.length < 10) {
      return { success: false, message: "Reason required" };
    }

    try {
      const response = await fetch("/api/tools/incident/create", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ reason }),
      });

      const result = await response.json();

      // Slack webhook (opsiyonel)
      if (process.env.NEXT_PUBLIC_SLACK_WEBHOOK_URL) {
        await fetch(process.env.NEXT_PUBLIC_SLACK_WEBHOOK_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            text: `üö® Incident: ${reason}`,
            attachments: [{
              color: "danger",
              fields: [
                { title: "Incident ID", value: result.incidentId, short: true },
                { title: "Trace ID", value: result.traceId, short: true },
                { title: "Git SHA", value: result.git.sha, short: true },
                { title: "Branch", value: result.git.branch, short: true },
                { title: "Evidence", value: result.zipPath, short: false },
              ],
            }],
          }),
        });
      }

      return {
        success: true,
        message: `Incident ZIP created: ${result.zipPath}`,
        details: result,
      };
    } catch (err) {
      return { success: false, message: `Failed: ${err}` };
    }
  },
};

// COMMANDS array'e ekle
export const COMMANDS: CommandAction[] = [
  // ... existing commands
  collectIncidentZip,
];
```

**Runbook'ta Tek Satƒ±r Arama:**
```bash
# Incident ID ile t√ºm log'larƒ± ara
grep "inc-abc123-def456" logs/*.log evidence/*.zip

# Trace ID ile request chain'i izle
grep "trace-xyz789" logs/audit.log
```

---

## üìä "Ge√ßer Not" ≈ûablonu (Hedef √áƒ±ktƒ±)

```
‚ïê‚ïê‚ïê FINAL GAUNTLET RESULTS ‚ïê‚ïê‚ïê

‚úÖ Gauntlet 1: Zaman √ú√ßl√ºs√º (3/3 PASS)
  ‚úÖ Clock skew: clock_skew_ms=2500, staleness alarm YOK
  ‚úÖ BIST tatil: market_closed=1, zero-volume silent
  ‚úÖ DST ge√ßi≈ü: √áift kayƒ±t YOK

‚úÖ Gauntlet 2: Kimlik & Kota (2/2 PASS)
  ‚úÖ Rate limit: burst_violations=2, sustained_violations=1
  ‚úÖ Adaptive backoff: vendor_adaptive_backoff_multiplier=1.5x

‚úÖ Gauntlet 3: Aƒü ≈ûiddeti (2/2 PASS)
  ‚úÖ WS reconnect: concurrent_reconnects_gauge‚â§2, vendor_backoff_active=1
  ‚úÖ SSE flood: sse_dropped_events_total‚Üë, egress ‚â§30%, RAM plato

‚úÖ Gauntlet 4: Kardinalite (2/2 PASS)
  ‚úÖ TSDB series: +35% (‚â§50% limit)
  ‚úÖ Top-N: venue_requests_by_symbol_total 10 series

‚úÖ Gauntlet 5: Kill-Switch (3/3 PASS)
  ‚úÖ Flipflop reject: flipflop_rejects_total=1, cooldown active
  ‚úÖ Evidence ZIP: reason.txt + healthz.json + config_snapshot.json + trace_id
  ‚úÖ Restore 25%‚Üí50%‚Üí100%: SLO alarm YOK

‚úÖ Gauntlet 6: Veri Kalitesi (2/2 PASS)
  ‚úÖ Schema v1.1‚Üív1.2: Side-by-side canary, parser crash YOK
  ‚úÖ Anomaly: +12% ‚Üí warning, stale>30s ‚Üí critical reject

‚úÖ Gauntlet 7: Maliyet (2/2 PASS)
  ‚úÖ Budget limit %110: Throttle active, rollout devam ediyor
  ‚úÖ vendor_cost_usd_total tracking aktif

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
SERTƒ∞Fƒ∞KA: ‚úÖ BA≈ûARILI (95% success rate)
PROD'A √áIKI≈û: ONAYLANDI
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
```

---

## üöÄ Hƒ±zlƒ± Uygulama (3√ó 30 Dakika)

### Batch 1: Delta + SSE (30 dk)
```bash
# 1. Replace sse-delta-throttle.ts (symbol matrix)
# 2. Update stream/route.ts (adaptive throttle)
# 3. Test: XRP_TRY vs BTC_TRY emit rate
# 4. Verify: sse_throttle_coefficient_avg_gauge in metrics
```

### Batch 2: Trace-ID + Git SHA (30 dk)
```bash
# 1. Create middleware.ts (trace-ID injection)
# 2. Create incident/create route
# 3. Update command-palette.ts
# 4. Test: Incident ZIP i√ßinde trace_id + git SHA
```

### Batch 3: Rate-Limit Burst/Sustained (30 dk)
```bash
# 1. Update rate-limiter.ts (burst/sustained detection)
# 2. Update metrics/route.ts (new counters)
# 3. Update Grafana alerts (burst vs sustained)
# 4. Test: 10√ó 429 in 10s ‚Üí burst alarm
```

---

*Mikro-ƒ∞nce Ayarlar hazƒ±r. Her biri 30 dakika, toplamda 90 dakikada "saklƒ± meteor yaƒümuruna" kar≈üƒ± kalkan tamamlanƒ±r.* üõ°Ô∏è

