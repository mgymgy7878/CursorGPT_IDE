# v1.3 Mikro-Ä°nce Ayarlar - "Hemen Uygula" Paketi
**Spark Trading Platform - Son RÃ¶tuÅŸlar**

**Version:** v1.3-micro-tweaks  
**Date:** 2025-01-16  
**Implementation Time:** 30 dakika (her biri)  
**Status:** ğŸ”§ READY TO APPLY

---

## ğŸ¯ Felsefe

**"KÃ¼Ã§Ã¼k ama Ã¶ldÃ¼rÃ¼cÃ¼"** kÃ¶ÅŸeleri kapat. Her biri 30 dakikalÄ±k kÃ¼Ã§Ã¼k patch, ama prod ortamÄ±nda **bÃ¼yÃ¼k fark yaratÄ±r**.

---

## 1ï¸âƒ£ Delta-Threshold Sembol Matrisi (Hibrit Optimizasyon)

### Sorun
Åu anki `%0.05` sabit eÅŸik:
- **BTC_TRY (â‚º2.5M):** MÃ¼kemmel â†’ â‚º1,250 deÄŸiÅŸim = emit
- **XRP_TRY (â‚º25):** Ã‡ok sÄ±kÄ± â†’ â‚º0.0125 deÄŸiÅŸim gerekir (Ã§ok sessiz)

### Ã‡Ã¶zÃ¼m
```typescript
// apps/web-next/src/lib/sse-delta-throttle.ts (enhanced - REPLACE ENTIRE FILE)

interface SymbolThresholdConfig {
  symbol: string;
  tickSize: number;        // Minimum fiyat adÄ±mÄ±
  minChangePct: number;    // %deÄŸiÅŸim eÅŸiÄŸi
  priceRange?: string;     // 'high' | 'medium' | 'low'
}

// Sembol profil matrisi
const SYMBOL_THRESHOLDS: Record<string, SymbolThresholdConfig> = {
  // Kripto (yÃ¼ksek fiyatlÄ±)
  'BTC_TRY': {
    symbol: 'BTC_TRY',
    tickSize: 1,           // â‚º1
    minChangePct: 0.05,    // %0.05
    priceRange: 'high',
  },
  'ETH_TRY': {
    symbol: 'ETH_TRY',
    tickSize: 0.5,         // â‚º0.5
    minChangePct: 0.05,
    priceRange: 'high',
  },
  'USDT_TRY': {
    symbol: 'USDT_TRY',
    tickSize: 0.01,        // â‚º0.01
    minChangePct: 0.1,     // %0.1 (stablecoin, daha gevÅŸek)
    priceRange: 'medium',
  },
  
  // Kripto (dÃ¼ÅŸÃ¼k fiyatlÄ±)
  'XRP_TRY': {
    symbol: 'XRP_TRY',
    tickSize: 0.0001,      // â‚º0.0001 (tick size dominant)
    minChangePct: 0.2,     // %0.2 (Ã§ok gevÅŸek)
    priceRange: 'low',
  },
  
  // BIST hisseleri
  'THYAO': {
    symbol: 'THYAO',
    tickSize: 0.02,        // BIST tick size
    minChangePct: 0.1,     // %0.1
    priceRange: 'medium',
  },
  'AKBNK': {
    symbol: 'AKBNK',
    tickSize: 0.02,
    minChangePct: 0.1,
    priceRange: 'medium',
  },
  'GARAN': {
    symbol: 'GARAN',
    tickSize: 0.02,
    minChangePct: 0.1,
    priceRange: 'medium',
  },
};

interface Tick {
  symbol: string;
  price: number;
  timestamp: number;
}

const lastEmittedTicks = new Map<string, Tick>();
const skipCountBySymbol = new Map<string, number>();

/**
 * Sembol-duyarlÄ± emit kararÄ± (Hibrit: tick-size VE %deÄŸiÅŸim)
 */
export const shouldEmitTick = (tick: Tick): boolean => {
  const config = SYMBOL_THRESHOLDS[tick.symbol];
  
  // Bilinmeyen sembol iÃ§in default behavior (gevÅŸek)
  if (!config) {
    const lastTick = lastEmittedTicks.get(tick.symbol);
    if (!lastTick || tick.timestamp - lastTick.timestamp > 250) {
      lastEmittedTicks.set(tick.symbol, tick);
      return true;
    }
    return false;
  }

  const lastTick = lastEmittedTicks.get(tick.symbol);
  
  // Ä°lk tick, emit et
  if (!lastTick) {
    lastEmittedTicks.set(tick.symbol, tick);
    return true;
  }

  const dt = tick.timestamp - lastTick.timestamp;
  const dp = Math.abs(tick.price - lastTick.price);
  const pct = lastTick.price ? (dp / lastTick.price) : 1;

  // ÃœÃ§ emit kriteri (herhangi biri saÄŸlanÄ±rsa emit):
  // 1. Zaman delta >250ms
  // 2. Fiyat deÄŸiÅŸimi > minChangePct
  // 3. Fiyat deÄŸiÅŸimi > tickSize (mutlak)
  
  const timeThreshold = dt > 250;
  const pctThreshold = pct > (config.minChangePct / 100);
  const absThreshold = dp > config.tickSize;

  const shouldEmit = timeThreshold || pctThreshold || absThreshold;

  if (shouldEmit) {
    lastEmittedTicks.set(tick.symbol, tick);
  } else {
    // Skip count artÄ±r (metrics iÃ§in)
    const currentSkip = skipCountBySymbol.get(tick.symbol) || 0;
    skipCountBySymbol.set(tick.symbol, currentSkip + 1);
  }

  return shouldEmit;
};

/**
 * Prometheus metrikleri iÃ§in skip stats
 */
export const getSkipStats = (): Record<string, number> => {
  const stats: Record<string, number> = {};
  for (const [symbol, count] of skipCountBySymbol.entries()) {
    stats[symbol] = count;
  }
  return stats;
};

/**
 * Reset (test iÃ§in)
 */
export const resetThrottle = () => {
  lastEmittedTicks.clear();
  skipCountBySymbol.clear();
};

/**
 * Metrics export
 */
export const getDeltaThrottleMetrics = (): string[] => {
  const metrics: string[] = [
    "# HELP sse_delta_throttle_skipped_total Total ticks skipped by delta throttle",
    "# TYPE sse_delta_throttle_skipped_total counter",
  ];
  
  for (const [symbol, count] of skipCountBySymbol.entries()) {
    metrics.push(`sse_delta_throttle_skipped_total{symbol="${symbol}"} ${count}`);
  }
  
  return metrics;
};
```

**Expected Impact:**
- **XRP_TRY:** Emit rate +%35 (tick-size dominant)
- **BTC_TRY:** Emit rate korunur (%deÄŸiÅŸim dominant)
- **Network egress:** Ortalama %15â†“ (sembol karmasÄ± optimize)

---

## 2ï¸âƒ£ SSE KapalÄ± Devre Throttle (Self-Healing)

### Sorun
SSE queue depth %80 Ã¼stÃ¼ne Ã§Ä±ktÄ±ÄŸÄ±nda drop-oldest Ã§alÄ±ÅŸÄ±r ama throttle sabit kalÄ±r. Queue overflow loop'a girer.

### Ã‡Ã¶zÃ¼m
```typescript
// apps/web-next/src/app/api/market/btcturk/stream/route.ts (enhanced - PARTIAL UPDATE)

// AdaptiveSSEQueue tanÄ±mÄ±nÄ± ekle (mevcut SSEQueue yerine)
interface AdaptiveSSEQueue {
  messages: any[];
  maxSize: number;
  droppedCount: number;
  throttleCoefficient: number; // 1.0 = normal, 4.0 = max throttle
  lastAdjustmentTime: number;
}

// Adaptive throttle adjustment
function adjustThrottleCoefficient(queue: AdaptiveSSEQueue) {
  const now = Date.now();
  const queueUtilization = queue.messages.length / queue.maxSize;

  // En az 10s'de bir ayarlama yap (thrashing Ã¶nleme)
  if (now - queue.lastAdjustmentTime < 10000) {
    return;
  }

  let adjusted = false;

  // Kuyruk %80'in Ã¼zerindeyse, throttle +0.5
  if (queueUtilization > 0.8 && queue.throttleCoefficient < 4.0) {
    queue.throttleCoefficient = Math.min(4.0, queue.throttleCoefficient + 0.5);
    console.log(`[SSE Adaptive] Throttle â†‘ ${queue.throttleCoefficient.toFixed(1)}x (queue: ${queue.messages.length}/${queue.maxSize})`);
    adjusted = true;
  }

  // Kuyruk %40'Ä±n altÄ±ndaysa, throttle -0.25
  if (queueUtilization < 0.4 && queue.throttleCoefficient > 1.0) {
    queue.throttleCoefficient = Math.max(1.0, queue.throttleCoefficient - 0.25);
    console.log(`[SSE Adaptive] Throttle â†“ ${queue.throttleCoefficient.toFixed(1)}x (queue: ${queue.messages.length}/${queue.maxSize})`);
    adjusted = true;
  }

  if (adjusted) {
    queue.lastAdjustmentTime = now;
  }
}

// Queue initialization (GET handler'da)
const queue: AdaptiveSSEQueue = {
  messages: [],
  maxSize: 100,
  droppedCount: 0,
  throttleCoefficient: 1.0,
  lastAdjustmentTime: Date.now(),
};

// Her interval'da throttle ayarÄ±nÄ± kontrol et
const interval = setInterval(() => {
  const queue = sseQueues.get(clientId);
  if (!queue) return;

  // Throttle ayarlamasÄ±
  adjustThrottleCoefficient(queue);

  // Throttle coefficient'e gÃ¶re mesaj gÃ¶nder
  const messagesToSend = Math.max(1, Math.floor(10 / queue.throttleCoefficient)); // Base 10 msg/interval
  
  for (let i = 0; i < messagesToSend && queue.messages.length > 0; i++) {
    const msg = queue.messages.shift();
    const sseData = `data: ${JSON.stringify(msg)}\n\n`;
    controller.enqueue(encoder.encode(sseData));
  }

  // Throttle bilgisi
  if (queue.messages.length > 0) {
    const info = `data: ${JSON.stringify({ 
      type: 'info',
      queueDepth: queue.messages.length,
      throttleCoefficient: queue.throttleCoefficient,
    })}\n\n`;
    controller.enqueue(encoder.encode(info));
  }
}, 250);
```

**Prometheus Metrics:**
```typescript
// apps/web-next/src/app/api/tools/metrics/route.ts (ADD)

// SSE queue depth (aggregate across clients)
const avgQueueDepth = Array.from(sseQueues.values())
  .reduce((sum, q) => sum + q.messages.length, 0) / (sseQueues.size || 1);

metrics.push("# HELP sse_queue_depth_avg_gauge Average SSE queue depth across clients");
metrics.push("# TYPE sse_queue_depth_avg_gauge gauge");
metrics.push(`sse_queue_depth_avg_gauge ${Math.round(avgQueueDepth)}`);

// SSE throttle coefficient (average)
const avgThrottle = Array.from(sseQueues.values())
  .reduce((sum, q) => sum + q.throttleCoefficient, 0) / (sseQueues.size || 1);

metrics.push("# HELP sse_throttle_coefficient_avg_gauge Average throttle coefficient");
metrics.push("# TYPE sse_throttle_coefficient_avg_gauge gauge");
metrics.push(`sse_throttle_coefficient_avg_gauge ${avgThrottle.toFixed(2)}`);
```

**Expected Impact:**
- **Queue overflow:** %80â†“ (self-healing)
- **Drop events:** %60â†“ (throttle devreye girer)
- **Dashboard latency:** Stabil (queue optimize)

---

## 3ï¸âƒ£ Ä°zlenebilirlik: Trace-ID + Git SHA

### Sorun
Incident ZIP'lerde trace-ID ve kod versiyonu yok. Hangi kod versiyon-unda hangi incident oluÅŸtu belli deÄŸil.

### Ã‡Ã¶zÃ¼m
```typescript
// apps/web-next/src/app/api/tools/incident/create/route.ts (NEW)

import { execSync } from 'child_process';
import path from 'path';
import fs from 'fs';
import crypto from 'crypto';

export async function POST(req: NextRequest) {
  const { reason } = await req.json();
  const traceId = (globalThis as any).__traceId || crypto.randomUUID();

  try {
    // Git SHA al
    const gitSha = execSync('git rev-parse --short HEAD', { 
      encoding: 'utf-8',
      cwd: process.cwd()
    }).trim();

    // Git branch al
    const gitBranch = execSync('git rev-parse --abbrev-ref HEAD', { 
      encoding: 'utf-8',
      cwd: process.cwd()
    }).trim();

    // Timestamp
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const evidenceDir = path.resolve(process.cwd(), `evidence/incident_${timestamp}`);
    fs.mkdirSync(evidenceDir, { recursive: true });

    // 1. Health snapshot
    const healthResponse = await fetch('http://localhost:3003/api/healthz', { cache: 'no-store' });
    const healthData = await healthResponse.json();
    fs.writeFileSync(
      path.join(evidenceDir, 'healthz.json'),
      JSON.stringify(healthData, null, 2)
    );

    // 2. Prometheus dump (son 15 dk)
    const metricsResponse = await fetch('http://localhost:3003/api/tools/metrics?format=prometheus');
    const metricsData = await metricsResponse.text();
    fs.writeFileSync(path.join(evidenceDir, 'prometheus_metrics.txt'), metricsData);

    // 3. Logs (WS, rate-limit, SSE)
    const logFiles = ['ws_client.log', 'rate_limiter.log', 'sse_stream.log', 'bist_quality.log'];
    for (const logFile of logFiles) {
      const logPath = path.resolve(process.cwd(), `logs/${logFile}`);
      if (fs.existsSync(logPath)) {
        const logContent = fs.readFileSync(logPath, 'utf-8');
        const recentLines = logContent.split('\n').slice(-200).join('\n'); // Son 200 satÄ±r
        fs.writeFileSync(path.join(evidenceDir, logFile), recentLines);
      }
    }

    // 4. Config snapshot
    const configSnapshot = {
      env: {
        SPARK_REAL_DATA: process.env.SPARK_REAL_DATA || '0',
        NEXT_PUBLIC_EXECUTOR_URL: process.env.NEXT_PUBLIC_EXECUTOR_URL || 'unknown',
        NODE_ENV: process.env.NODE_ENV || 'unknown',
      },
      git: {
        sha: gitSha,
        branch: gitBranch,
      },
      deployment: {
        version: '1.2.0',
        timestamp,
      },
    };
    fs.writeFileSync(
      path.join(evidenceDir, 'config_snapshot.json'),
      JSON.stringify(configSnapshot, null, 2)
    );

    // 5. Incident metadata
    const incidentMeta = {
      id: `inc-${crypto.randomUUID()}`,
      traceId,
      timestamp,
      reason,
      triggeredBy: 'user', // Auth'dan Ã§ekilecek
      git: { sha: gitSha, branch: gitBranch },
      health: {
        status: healthData.status,
        latencyP95: healthData.slo?.latencyP95,
        errorRate: healthData.slo?.errorRate,
      },
    };
    fs.writeFileSync(
      path.join(evidenceDir, 'incident_meta.json'),
      JSON.stringify(incidentMeta, null, 2)
    );

    // 6. Reason text
    fs.writeFileSync(path.join(evidenceDir, 'reason.txt'), reason);

    // ZIP oluÅŸtur
    const zipPath = path.resolve(process.cwd(), `evidence/incident_${timestamp}.zip`);
    execSync(`powershell Compress-Archive -Path "${evidenceDir}\\*" -DestinationPath "${zipPath}"`);

    // Cleanup temp dir
    fs.rmSync(evidenceDir, { recursive: true });

    return NextResponse.json({
      success: true,
      incidentId: incidentMeta.id,
      traceId,
      zipPath: `evidence/incident_${timestamp}.zip`,
      git: { sha: gitSha, branch: gitBranch },
    });
  } catch (error: any) {
    console.error('[Incident] Failed to create incident ZIP:', error);
    return NextResponse.json({
      success: false,
      error: error.message,
    }, { status: 500 });
  }
}
```

**Command Palette Integration:**
```typescript
// apps/web-next/src/lib/command-palette.ts (UPDATE)

export const collectIncidentZip: CommandAction = {
  id: "ops.collect-incident-zip",
  label: "Collect Incident ZIP & Slack Page",
  description: "Generate evidence ZIP with trace-ID and Git SHA",
  icon: "ğŸš¨",
  category: "ops",
  handler: async () => {
    const reason = prompt("Incident reason (min 10 chars):");
    if (!reason || reason.length < 10) {
      return { success: false, message: "Reason required" };
    }

    try {
      const response = await fetch("/api/tools/incident/create", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ reason }),
      });

      const result = await response.json();

      // Slack webhook (opsiyonel)
      if (process.env.NEXT_PUBLIC_SLACK_WEBHOOK_URL) {
        await fetch(process.env.NEXT_PUBLIC_SLACK_WEBHOOK_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            text: `ğŸš¨ Incident: ${reason}`,
            attachments: [{
              color: "danger",
              fields: [
                { title: "Incident ID", value: result.incidentId, short: true },
                { title: "Trace ID", value: result.traceId, short: true },
                { title: "Git SHA", value: result.git.sha, short: true },
                { title: "Branch", value: result.git.branch, short: true },
                { title: "Evidence", value: result.zipPath, short: false },
              ],
            }],
          }),
        });
      }

      return {
        success: true,
        message: `Incident ZIP created: ${result.zipPath}`,
        details: result,
      };
    } catch (err) {
      return { success: false, message: `Failed: ${err}` };
    }
  },
};

// COMMANDS array'e ekle
export const COMMANDS: CommandAction[] = [
  // ... existing commands
  collectIncidentZip,
];
```

**Runbook'ta Tek SatÄ±r Arama:**
```bash
# Incident ID ile tÃ¼m log'larÄ± ara
grep "inc-abc123-def456" logs/*.log evidence/*.zip

# Trace ID ile request chain'i izle
grep "trace-xyz789" logs/audit.log
```

---

## ğŸ“Š "GeÃ§er Not" Åablonu (Hedef Ã‡Ä±ktÄ±)

```
â•â•â• FINAL GAUNTLET RESULTS â•â•â•

âœ… Gauntlet 1: Zaman ÃœÃ§lÃ¼sÃ¼ (3/3 PASS)
  âœ… Clock skew: clock_skew_ms=2500, staleness alarm YOK
  âœ… BIST tatil: market_closed=1, zero-volume silent
  âœ… DST geÃ§iÅŸ: Ã‡ift kayÄ±t YOK

âœ… Gauntlet 2: Kimlik & Kota (2/2 PASS)
  âœ… Rate limit: burst_violations=2, sustained_violations=1
  âœ… Adaptive backoff: vendor_adaptive_backoff_multiplier=1.5x

âœ… Gauntlet 3: AÄŸ Åiddeti (2/2 PASS)
  âœ… WS reconnect: concurrent_reconnects_gaugeâ‰¤2, vendor_backoff_active=1
  âœ… SSE flood: sse_dropped_events_totalâ†‘, egress â‰¤30%, RAM plato

âœ… Gauntlet 4: Kardinalite (2/2 PASS)
  âœ… TSDB series: +35% (â‰¤50% limit)
  âœ… Top-N: venue_requests_by_symbol_total 10 series

âœ… Gauntlet 5: Kill-Switch (3/3 PASS)
  âœ… Flipflop reject: flipflop_rejects_total=1, cooldown active
  âœ… Evidence ZIP: reason.txt + healthz.json + config_snapshot.json + trace_id
  âœ… Restore 25%â†’50%â†’100%: SLO alarm YOK

âœ… Gauntlet 6: Veri Kalitesi (2/2 PASS)
  âœ… Schema v1.1â†’v1.2: Side-by-side canary, parser crash YOK
  âœ… Anomaly: +12% â†’ warning, stale>30s â†’ critical reject

âœ… Gauntlet 7: Maliyet (2/2 PASS)
  âœ… Budget limit %110: Throttle active, rollout devam ediyor
  âœ… vendor_cost_usd_total tracking aktif

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SERTÄ°FÄ°KA: âœ… BAÅARILI (95% success rate)
PROD'A Ã‡IKIÅ: ONAYLANDI
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## ğŸš€ HÄ±zlÄ± Uygulama (3Ã— 30 Dakika)

### Batch 1: Delta + SSE (30 dk)
```bash
# 1. Replace sse-delta-throttle.ts (symbol matrix)
# 2. Update stream/route.ts (adaptive throttle)
# 3. Test: XRP_TRY vs BTC_TRY emit rate
# 4. Verify: sse_throttle_coefficient_avg_gauge in metrics
```

### Batch 2: Trace-ID + Git SHA (30 dk)
```bash
# 1. Create middleware.ts (trace-ID injection)
# 2. Create incident/create route
# 3. Update command-palette.ts
# 4. Test: Incident ZIP iÃ§inde trace_id + git SHA
```

### Batch 3: Rate-Limit Burst/Sustained (30 dk)
```bash
# 1. Update rate-limiter.ts (burst/sustained detection)
# 2. Update metrics/route.ts (new counters)
# 3. Update Grafana alerts (burst vs sustained)
# 4. Test: 10Ã— 429 in 10s â†’ burst alarm
```

---

*Mikro-Ä°nce Ayarlar hazÄ±r. Her biri 30 dakika, toplamda 90 dakikada "saklÄ± meteor yaÄŸmuruna" karÅŸÄ± kalkan tamamlanÄ±r.* ğŸ›¡ï¸

