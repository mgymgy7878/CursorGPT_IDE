#!/usr/bin/env tsx
/**
 * TypeScript Error Delta Calculator
 * 
 * Compares tsc output before/after to measure progress
 * 
 * Usage:
 *   pnpm -F web-next typecheck 2>&1 | node scripts/type-delta.ts before
 *   # ... make changes ...
 *   pnpm -F web-next typecheck 2>&1 | node scripts/type-delta.ts after
 */

import fs from 'node:fs';
import path from 'node:path';

const EVIDENCE_DIR = path.join(process.cwd(), 'evidence/ui');
const BEFORE_FILE = path.join(EVIDENCE_DIR, 'types-before.txt');
const AFTER_FILE = path.join(EVIDENCE_DIR, 'types-after.txt');
const DELTA_FILE = path.join(EVIDENCE_DIR, 'types-delta.md');

type ErrorSummary = {
  totalErrors: number;
  errorsByFile: Map<string, number>;
  errorsByCode: Map<string, number>;
};

function parseTypeScriptErrors(content: string): ErrorSummary {
  const lines = content.split('\n');
  const errorsByFile = new Map<string, number>();
  const errorsByCode = new Map<string, number>();
  let totalErrors = 0;

  for (const line of lines) {
    // Match: ./src/path/file.tsx:123:45
    // or: Type error: ...
    const fileMatch = line.match(/^\.\/src\/([^:]+):(\d+):(\d+)/);
    const errorMatch = line.match(/Type error: (.+)/);
    const tsCodeMatch = line.match(/TS(\d+)/);

    if (fileMatch) {
      const file = `src/${fileMatch[1]}`;
      errorsByFile.set(file, (errorsByFile.get(file) || 0) + 1);
      totalErrors++;
    }

    if (tsCodeMatch) {
      const code = `TS${tsCodeMatch[1]}`;
      errorsByCode.set(code, (errorsByCode.get(code) || 0) + 1);
    }
  }

  return { totalErrors, errorsByFile, errorsByCode };
}

function generateDeltaReport(before: ErrorSummary, after: ErrorSummary): string {
  const delta = before.totalErrors - after.totalErrors;
  const percentChange = before.totalErrors > 0 
    ? ((delta / before.totalErrors) * 100).toFixed(1)
    : '0.0';

  const lines: string[] = [
    '# TypeScript Error Delta Report',
    '',
    `**Generated:** ${new Date().toISOString()}`,
    '',
    '## Summary',
    '',
    `- **Before:** ${before.totalErrors} errors`,
    `- **After:** ${after.totalErrors} errors`,
    `- **Delta:** ${delta > 0 ? 'âœ…' : delta < 0 ? 'âŒ' : 'âž–'} ${delta} (${percentChange}%)`,
    '',
  ];

  if (delta > 0) {
    lines.push('**ðŸŽ‰ Progress! Errors reduced.**');
  } else if (delta < 0) {
    lines.push('**âš ï¸ Regression. New errors introduced.**');
  } else {
    lines.push('**âž– No change in error count.**');
  }

  lines.push('', '## By File', '');

  // Files that improved
  const improved: string[] = [];
  const regressed: string[] = [];
  const unchanged: string[] = [];

  const allFiles = new Set([
    ...before.errorsByFile.keys(),
    ...after.errorsByFile.keys()
  ]);

  for (const file of allFiles) {
    const beforeCount = before.errorsByFile.get(file) || 0;
    const afterCount = after.errorsByFile.get(file) || 0;
    const fileDelta = beforeCount - afterCount;

    if (fileDelta > 0) {
      improved.push(`- âœ… \`${file}\`: ${beforeCount} â†’ ${afterCount} (${fileDelta} fixed)`);
    } else if (fileDelta < 0) {
      regressed.push(`- âŒ \`${file}\`: ${beforeCount} â†’ ${afterCount} (${Math.abs(fileDelta)} new)`);
    } else if (afterCount > 0) {
      unchanged.push(`- âž– \`${file}\`: ${afterCount} errors`);
    }
  }

  if (improved.length > 0) {
    lines.push('### Improved', '', ...improved, '');
  }

  if (regressed.length > 0) {
    lines.push('### Regressed', '', ...regressed, '');
  }

  if (unchanged.length > 0) {
    lines.push('### Unchanged', '', ...unchanged, '');
  }

  lines.push('', '## By Error Code', '');

  const allCodes = new Set([
    ...before.errorsByCode.keys(),
    ...after.errorsByCode.keys()
  ]);

  for (const code of Array.from(allCodes).sort()) {
    const beforeCount = before.errorsByCode.get(code) || 0;
    const afterCount = after.errorsByCode.get(code) || 0;
    const codeDelta = beforeCount - afterCount;

    if (codeDelta !== 0 || afterCount > 0) {
      const icon = codeDelta > 0 ? 'âœ…' : codeDelta < 0 ? 'âŒ' : 'âž–';
      lines.push(`- ${icon} **${code}**: ${beforeCount} â†’ ${afterCount}`);
    }
  }

  lines.push('', '---', '*Generated by scripts/type-delta.ts*');

  return lines.join('\n');
}

async function main() {
  const command = process.argv[2];

  if (!command || !['before', 'after', 'report'].includes(command)) {
    console.error('Usage: type-delta.ts [before|after|report]');
    console.error('');
    console.error('Examples:');
    console.error('  pnpm -F web-next typecheck 2>&1 | tsx scripts/type-delta.ts before');
    console.error('  pnpm -F web-next typecheck 2>&1 | tsx scripts/type-delta.ts after');
    console.error('  tsx scripts/type-delta.ts report');
    process.exit(1);
  }

  // Ensure evidence directory exists
  if (!fs.existsSync(EVIDENCE_DIR)) {
    fs.mkdirSync(EVIDENCE_DIR, { recursive: true });
  }

  if (command === 'before') {
    // Read from stdin and save as before
    let input = '';
    for await (const chunk of process.stdin) {
      input += chunk;
    }
    fs.writeFileSync(BEFORE_FILE, input, 'utf8');
    const summary = parseTypeScriptErrors(input);
    console.log(`âœ… Baseline saved: ${summary.totalErrors} errors`);
  } else if (command === 'after') {
    // Read from stdin and save as after
    let input = '';
    for await (const chunk of process.stdin) {
      input += chunk;
    }
    fs.writeFileSync(AFTER_FILE, input, 'utf8');
    const summary = parseTypeScriptErrors(input);
    console.log(`âœ… After saved: ${summary.totalErrors} errors`);

    // Auto-generate report
    if (fs.existsSync(BEFORE_FILE)) {
      const beforeContent = fs.readFileSync(BEFORE_FILE, 'utf8');
      const beforeSummary = parseTypeScriptErrors(beforeContent);
      const report = generateDeltaReport(beforeSummary, summary);
      fs.writeFileSync(DELTA_FILE, report, 'utf8');
      console.log(`\nðŸ“Š Delta report: evidence/ui/types-delta.md`);
      console.log(`\nProgress: ${beforeSummary.totalErrors} â†’ ${summary.totalErrors} (${beforeSummary.totalErrors - summary.totalErrors} fixed)`);
    }
  } else if (command === 'report') {
    // Generate report from saved files
    if (!fs.existsSync(BEFORE_FILE) || !fs.existsSync(AFTER_FILE)) {
      console.error('âŒ Missing before/after files. Run "before" and "after" first.');
      process.exit(1);
    }

    const beforeContent = fs.readFileSync(BEFORE_FILE, 'utf8');
    const afterContent = fs.readFileSync(AFTER_FILE, 'utf8');
    const beforeSummary = parseTypeScriptErrors(beforeContent);
    const afterSummary = parseTypeScriptErrors(afterContent);
    const report = generateDeltaReport(beforeSummary, afterSummary);

    fs.writeFileSync(DELTA_FILE, report, 'utf8');
    console.log(report);
    console.log(`\nðŸ“Š Report saved: evidence/ui/types-delta.md`);
  }
}

main().catch(err => {
  console.error('Error:', err);
  process.exit(1);
});

