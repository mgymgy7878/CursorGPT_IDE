# P1.2 Live Layer Minimum Patch — Delta (Düzeltme Paketi)

## Kritik Sorunlar ve Düzeltmeler

Bu doküman, `P1.2_LIVE_LAYER_MINIMUM_PATCH.md` planındaki 8 kritik sorunu düzeltir.

---

## 1. Copilot Akışı: "Subscribe" Değil, Request-Scoped Stream

### Sorun

`/api/copilot/chat` tipik olarak "prompt gönder → stream'i oku → biter". `LiveClient.connect()` içindeki "subscribe, channels: ['copilot:chat']" yaklaşımı gerçek chat akışıyla çakışır (prompt yokken stream açılmaz / anlamsız kalır).

### Düzeltme

**LiveClient yerine Copilot için şu interface daha doğru:**

**Dosya:** `packages/live-core/src/copilot/startCopilotStream.ts`

```typescript
import type { LiveEvent } from '../envelope/LiveEvent.js';
import { SSEParser } from '../sse/SSEParser.js';

export interface CopilotStreamCallbacks {
  onEvent?: (event: LiveEvent) => void;
  onError?: (error: Error) => void;
  onComplete?: () => void;
}

export interface CopilotStreamSession {
  abort(): void;
}

/**
 * Start a request-scoped Copilot stream (not a persistent subscribe)
 *
 * P1.2: UI'dan "Gönder"e basınca çağrılır; parsing UI'da değil live-core'da kalır
 */
export async function startCopilotStream(
  payload: { message: string; requestId?: string },
  callbacks: CopilotStreamCallbacks
): Promise<CopilotStreamSession> {
  const abortController = new AbortController();
  const parser = new SSEParser();

  const run = async () => {
    try {
      const response = await fetch('/api/copilot/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
        signal: abortController.signal,
      });

      if (!response.ok) {
        throw new Error(`Copilot stream failed: ${response.status}`);
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error('No response body');
      }

      const decoder = new TextDecoder();

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value, { stream: true });
        parser.feed(chunk);

        // Parse complete events
        for (const event of parser.parse()) {
          callbacks.onEvent?.(event);
        }
      }

      // Normal completion
      callbacks.onComplete?.();
    } catch (error: any) {
      if (error.name === 'AbortError') {
        // Client abort → don't call onError
        return;
      }
      callbacks.onError?.(error instanceof Error ? error : new Error(String(error)));
    }
  };

  run();

  return {
    abort: () => {
      abortController.abort();
    },
  };
}
```

**Dosya:** `packages/live-core/src/index.ts` (export ekle)

```typescript
export * from './copilot/startCopilotStream.js';
```

---

## 2. SSE Parsing: Chunk Boundary Problemi

### Sorun

`chunk.split('\n')` yaklaşımı SSE'de yanlış parse üretir. Çünkü `data:` satırı TCP chunk ortasında bölünebilir; `\n\n` event delimiter'ını kaçırırsın.

### Düzeltme

**SSEParser ekle: buffer biriktirsin, `\n\n` yakalayınca event'i çıkarsın.**

**Dosya:** `packages/live-core/src/sse/SSEParser.ts`

```typescript
import { validateLiveEventMinimal } from '../envelope/LiveEvent.js';
import type { LiveEvent } from '../envelope/LiveEvent.js';

/**
 * SSE Parser - buffer-based, handles chunk boundaries correctly
 *
 * P1.2: Her event için data: satırlarını birleştirip JSON parse et
 */
export class SSEParser {
  private buffer = '';

  /**
   * Feed chunk data (may be partial)
   */
  feed(chunk: string): void {
    this.buffer += chunk;
  }

  /**
   * Parse complete events from buffer (up to \n\n delimiter)
   *
   * Returns array of parsed LiveEvents
   */
  parse(): LiveEvent[] {
    const events: LiveEvent[] = [];
    let eventEndIndex: number;

    // Find complete events (delimited by \n\n)
    while ((eventEndIndex = this.buffer.indexOf('\n\n')) !== -1) {
      const eventText = this.buffer.slice(0, eventEndIndex);
      this.buffer = this.buffer.slice(eventEndIndex + 2); // Remove parsed event + delimiter

      const event = this.parseEvent(eventText);
      if (event) {
        events.push(event);
      }
    }

    return events;
  }

  /**
   * Parse a single SSE event (text up to \n\n)
   */
  private parseEvent(eventText: string): LiveEvent | null {
    const lines = eventText.split('\n').filter(line => line.trim() !== '');
    let dataLines: string[] = [];

    for (const line of lines) {
      if (line.startsWith('data: ')) {
        dataLines.push(line.slice(6)); // Remove 'data: ' prefix
      }
      // Ignore other SSE fields (event:, id:, retry:) for now
    }

    if (dataLines.length === 0) {
      return null; // No data field
    }

    // Join multi-line data (SSE spec allows this)
    const dataJson = dataLines.join('\n');

    try {
      const raw = JSON.parse(dataJson);

      // Minimal validation (client girişinde)
      if (validateLiveEventMinimal(raw)) {
        return raw as LiveEvent;
      } else {
        // Invalid event → drop
        console.warn('Invalid LiveEvent dropped:', raw);
        return null;
      }
    } catch (error) {
      // Malformed JSON → drop
      console.warn('Malformed JSON dropped:', dataJson);
      return null;
    }
  }

  /**
   * Get remaining buffer (for debugging)
   */
  getBuffer(): string {
    return this.buffer;
  }

  /**
   * Clear buffer
   */
  clear(): void {
    this.buffer = '';
  }
}
```

**Dosya:** `packages/live-core/src/index.ts` (export ekle)

```typescript
export * from './sse/SSEParser.js';
```

---

## 3. Hook'ların İkiz Bağlantı Açma Riski

### Sorun

Hem `CopilotDock` hem `StatusBar` `useCopilotStream()` çağırırsa iki `LiveClient` oluşur → iki stream → iki kat yük + garip UI.

### Düzeltme

**"Tek client, çok consumer" - Client'ı store seviyesinde singleton yap:**

**Dosya:** `packages/live-react/src/store/copilotSession.ts`

```typescript
import { startCopilotStream, type CopilotStreamCallbacks } from '@spark/live-core';
import type { LiveEvent } from '@spark/live-core';

/**
 * Singleton Copilot session manager (refCount-based)
 *
 * P1.2: İlk consumer mount → session başlat, refCount 0 olunca kapat
 */
class CopilotSessionManager {
  private session: ReturnType<typeof startCopilotStream> | null = null;
  private refCount = 0;
  private callbacks: CopilotStreamCallbacks[] = [];

  /**
   * Register a consumer (increment refCount)
   */
  register(callbacks: CopilotStreamCallbacks): () => void {
    this.refCount++;
    this.callbacks.push(callbacks);

    // First consumer → start session
    if (this.refCount === 1) {
      this.start();
    }

    // Return unregister function
    return () => {
      this.refCount--;
      this.callbacks = this.callbacks.filter(cb => cb !== callbacks);

      // Last consumer → stop session
      if (this.refCount === 0) {
        this.stop();
      }
    };
  }

  private async start(): Promise<void> {
    // P1.2: Session başlatma logic'i buraya (şimdilik boş, request-scoped olduğu için)
    // Gerçek implementasyonda: startCopilotStream() çağrılır
  }

  private stop(): void {
    if (this.session) {
      this.session.abort();
      this.session = null;
    }
  }

  /**
   * Get current refCount (for debugging)
   */
  getRefCount(): number {
    return this.refCount;
  }
}

export const copilotSessionManager = new CopilotSessionManager();
```

**Dosya:** `packages/live-react/src/hooks/useCopilotStream.ts` (güncelle)

```typescript
import { useEffect, useRef } from 'react';
import { copilotSessionManager } from '../store/copilotSession.js';
import { useLiveStore } from './liveStore.js';

export function useCopilotStream() {
  const { /* ... */ } = useLiveStore();
  const unregisterRef = useRef<(() => void) | null>(null);

  useEffect(() => {
    const callbacks = {
      onEvent: (event) => {
        // Handle events
      },
      onError: (error) => {
        // Handle errors
      },
      onComplete: () => {
        // Handle completion
      },
    };

    // Register consumer (increment refCount)
    unregisterRef.current = copilotSessionManager.register(callbacks);

    return () => {
      // Unregister consumer (decrement refCount)
      if (unregisterRef.current) {
        unregisterRef.current();
        unregisterRef.current = null;
      }
    };
  }, []);

  // ... return store state
}
```

---

## 4. Token Başına "Yeni Mesaj" Patlaması

### Sorun

Token event'i genelde parça parça gelir. Her token'ı `addCopilotMessage` ile ayrı mesaj yapıyorsun; 2 dakikada binlerce mesaj olur.

### Düzeltme

**Stream assembly: Store'da `activeMessageId` tut, token gelince aynı mesajın content'ine append et.**

**Dosya:** `packages/live-react/src/store/liveStore.ts` (güncelle)

```typescript
interface LiveStoreState {
  // Copilot stream
  copilotMessages: Array<{ id: string; content: string; timestamp: Date }>;
  activeMessageId: string | null; // P1.2: Stream assembly için
  activeMessageContent: string;   // P1.2: Token'ları birleştir
  copilotStatus: LiveClientStatus;
  copilotStaleness: { status: 'ok' | 'warn' | 'stale'; seconds: number } | null;

  // Actions
  startMessage: (messageId: string) => void;
  appendToken: (token: string) => void;
  finalizeMessage: () => void;
  // ... diğer actions
}

export const useLiveStore = create<LiveStoreState>((set, get) => ({
  copilotMessages: [],
  activeMessageId: null,
  activeMessageContent: '',
  // ...

  startMessage: (messageId) =>
    set({
      activeMessageId: messageId,
      activeMessageContent: '',
    }),

  appendToken: (token) =>
    set((state) => {
      if (!state.activeMessageId) {
        // No active message → start one
        const newId = `msg_${Date.now()}`;
        return {
          activeMessageId: newId,
          activeMessageContent: token,
        };
      }
      return {
        activeMessageContent: state.activeMessageContent + token,
      };
    }),

  finalizeMessage: () =>
    set((state) => {
      if (state.activeMessageId && state.activeMessageContent) {
        const message = {
          id: state.activeMessageId,
          content: state.activeMessageContent,
          timestamp: new Date(),
        };
        return {
          copilotMessages: [...state.copilotMessages, message],
          activeMessageId: null,
          activeMessageContent: '',
        };
      }
      return {
        activeMessageId: null,
        activeMessageContent: '',
      };
    }),
}));
```

**Dosya:** `packages/live-react/src/hooks/useCopilotStream.ts` (güncelle)

```typescript
const {
  copilotMessages,
  activeMessageId,
  activeMessageContent,
  startMessage,
  appendToken,
  finalizeMessage,
  // ...
} = useLiveStore();

// Event handler'da:
if (event.event === 'token' && event.data?.content) {
  appendToken(event.data.content);
} else if (event.event === 'message_done' || event.event === 'stream_end') {
  finalizeMessage();
}
```

---

## 5. Server Import: "Barrel Export" Tuzağı

### Sorun

`route.ts` içinde `@spark/live-core`'dan import edersen Next bundler bazen `LiveClient` gibi browser-side parçaları da server bundle'a çekebilir (tree-shaking garanti değil).

### Düzeltme

**Subpath exports: `package.json` exports'ta şunları aç:**

**Dosya:** `packages/live-core/package.json` (güncelle)

```json
{
  "name": "@spark/live-core",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    },
    "./envelope": {
      "import": "./dist/envelope/index.js",
      "types": "./dist/envelope/index.d.ts"
    },
    "./staleness": {
      "import": "./dist/staleness/index.js",
      "types": "./dist/staleness/index.d.ts"
    },
    "./sse": {
      "import": "./dist/sse/index.js",
      "types": "./dist/sse/index.d.ts"
    }
  }
}
```

**Dosya:** `packages/live-core/src/envelope/index.ts` (yeni)

```typescript
export * from './LiveEvent.js';
export * from './versioning.js';
```

**Dosya:** `packages/live-core/src/staleness/index.ts` (yeni)

```typescript
export * from './policies.js';
export * from './computeStaleness.js';
```

**Dosya:** `packages/live-core/src/sse/index.ts` (yeni)

```typescript
export * from './SSEParser.js';
```

**Server tarafında:**

```typescript
// ✅ Server sadece envelope'u import eder
import { validateLiveEvent } from '@spark/live-core/envelope';

// ❌ Server LiveClient'ı import etmez (browser-only)
```

---

## 6. NodeJS.Timeout Tipi Browser'da Problem

### Sorun

`LiveClient` tarayıcıda çalışacaksa `NodeJS.Timeout` TS hatası/karmaşası çıkarabilir.

### Düzeltme

**Dosya:** `packages/live-core/src/client/LiveClient.ts` (güncelle)

```typescript
export class LiveClient {
  private reconnectTimer: ReturnType<typeof setTimeout> | null = null;
  private heartbeatTimer: ReturnType<typeof setInterval> | null = null;
  // ...
}
```

**Dosya:** `packages/live-core/src/client/DegradeMode.ts` (varsa, güncelle)

```typescript
// Aynı şekilde ReturnType<typeof setTimeout> kullan
```

---

## 7. Stream Normal Bittiğinde Status "Connected" Kalıyor

### Sorun

SSE loop `done` ile biterse şu an:
- Status'u düşürmüyorsun
- Reconnect tetiklemiyorsun
- Heartbeat çalışıyorsa kendi kendine reconnect'e zorlayabilir

### Düzeltme

**"Normal completion" = idle/disconnected (ve reconnect yok), "network error" = reconnect/backoff**

**Dosya:** `packages/live-core/src/copilot/startCopilotStream.ts` (güncelle)

```typescript
export async function startCopilotStream(
  payload: { message: string; requestId?: string },
  callbacks: CopilotStreamCallbacks
): Promise<CopilotStreamSession> {
  const abortController = new AbortController();
  const parser = new SSEParser();
  let isAborted = false;

  const run = async () => {
    try {
      // ... fetch logic

      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          // Normal completion → don't reconnect
          if (!isAborted) {
            callbacks.onComplete?.();
          }
          break;
        }

        // ... parse logic
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        // Client abort → don't call onError or reconnect
        isAborted = true;
        return;
      }
      // Network error → call onError (reconnect logic caller'da)
      callbacks.onError?.(error instanceof Error ? error : new Error(String(error)));
    }
  };

  run();

  return {
    abort: () => {
      isAborted = true;
      abortController.abort();
    },
  };
}
```

---

## 8. getStalenessPolicy Export Eksik + Event Tipleri Uyuşmazlığı

### Sorun

Hook'ta `getStalenessPolicy` kullanıyorsun ama index'te export yok. Ayrıca copilot event tipleri sadece `token` değil: `tool_call`, `tool_result`, `job_*`, `error` vb.

### Düzeltme

**getStalenessPolicy export et + Copilot store reducer'ında temel event setini karşıla**

**Dosya:** `packages/live-core/src/staleness/index.ts` (güncelle)

```typescript
export * from './policies.js';
export * from './computeStaleness.js';

// Explicit export
export { getStalenessPolicy } from './policies.js';
```

**Dosya:** `packages/live-react/src/hooks/useCopilotStream.ts` (güncelle)

```typescript
import { getStalenessPolicy } from '@spark/live-core/staleness';

// Event handler'da:
if (event.event === 'token' && event.data?.content) {
  appendToken(event.data.content);
} else if (event.event === 'tool_call') {
  // Timeline entry (opsiyonel, ama CopilotDock'un bugünkü UX'ini kırmamak için kritik)
  addTimelineEntry({ type: 'tool_call', data: event.data });
} else if (event.event === 'tool_result') {
  addTimelineEntry({ type: 'tool_result', data: event.data });
} else if (event.event.startsWith('job_')) {
  // Job events → job store slice'a pasla (P1.2'de minimum sadece forward bile olur)
  forwardToJobStore(event);
} else if (event.event === 'error') {
  // Error handling
  handleError(event.data);
}
```

**Dosya:** `packages/live-react/src/store/liveStore.ts` (güncelle)

```typescript
interface LiveStoreState {
  // ...
  timeline: Array<{ type: string; data: any; timestamp: Date }>; // P1.2: Tool calls/results timeline
  // ...
  addTimelineEntry: (entry: { type: string; data: any }) => void;
  forwardToJobStore: (event: LiveEvent) => void;
}
```

---

## 9. Smoke Test: "UI Parsing Yok" Grep Düzeltmesi

### Sorun

"UI'da raw parsing yok" grep'i false-positive üretebilir.

### Düzeltme

**Pattern önerisi: `getReader\(`, `EventSource`, `new WebSocket`, `data:\s` gibi**

**Dosya:** `tools/copilot-smoke-test.ps1` (güncelle)

```powershell
# Test 15: UI parsing yok (yasak)
Write-Host "[15/16] UI Raw Parsing Kontrolü (Yasak)..." -ForegroundColor Yellow

# Exclude live-* packages (they're allowed to parse)
$excludeDirs = @("packages/live-core", "packages/live-react")

# Search in components and app directories only
$searchPaths = @(
    "apps/web-next/src/components/**/*.tsx",
    "apps/web-next/src/app/**/*.tsx"
)

$violations = @()

foreach ($path in $searchPaths) {
    $files = Get-ChildItem -Path $path -Recurse -Filter "*.tsx" -ErrorAction SilentlyContinue

    foreach ($file in $files) {
        # Skip if in exclude dirs
        $relativePath = $file.FullName.Replace((Get-Location).Path, "").Replace("\", "/")
        $shouldExclude = $excludeDirs | Where-Object { $relativePath -like "*$_*" }
        if ($shouldExclude) { continue }

        $content = Get-Content $file.FullName -Raw
        $lineNumber = 1

        # Patterns to detect raw parsing (yasak)
        $patterns = @(
            "\.getReader\s*\(",
            "new\s+EventSource\s*\(",
            "new\s+WebSocket\s*\(",
            "data:\s*"  # SSE data: field parsing
        )

        foreach ($line in $content -split "`n") {
            foreach ($pattern in $patterns) {
                if ($line -match $pattern) {
                    # Allow if it's in a comment or string literal
                    if ($line -notmatch "//.*$pattern" -and $line -notmatch "`".*$pattern.*`"") {
                        $violations += "$($file.FullName):$lineNumber - $line"
                    }
                }
            }
            $lineNumber++
        }
    }
}

if ($violations.Count -gt 0) {
    Write-Host "  ❌ FAIL: UI'da raw SSE/WS parsing bulundu:" -ForegroundColor Red
    $violations | ForEach-Object { Write-Host "    $_" -ForegroundColor Red }
} else {
    Write-Host "  ✅ PASS: UI'da raw SSE/WS parsing yok (sadece hooks kullanılıyor)" -ForegroundColor Green
}
```

**Not:** `hooks` içinde `fetch('/api/copilot/chat')` kalabilir ama stream okuma/parsing kalmamalı (asıl yasak bu).

---

## 10. Dosya Listesi (Delta Eklemeleri)

### Yeni Dosyalar (Delta)

**Core:**
- `packages/live-core/src/sse/SSEParser.ts` (buffer-based parsing)
- `packages/live-core/src/copilot/startCopilotStream.ts` (request-scoped stream)
- `packages/live-core/src/envelope/index.ts` (subpath export)
- `packages/live-core/src/staleness/index.ts` (subpath export + getStalenessPolicy export)
- `packages/live-core/src/sse/index.ts` (subpath export)

**React:**
- `packages/live-react/src/store/copilotSession.ts` (singleton session manager)

### Değiştirilecek Dosyalar (Delta)

**Core:**
- `packages/live-core/src/client/LiveClient.ts` → `ReturnType<typeof setTimeout>` (NodeJS.Timeout yerine)
- `packages/live-core/src/index.ts` → export eklemeleri
- `packages/live-core/package.json` → subpath exports

**React:**
- `packages/live-react/src/store/liveStore.ts` → `activeMessageId`, `activeMessageContent`, `timeline` alanları + actions
- `packages/live-react/src/hooks/useCopilotStream.ts` → `copilotSessionManager` kullanımı + event type handling

**Backend:**
- `apps/web-next/src/app/api/copilot/chat/route.ts` → `@spark/live-core/envelope` import (subpath)

**UI:**
- `apps/web-next/src/components/copilot/CopilotDock.tsx` → `useCopilotChat()` kullanımı (request-scoped)
- `apps/web-next/src/components/StatusBar.tsx` → store'dan status okur (client başlatmaz)

**Test:**
- `tools/copilot-smoke-test.ps1` → grep pattern düzeltmesi

---

## 11. Interface Özeti (Güncellenmiş)

### startCopilotStream Interface

```typescript
function startCopilotStream(
  payload: { message: string; requestId?: string },
  callbacks: CopilotStreamCallbacks
): Promise<CopilotStreamSession>;

interface CopilotStreamSession {
  abort(): void;
}
```

### Store Shape (Güncellenmiş)

```typescript
interface LiveStoreState {
  copilotMessages: Array<{ id: string; content: string; timestamp: Date }>;
  activeMessageId: string | null;        // P1.2: Stream assembly
  activeMessageContent: string;          // P1.2: Token birleştirme
  timeline: Array<{ type: string; data: any; timestamp: Date }>; // P1.2: Tool calls/results
  copilotStatus: 'idle' | 'streaming' | 'error';
  copilotStaleness: { status: 'ok' | 'warn' | 'stale'; seconds: number } | null;
  backpressureDrops: number;
}
```

### Hook İmzası (Güncellenmiş)

```typescript
function useCopilotChat(): {
  messages: Array<{ id: string; content: string; timestamp: Date }>;
  activeMessage: string | null;  // P1.2: Stream assembly için
  timeline: Array<{ type: string; data: any; timestamp: Date }>;
  status: 'idle' | 'streaming' | 'error';
  staleness: { status: 'ok' | 'warn' | 'stale'; seconds: number } | null;
  send: (message: string) => Promise<void>;
  cancel: () => void;
};
```

---

## 12. Mimari Doğruluk Testi

**"Her şey canlı" hedefinin kırmızı çizgisi:**

✅ **UI bağlantı yönetmesin, UI yalnızca state okusun.**

✅ **Copilot özelinde "canlılık", "tek uzun subscribe" değil, "her chat request'i bir stream" olduğu için Live Layer'ı session-based kurarsan hem doğru hem dayanıklı olur.**

**Delta ile düzeltilen sorunlar:**
1. ✅ Request-scoped stream (subscribe değil)
2. ✅ SSE chunk boundary handling
3. ✅ Singleton session manager (ikiz bağlantı yok)
4. ✅ Stream assembly (token birleştirme)
5. ✅ Subpath exports (server/browser ayrımı)
6. ✅ Browser-compatible timer types
7. ✅ Normal completion vs network error ayrımı
8. ✅ Event type handling (token, tool_call, tool_result, job_*)
9. ✅ Smoke test grep düzeltmesi

---

## Sonuç

Bu delta ile minimum patch planı "gerçekten minimum ama sağlam" olur. Tüm kritik sorunlar düzeltildi, refactor-safe mimari sağlandı.

