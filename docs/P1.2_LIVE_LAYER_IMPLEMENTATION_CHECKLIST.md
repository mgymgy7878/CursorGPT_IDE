# P1.2 Live Layer Implementation Checklist — Uygulama Sırası ve Kabul Kriterleri

## Genel Bakış

Bu checklist, `P1.2_LIVE_LAYER_MINIMUM_PATCH.md` ve `P1.2_LIVE_LAYER_MINIMUM_PATCH_DELTA.md` planlarını uygularken takip edilecek adımları ve kabul kriterlerini içerir.

**Hedef:** UI refactor-safe bir "canlı sinir sistemi" omurgası kurmak.

---

## Uygulama Sırası (5 Adım)

### 1. live-core → Çekirdek Kontrat + SSEParser + Copilot Session

**Sıra:**

1. Paket oluşturma (`packages/live-core/package.json`, `tsconfig.json`)
2. Envelope + Zod validation (`envelope/LiveEvent.ts`)
3. SSEParser (`sse/SSEParser.ts`)
4. startCopilotStream (`copilot/startCopilotStream.ts`)
5. Subpath exports (`package.json` exports)

**SSEParser Mutlaka Şu 3 Şeyi Doğru Yapsın:**

✅ **Chunk Boundary:**

- Buffer biriktirip `\n\n` ile event ayırma
- TCP chunk ortasında bölünen `data:` satırları doğru parse edilmeli
- Test: `"data: {json}\n\n"` iki chunk'a bölünmüş gelirse → tek event

✅ **Multi-line data::**

- Aynı event içindeki `data:` satırlarını birleştirip parse etme
- SSE spec: `data: line1\ndata: line2\n\n` → `"line1\nline2"` JSON parse edilmeli

✅ **"Çöp Satır" Toleransı:**

- `: comment` / boş satır / bilinmeyen alanları atlayabilme
- `event:`, `id:`, `retry:` gibi alanlar ignore edilmeli (şimdilik)

**startCopilotStream() Kontrolleri:**

✅ **abort() Garantisi:**

- `abort()` çağrılınca `AbortController.abort()` tetiklenmeli
- Stream kapanmalı, `onError` çağrılmamalı (normal abort)

✅ **"Normal Completion" vs "Network Error" Ayrımı:**

- `reader.read()` → `done: true` → `onComplete()` çağrılmalı (reconnect yok)
- Network error → `onError()` çağrılmalı (reconnect logic caller'da)

**Kabul Kriteri:**

- [ ] SSEParser unit test: chunk boundary (data satırı ortadan bölünmüş iki chunk)
- [ ] SSEParser unit test: multi-line data
- [ ] SSEParser unit test: çöp satır toleransı
- [ ] SSEParser unit test: CRLF delimiter (`\r\n\r\n` ile event ayrımı) ⚠️ Critical
- [ ] SSEParser unit test: JSON split + multi-line birlikte (data: satırı ortadan bölünmüş + aynı event içinde 2 data: satırı → tek payload birleşip parse olmalı) ⚠️ Critical
- [ ] startCopilotStream unit test: abort() garantisi
- [ ] startCopilotStream unit test: normal completion vs network error

**⚠️ Critical Add-on: SSEParser Gerçek Dünya Testleri**

✅ **CRLF Delimiter Testi:**

- Parser hem `\n\n` hem `\r\n\r\n` ile düzgün ayırıyor (bazı proxy'ler / server impl'leri CRLF kullanır)
- Test: `"data: {...}\r\n\r\n"` → tek event parse edilmeli

✅ **JSON Split + Multi-line Birlikte Testi:**

- `data:` satırı ortadan bölünmüş + aynı event içinde 2 `data:` satırı → tek payload birleşip parse olmalı
- Test: `"data: {\"v\":1"` (chunk 1) + `",\"event\":\"token\"}\n"` (chunk 2) + `"data: {\"v\":1,\"event\":\"token\"}\n\n"` → 2 event parse edilmeli

**Kabul:** Parser hem `\n\n` hem `\r\n\r\n` ile düzgün ayırıyor; event başına `data:` birleşimi stabil.

---

### 2. route.ts → Tek Çıkış Formatı (Envelope) + Seq Semantiği

**Sıra:**

1. Mevcut SSE event'lerini envelope formatına çevir
2. `seq` semantiği ekle (stream scope içinde monoton artan)
3. Event tipleri standardize et
4. Gateway çıkışında Zod validation

**Her SSE "data:" Payload'ı LiveEvent Olsun (v1):**

✅ **Zorunlu Alanlar:**

- `v: 1` (version)
- `event: string` (event type)
- `channel: 'copilot:chat'` (channel identifier)
- `seq: number` (monoton artan, request başına sıfırlanabilir)
- `ts: number` (timestamp ms)
- `ok: boolean` (success/failure)
- `data: any` (event-specific payload)

✅ **Seq Semantiği:**

- Stream scope içinde monoton artmalı (request başına sıfırlanabilir)
- Her yeni request → `seq` 0'dan başlar
- Aynı request içinde: `seq: 0, 1, 2, ...`

**⚠️ Critical: Gateway'de Seq Reset Kuralını Yazılı Hale Getir**

✅ **Seq Reset Kuralları:**

- Her Copilot request'inde `seq = 0`'dan başlar
- Aynı request içinde monoton artar (`seq: 0, 1, 2, ...`)
- `message_done` geldiğinde o stream biter; yeni stream yeni seq space
- Bu, ileride replay/debug yaparken "aynı kanalda seq karıştı" kabusunu engeller

**Kabul:** Her request yeni seq space başlatır; seq karışmaz.

**Event Tipleri "En Az" Şu Seti Taşısın:**

✅ **Token Events:**

- `token` → `{ content: string }` (content parçaları)

✅ **Message Events:**

- `message_done` → `{}` (stream tamamlandı)

✅ **Tool Events:**

- `tool_call` → `{ tool: string, params: any }`
- `tool_result` → `{ tool: string, result: any }`

✅ **Job Events:**

- `job_started` → `{ jobId: string }`
- `job_progress` → `{ jobId: string, progress: number, phase: string }`
- `job_done` → `{ jobId: string }`
- `job_failed` → `{ jobId: string, error: string }`

✅ **Error Events:**

- `error` → `{ errorCode: string, message: string }`

**Gateway Çıkışında Zod Validation:**

✅ **Her Event Göndermeden Önce:**

```typescript
import { validateLiveEvent } from "@spark/live-core/envelope";

const validation = validateLiveEvent(event);
if (!validation.valid) {
  console.error("Invalid LiveEvent:", validation.error);
  return; // Drop invalid event
}
```

**"UI Parsing Yok" Hedefi:**

✅ **Route.ts Zaten SSE Yazıyor:**

- UI artık sadece hook/store okur
- Raw SSE parsing UI'da yok (yasak)

**Kabul Kriteri:**

- [ ] Tüm mevcut SSE event'leri envelope formatına çevrildi
- [ ] `seq` stream scope içinde monoton artıyor (request başına sıfırlanıyor)
- [ ] Tüm event tipleri standardize edildi (token, message*done, tool*\_, job\_\_, error)
- [ ] Gateway çıkışında Zod validation çalışıyor
- [ ] Invalid event'ler drop ediliyor (log + skip)

**⚠️ Critical Add-on: route.ts Streaming Stabilitesi**

✅ **Next/Edge/Node Farklarında SSE'nin "Sessizce Bozulmasını" Engeller:**

```typescript
// route.ts başına ekle:
export const runtime = "nodejs"; // SSE için en az sürpriz
export const dynamic = "force-dynamic"; // Cache/ISR sürprizlerini kapatır

// Response header set'i:
headers.set("Content-Type", "text/event-stream; charset=utf-8");
headers.set("Cache-Control", "no-cache, no-transform");
headers.set("Connection", "keep-alive");
```

**Kabul:** Prod reverse-proxy arkasında da stream "parça parça" akıyor, tek seferde bufferlanmıyor.

---

### 3. live-react → Store + Session Manager + Assembly

**Sıra:**

1. Paket oluşturma (`packages/live-react/package.json`, `tsconfig.json`)
2. copilotSessionManager (`store/copilotSession.ts`)
3. liveStore (`store/liveStore.ts`)
4. useCopilotChat hook (`hooks/useCopilotChat.ts`)

**copilotSessionManager Kontrolleri:**

✅ **Singleton + RefCount Şart:**

- Dock + StatusBar ikiz bağlantı açmayacak
- İlk consumer mount → session başlat (refCount: 0 → 1)
- İkinci consumer mount → refCount artar (refCount: 1 → 2)
- Consumer unmount → refCount azalır
- refCount 0 → session kapanacak

✅ **RefCount Testi:**

- CopilotDock mount → refCount: 1
- StatusBar mount → refCount: 2 (aynı session)
- StatusBar unmount → refCount: 1 (session açık kalır)
- CopilotDock unmount → refCount: 0 (session kapanır)

**Store'da Bellek Sınırı:**

✅ **Messages:**

- Max 200 mesaj (drop oldest)
- `messages.length > 200` → `messages.shift()` (en eski mesajı sil)

✅ **Timeline:**

- Max 300 entry (drop oldest)
- `timeline.length > 300` → `timeline.shift()` (en eski entry'yi sil)

✅ **activeMessageContent:**

- Byte limiti (örn 32KB-64KB) ⚠️ Critical: char ≠ byte
- Limit ölçümü: `TextEncoder().encode(str).length` (UTF-8'te emoji/çok baytlı karakterler char sayısını bozar)
- Taşarsa → `truncated: true` flag set et
- UI'da "Message truncated" uyarısı göster

**⚠️ Critical Add-on: Byte Limit (char ≠ byte)**

✅ **UTF-8 Byte Ölçümü:**

- `activeMessageContent.length` → char sayısı (yanlış)
- `TextEncoder().encode(activeMessageContent).length` → byte sayısı (doğru)
- Limit gerçekten payload boyutunu kontrol ediyor; "görünürde küçük ama byte'ta büyük" içeriklerde patlamıyor

**Kabul:** Limit gerçekten payload boyutunu kontrol ediyor; "görünürde küçük ama byte'ta büyük" içeriklerde patlamıyor.

**Token Assembly:**

✅ **Token → activeMessageContent:**

- `token` event → `activeMessageContent += chunk`
- `activeMessageId` yoksa → yeni message başlat (`msg_${Date.now()}`)

✅ **message_done → Finalize:**

- `message_done` event → finalize edip `messages[]` içine ekle
- `activeMessageId` ve `activeMessageContent` resetle

**⚠️ Critical Add-on: Store'da Date Yerine ts: number**

✅ **JSON-Serializable State:**

- `timestamp: Date` → `ts: number` (Zustand bunu kaldırır ama SSR/CSR boundary'de, persist/devtools kullanımında, future "event replay" işlerinde number daha güvenli)
- UI tarafında render'da: `new Date(ts)`
- Store state JSON-serializable kalıyor (debug/replay kolaylaşıyor)

**Kabul:** Store state JSON-serializable kalıyor (debug/replay kolaylaşıyor).

**⚠️ Store'a Eklenmesi Gereken Minimal Telemetry Alanları**

✅ **Telemetry Alanları (Date değil ts:number — checklist kuralına uygun):**

```typescript
interface LiveStoreState {
  // Copilot stream
  copilotMessages: Array<{ id: string; content: string; ts: number }>;
  copilotStatus: "idle" | "streaming" | "error";
  copilotLastEventTs: number | null; // Son event timestamp
  copilotStaleness: { status: "ok" | "warn" | "stale"; seconds: number } | null;

  // Backpressure
  backpressureDrops: number;
  invalidEvents: number; // Invalid event drop sayısı
  activeBufferBytes: number; // Opsiyonel ama çok iyi (activeMessageContent byte boyutu)

  // ... diğer alanlar
}
```

**Kabul:** Store'da minimal telemetry alanları mevcut; UI canlılık sinyalleri için yeterli.

**⚠️ Critical: copilotLastEventTs Telemetry Kuralı**

✅ **Her Valid Event'te Güncellensin:**

- `copilotLastEventTs` yalnız `token`'da değil, `tool_*`, `job_*`, `message_done` dahil her valid event'te güncellensin
- Aksi halde "canlı" akış tool event'lerinde stale görünebilir
- Store'da event handler: Her valid LiveEvent geldiğinde `copilotLastEventTs = event.ts` set et

**Kabul:** `copilotLastEventTs` her valid event'te güncellenir; "canlı" akış tool event'lerinde stale görünmez.

**⚠️ Critical: backpressure_drop Event'i için UI/Store Semantiğini Sabitle**

✅ **backpressure_drop Event Semantiği:**

- Drop sayacı artar: `copilot_backpressure_drop_total` (metrik) + `store.backpressureDrops` (store)
- Timeline'a tek "warn" kaydı düşer (spam olmasın)
- StatusBar amber: "Drops: N" + tooltip "render budget exceeded"

**Kabul:** Backpressure drop'lar sayılır, timeline spam olmaz, StatusBar bilgilendirir.

**⚠️ Montaj Hattı Best Practices**

✅ **Gate A Bitmeden Route/UI'ya Dokunma:**

- Her gate sonunda Proof Pack güncelle → regresyon olursa geri dönüş "kanıtlı" olur
- İdeal: 1 gate = 1 commit (geri sarma kristal netliği)

✅ **Proof Pack Güncelleme:**

- Her gate sonunda `tools/p1.2-proof-pack.ps1` çalıştır
- Proof Pack dosyaları `evidence/p1.2-live/` altına yazılsın
- Regresyon olursa geri dönüş "kanıtlı" olur

**Kabul Kriteri:**

- [ ] copilotSessionManager unit test: refCount (mount/unmount)
- [ ] copilotSessionManager unit test: ikiz bağlantı yok (Dock + StatusBar)
- [ ] Store unit test: messages max 200 (drop oldest)
- [ ] Store unit test: timeline max 300 (drop oldest)
- [ ] Store unit test: activeMessageContent byte limiti (truncated flag)
- [ ] Token assembly unit test: 3 token + done → tek message üretmeli

---

### 4. UI Migration

**Sıra:**

1. CopilotDock.tsx → useCopilotChat() kullanımı
2. StatusBar.tsx → store'dan status/staleness okuma
3. Raw SSE parsing kaldırma

**CopilotDock.tsx Kontrolleri:**

✅ **Sadece useCopilotChat() Çağırır:**

```typescript
import { useCopilotChat } from "@spark/live-react";

const { messages, activeMessage, timeline, status, send, cancel } =
  useCopilotChat();

// send() → prompt gönder
// cancel() → stream iptal
```

**⚠️ Critical Add-on: send() Yarış Durumu**

✅ **Aktif Stream Varsa:**

- `send()` çağrıldığında aktif stream varsa:
  - Ya otomatik `cancel()` + yeni stream
  - Ya "busy" dön (UI disable)
- Aynı anda tek aktif stream var; token'lar çapraz akmıyor

**Kabul:** Aynı anda tek aktif stream var; token'lar çapraz akmıyor.

✅ **Raw SSE Parsing Yok:**

- `fetch('/api/copilot/chat', ...)` → yok
- `getReader()` → yok
- `EventSource` → yok
- `data:` parse → yok

**StatusBar.tsx Kontrolleri:**

✅ **Sadece Store'dan Okur:**

```typescript
import { useLiveStore } from "@spark/live-react";

const { copilotStatus, copilotStaleness, backpressureDrops } = useLiveStore();
```

✅ **Asla Client Başlatmaz:**

- `useCopilotChat()` çağrılmaz (başlatırsa ikiz bağlantı geri gelir)
- Sadece store'dan status/staleness/backpressureDrops okur

**⚠️ Critical Add-on: StatusBar "Client Başlatmaz" Kuralını Otomatikleştir**

✅ **İnsan Hatasını Önlemek:**

- StatusBar sadece `useLiveStore(selector)` ile okur
- `useCopilotChat()` asla StatusBar'da import edilmez
- Smoke test'e ekstra grep kuralı: `apps/web-next/src/components/StatusBar.tsx` içinde `useCopilotChat` geçmeyecek

**Kabul:** Dock kapalıyken StatusBar bağlantı açmıyor.

**⚠️ UI Canlılık Sinyalleri (P1.2)**

✅ **StatusBar (Global, Store'dan Okur; Client Başlatmaz):**

- **Copilot:** `idle | streaming | error` (pulsing dot: streaming → yeşil, error → kırmızı, idle → gri)
- **Staleness:** `ok | warn | stale` (streaming sırasında) + seconds
- **Drops:** N (amber) + tooltip: "render budget exceeded"
- **Invalid:** N (kırmızıya yakın) + tooltip: "invalid live event dropped"
- **Last event age:** X.s (idle iken bile "son olay ne zaman" kanıtı)

✅ **CopilotDock (Lokal, Hook Kullanır):**

- "Gönder" yanında pulsing dot: streaming iken yeşil, error iken kırmızı
- Token assembly çalışırken "typing…" hissi: `activeMessageContent` canlı büyür
- Cancel sonrası anında idle (reconnect yok)

**Kabul:** UI'da "canlılık kanıtı" görünür; kullanıcı sistemin yaşadığını/bozulduğunu anlar.

**Kabul Kriteri:**

- [ ] CopilotDock.tsx → sadece `useCopilotChat()` kullanıyor
- [ ] CopilotDock.tsx → raw SSE parsing yok (grep kontrolü)
- [ ] CopilotDock.tsx → pulsing dot (streaming → yeşil, error → kırmızı)
- [ ] CopilotDock.tsx → token assembly "typing…" hissi
- [ ] StatusBar.tsx → sadece store'dan okur
- [ ] StatusBar.tsx → client başlatmaz (ikiz bağlantı yok)
- [ ] StatusBar.tsx → canlılık sinyalleri (pulsing dot, staleness, drops, invalid, last event age)

---

## StatusBar Örnek TSX (Store-Only, "Canlılık Paneli")

**Dosya:** `apps/web-next/src/components/StatusBar.tsx`

```typescript
// apps/web-next/src/components/StatusBar.tsx
"use client";

import { useEffect, useState, useMemo } from "react";
import { useLiveStore } from "@spark/live-react";

function fmtAge(ms: number) {
  return `${Math.max(0, ms / 1000).toFixed(1)}s`;
}

export function StatusBar() {
  // ⚠️ Critical: "now tick" (client başlatmadan) - Last: X.s kendiliğinden akar
  const [now, setNow] = useState(() => Date.now());

  useEffect(() => {
    const t = setInterval(() => setNow(Date.now()), 1000);
    return () => clearInterval(t);
  }, []);

  const {
    copilotStatus,
    copilotLastEventTs,
    copilotStaleness,
    backpressureDrops,
    invalidEvents,
  } = useLiveStore((s) => ({
    copilotStatus: s.copilotStatus,
    copilotLastEventTs: s.copilotLastEventTs,
    copilotStaleness: s.copilotStaleness,
    backpressureDrops: s.backpressureDrops,
    invalidEvents: s.invalidEvents,
  }));

  const ageMs = useMemo(() => {
    if (!copilotLastEventTs) return null;
    return now - copilotLastEventTs; // ⚠️ Critical: now state'i kullan (Date.now() render tetiklemez)
  }, [now, copilotLastEventTs]);

  const copilotDotClass =
    copilotStatus === "streaming"
      ? "bg-emerald-400 animate-pulse"
      : copilotStatus === "error"
      ? "bg-rose-400"
      : "bg-zinc-500";

  const staleBadge =
    copilotStatus === "streaming" && copilotStaleness
      ? copilotStaleness.status === "ok"
        ? "text-emerald-300"
        : copilotStaleness.status === "warn"
        ? "text-amber-300"
        : "text-rose-300"
      : "text-zinc-400";

  return (
    <div className="flex items-center gap-3 text-[12px] text-zinc-300">
      {/* Copilot Live */}
      <div className="flex items-center gap-2">
        <span className={`h-2 w-2 rounded-full ${copilotDotClass}`} />
        <span className="font-medium">Copilot</span>
        <span className="text-zinc-400">{copilotStatus}</span>
      </div>

      {/* Staleness */}
      <div className={`flex items-center gap-2 ${staleBadge}`}>
        <span>Stale</span>
        <span>
          {copilotStatus === "streaming" && copilotStaleness
            ? `${copilotStaleness.status} (${copilotStaleness.seconds.toFixed(1)}s)`
            : "-"}
        </span>
      </div>

      {/* Drops + Invalid */}
      <div className="flex items-center gap-2">
        <span className={backpressureDrops > 0 ? "text-amber-300" : "text-zinc-400"} title="render budget exceeded">
          Drops: {backpressureDrops}
        </span>
        <span className={invalidEvents > 0 ? "text-rose-300" : "text-zinc-400"} title="invalid live event dropped">
          Invalid: {invalidEvents}
        </span>
      </div>

      {/* Last Event Age */}
      <div className="text-zinc-400" title="last live event age">
        Last: {ageMs == null ? "-" : fmtAge(ageMs)}
      </div>
    </div>
  );
}
```

**Kabul Kriteri:**

- [ ] StatusBar sadece `useLiveStore(selector)` ile okur
- [ ] `useCopilotChat()` asla import edilmez
- [ ] StatusBar dosyası `"use client"` (hook/timer kullanıyorsa şart) ⚠️ Critical
- [ ] StatusBar Last: X.s her 1 saniyede güncelleniyor (stream bitse bile akıyor) ⚠️ Critical
- [ ] Pulsing dot çalışıyor (streaming → yeşil, error → kırmızı, idle → gri)
- [ ] Staleness, Drops, Invalid, Last event age görünür
- [ ] Tooltip'ler mevcut

---

### 5. Smoke Test (Yasak/Guard Testi) + 2 Küçük Unit Test

**Grep "UI Parsing Yok":**

✅ **Pattern:**

- `getReader\(` → yok
- `EventSource` → yok
- `new WebSocket` → yok
- `data:\s` → yok

✅ **Exclude:**

- `packages/live-*` dizinleri hariç tut
- `**/*.md` (dokümanlar)
- `**/*.test.*` (test dosyaları)
- `**/__tests__/` (test dizinleri)

✅ **Search Paths:**

- `apps/web-next/src/components/**/*.tsx`
- `apps/web-next/src/app/**/*.tsx`

**⚠️ Critical Add-on: Smoke Grep'te False Positive Azalt**

✅ **Exclude Set'i:**

- `**/*.md` (dokümanlar)
- `**/*.test.*` (test dosyaları)
- `**/__tests__/` (test dizinleri)
- `packages/live-*` zaten hariç

**Kabul:** Guard test gerçek "UI parsing" ihlallerini yakalıyor, dokümana takılmıyor.

**2 Küçük Unit Test:**

✅ **SSEParser Chunk-Boundary Unit Test:**

```typescript
// Test: data satırı ortadan bölünmüş iki chunk
const parser = new SSEParser();
parser.feed('data: {"v":1,"event":"token"');
parser.feed(',"channel":"copilot:chat"}\n\n');
const events = parser.parse();
// → tek event dönmeli
```

✅ **Token Assembly Unit Test:**

```typescript
// Test: 3 token + done → tek message üretmeli
// 1. token event → activeMessageContent += "Hello"
// 2. token event → activeMessageContent += " "
// 3. token event → activeMessageContent += "World"
// 4. message_done event → finalize → messages[] içine ekle
// → messages.length === 1, messages[0].content === "Hello World"
```

**Kabul Kriteri:**

- [ ] Grep "UI parsing yok" → PASS (packages/live-\* hariç, docs/test dosyaları hariç)
- [ ] SSEParser chunk-boundary unit test → PASS
- [ ] Token assembly unit test → PASS
- [ ] StatusBar.tsx içinde `useCopilotChat` geçmeyecek (grep kontrolü) ⚠️ Critical

**⚠️ Critical Add-on: 2 Metrik Ekle**

✅ **P1.2'de Observability'ye Zaten Giriyorsun; Live Layer için Minimum İkisi Yeter:**

```typescript
// packages/live-core/src/metrics/copilotMetrics.ts
copilot_live_event_invalid_total; // Invalid event drop sayısı
copilot_backpressure_drop_total; // Backpressure drop sayısı
```

**Kabul:** "Canlı" iddianı sayıya bağlarsın; regressions yakalanır.

---

## Kabul Kriteri (P1.2 Done için Net, Ölçülebilir)

### 1. UI'da Hiçbir Yerde Raw Parsing Kalmayacak

✅ **Grep Kontrolü:**

- `getReader\(` → UI'da yok (packages/live-\* hariç)
- `EventSource` → UI'da yok
- `new WebSocket` → UI'da yok
- `data:\s` → UI'da yok

**Ölçüm:**

```powershell
# tools/copilot-smoke-test.ps1
# Test 15: UI parsing yok (yasak)
# → PASS/FAIL
```

---

### 2. Aynı Anda CopilotDock + StatusBar Açıkken Tek Stream Çalacak

✅ **RefCount Testi:**

- CopilotDock mount → refCount: 1, stream açık
- StatusBar mount → refCount: 2, aynı stream (ikiz bağlantı yok)
- StatusBar unmount → refCount: 1, stream açık kalır
- CopilotDock unmount → refCount: 0, stream kapanır

**Ölçüm:**

- Browser DevTools → Network tab → `/api/copilot/chat` → tek request görünmeli
- Console log → `copilotSessionManager.getRefCount()` → doğru değerler

---

### 3. 60 Saniyelik Yoğun Stream'de Bellek Sınırları Çalışacak

✅ **Mesaj Sayısı "Token Sayısı Kadar" Şişmeyecek:**

- 1000 token event → 1 mesaj (assembly doğrulanır)
- `messages.length` → max 200 (drop oldest)

✅ **Bellek Sınırları:**

- `messages.length` → max 200
- `timeline.length` → max 300
- `activeMessageContent` → max 32KB-64KB (truncated flag)

**Ölçüm:**

- 60 saniyelik yoğun stream testi
- `messages.length` → max 200
- `timeline.length` → max 300
- Memory profiler → bellek sızıntısı yok

---

### 4. Cancel: cancel() Çağrılınca Stream Kapanacak

✅ **Cancel Garantisi:**

- `cancel()` çağrılınca → stream kapanacak
- Status → `idle`'a dönecek
- Reconnect tetiklenmeyecek

**Ölçüm:**

- CopilotDock → "Cancel" butonu → stream kapanır
- Status → `idle`
- Network tab → request abort edilir

---

### 5. Normal Completion: Model Cevap Bitince Status Idle

✅ **Normal Completion:**

- Model cevap bitince → `message_done` event
- Status → `idle` (connected gibi kalmayacak)
- Reconnect tetiklenmeyecek

**Ölçüm:**

- Stream tamamlanınca → status `idle`
- Network tab → request normal biter (200 OK)
- Reconnect timer → çalışmaz

### 6. "Gerçek Dünya Doğrulaması"nı UI'dan Görünür Yapan 3 Net Kanıt

✅ **Dock + StatusBar Açıkken:**

- StatusBar'da Copilot `streaming` + pulsing dot (yeşil)
- Staleness, Drops, Invalid sayaçları görünür
- Network tab'da tek `/api/copilot/chat` request

✅ **60s Yoğun Akış:**

- StatusBar'da Drops/Invalid artışı görünür
- Messages/timeline limitleri çalışıyor (UI freeze yok)
- Active buffer byte limiti çalışıyor

✅ **Stream Bitince:**

- Copilot `idle` + Last: X.s akmaya devam (deterministik kanıt)
- Pulsing dot griye döner
- Reconnect yok

**Kabul:** UI'da "canlılık kanıtı" görünür; kullanıcı sistemin yaşadığını/bozulduğunu anlar.

---

## "Her Şey Canlı" Hedefi için (Copilot'tan Market'e Geçiş Köprüsü)

### Sistem Hibrit Olacak

✅ **Request-Scoped:**

- Copilot: request-scoped stream ✅ (şimdi)

✅ **Subscribe-Scoped:**

- Market: gerçek "subscribe/unsubscribe" WS ✅ (P1.3)
- Orderbook: gerçek "subscribe/unsubscribe" WS ✅ (P1.3)
- Candles: gerçek "subscribe/unsubscribe" WS ✅ (P1.3)

✅ **Polling-Scoped:**

- Job progress: polling→event'e zaten benziyor ✅

**UI Bunu Hiç Bilmeyecek:**

- Store/hook aynı kalacak
- `usePrice(symbol)` → subscribe-scoped
- `useCopilotChat()` → request-scoped
- UI sadece hook kullanır, transport bilmez

---

## Son Küçük "Şeytan Ayrıntısı" Uyarısı

### Subpath Exports Kullanımı

✅ **Server Tarafında Sadece:**

```typescript
// ✅ DOĞRU
import { validateLiveEvent } from "@spark/live-core/envelope";

// ❌ YANLIŞ (browser kodu server bundle'a sızar)
import { LiveClient } from "@spark/live-core";
```

✅ **Browser Tarafında:**

```typescript
// ✅ DOĞRU
import { SSEParser } from "@spark/live-core/sse";
import { getStalenessPolicy } from "@spark/live-core/staleness";
import { useCopilotChat } from "@spark/live-react";
```

**Kontrol:**

- Next build → server bundle'da `LiveClient` yok
- Next build → browser bundle'da `validateLiveEvent` yok (sadece envelope gerekirse)

---

## İlerleme Çizgisi

### P1.2 Minimum Patch (Şimdi)

✅ **Copilot: Request-Scoped Stream**

- UI refactor-safe
- "Canlı sinir sistemi" omurgası kuruldu

### P1.3 Market WS (Sonraki Adım)

✅ **Market: Subscribe-Scoped WS**

- Aynı envelope + store kalıbı
- StatusBar → gerçek "canlılık kanıtı paneli"

**Sonuç:**

- UI'yi istediğin kadar biçimlendir; "canlı sinir sistemi" yerinden oynamaz
- P1.3'te market WS'yi aynı envelope + store kalıbına sokmak (fiyat/candle/orderbook)
- StatusBar'ı gerçek "canlılık kanıtı paneli"ne çevirmek

---

## Checklist Özeti

### Adım 1: live-core

- [ ] SSEParser: chunk boundary, multi-line, çöp satır toleransı
- [ ] startCopilotStream: abort() garantisi, normal completion vs network error
- [ ] Unit testler: SSEParser (3 test), startCopilotStream (2 test)

### Adım 2: route.ts

- [ ] Envelope formatı (v, event, channel, seq, ts, ok, data)
- [ ] Seq semantiği (stream scope içinde monoton artan)
- [ ] Seq reset kuralı: Her request `seq = 0`'dan başlar, `message_done` ile stream biter ⚠️ Critical
- [ ] Event tipleri standardize (token, message*done, tool*\_, job\_\_, error)
- [ ] Gateway çıkışında Zod validation

### Adım 3: live-react

- [ ] copilotSessionManager: singleton + refCount
- [ ] Store: bellek sınırları (messages: 200, timeline: 300, activeMessageContent: 32KB-64KB)
- [ ] Store: minimal telemetry alanları (copilotStatus, copilotLastEventTs, copilotStaleness, backpressureDrops, invalidEvents, activeBufferBytes)
- [ ] Token assembly: token → activeMessageContent, message_done → finalize
- [ ] backpressure_drop semantiği: drop sayacı, timeline warn kaydı, StatusBar amber ⚠️ Critical
- [ ] Unit testler: refCount, ikiz bağlantı, bellek sınırları, token assembly

### Adım 4: UI Migration

- [ ] CopilotDock.tsx → useCopilotChat() kullanımı
- [ ] CopilotDock.tsx → pulsing dot (streaming → yeşil, error → kırmızı)
- [ ] CopilotDock.tsx → token assembly "typing…" hissi
- [ ] StatusBar.tsx → store'dan okuma (client başlatmaz)
- [ ] StatusBar.tsx → `"use client"` (hook/timer kullanıyorsa şart) ⚠️ Critical
- [ ] StatusBar.tsx → "now tick" (1 saniyede bir `now` state güncelleme) ⚠️ Critical
- [ ] StatusBar.tsx → canlılık sinyalleri (pulsing dot, staleness, drops, invalid, last event age)
- [ ] Store: `copilotLastEventTs` her valid event'te güncellenir (token, tool*\*, job*\*, message_done) ⚠️ Critical
- [ ] Raw SSE parsing kaldırma

### Adım 5: Smoke Test

- [ ] Grep "UI parsing yok" → PASS
- [ ] SSEParser chunk-boundary unit test → PASS
- [ ] Token assembly unit test → PASS

### P1.2 Done Kriterleri

- [ ] UI'da hiçbir yerde raw parsing kalmayacak
- [ ] Aynı anda CopilotDock + StatusBar açıkken tek stream çalacak
- [ ] 60 saniyelik yoğun stream'de bellek sınırları çalacak
- [ ] Cancel: cancel() çağrılınca stream kapanacak
- [ ] Normal completion: model cevap bitince status idle

### Gerçek Dünya Doğrulaması (En Kritik)

- [ ] Dock + StatusBar açık → Network tab'da tek `/api/copilot/chat` request
- [ ] 60s yoğun stream → messages max 200, timeline max 300, active buffer byte limit çalışıyor
- [ ] Stream bitince status idle
- [ ] UI'da canlılık kanıtı görünür: StatusBar'da pulsing dot + stale/drops/invalid + last event age

---

## ⚠️ Critical Add-ons Özeti

Bu 10 kritik ayrıntı yoksa P1.2 "çalışıyor gibi" olup prod'da naz yapabiliyor:

1. ✅ SSEParser: CRLF delimiter testi (`\r\n\r\n`), JSON split + multi-line birlikte testi
2. ✅ route.ts: `runtime = "nodejs"`, `dynamic = "force-dynamic"`, response headers (Content-Type, Cache-Control, Connection)
3. ✅ Store: `timestamp: Date` → `ts: number` (JSON-serializable)
4. ✅ activeMessageContent: Byte limiti (`TextEncoder().encode(str).length`, char ≠ byte)
5. ✅ send() yarış durumu: Aktif stream varsa otomatik cancel() + yeni stream veya "busy" dön
6. ✅ StatusBar: `useCopilotChat()` asla import edilmez (grep kontrolü)
7. ✅ Smoke grep: Exclude set'i (`**/*.md`, `**/*.test.*`, `**/__tests__/`)
8. ✅ 2 metrik: `copilot_live_event_invalid_total`, `copilot_backpressure_drop_total`
9. ✅ Gateway'de seq reset kuralı: Her request `seq = 0`'dan başlar, `message_done` ile stream biter
10. ✅ backpressure_drop semantiği: Drop sayacı, timeline warn kaydı, StatusBar amber

**Not:** P1.3'te market WS'ye geçerken de aynı guardrails'i aynen taşırsın (özellikle send() yarış ve byte limit konusu WS'de daha da önemli oluyor).

**Gerçek Dünya Doğrulaması:**
Bu üçlü PASS ise, P1.3 Market WS entegrasyonu neredeyse "aynı kalıbı kopyala-yapıştır" kadar mekanikleşir:

1. Dock + StatusBar açık → Network tab'da tek `/api/copilot/chat` request
2. 60s yoğun stream → messages max 200, timeline max 300, active buffer byte limit çalışıyor
3. Stream bitince status idle

---

## Sonuç

Bu checklist ile P1.2 minimum patch'i uygularsan:

- ✅ UI refactor-safe omurga kurulur
- ✅ "Canlı sinir sistemi" yerinden oynamaz
- ✅ P1.3'e geçiş köprüsü hazır
- ✅ Prod'da naz yapmayacak saha dayanıklılığı

**Sonraki Mantıklı Adım:**
P1.3'te market WS'yi aynı envelope + store kalıbına sokmak (fiyat/candle/orderbook) ve StatusBar'ı gerçek "canlılık kanıtı paneli"ne çevirmek.

---

## Nice-to-Have Guardrails (P1.2 Done'ı Değiştirmez, Prod Hissiyatını Cilar)

Bu 3 guardrail P1.2 Done kriterlerini değiştirmez, ama prod'da "son pürüzler"i temizler.

### 1. Clock Drift / Negatif Age

✅ **Mevcut Kilit:**

- `Math.max(0, ms / 1000)` ile negatif age engellenmiş ✅

✅ **Ek Küçük Kural (Opsiyonel):**

- `copilotLastEventTs` client clock ile değil, `event.ts` ile geliyor
- `event.ts` server clock ise, client ileri/geri ise age saçmalayabilir
- **Çözüm:** `lastSeenAtClient = Date.now()` da tut; StatusBar "Last (client)"ı bundan hesaplasın, `event.ts`'yi debug için saklasın

**Store'a Eklenebilir:**

```typescript
interface LiveStoreState {
  // ...
  copilotLastEventTs: number | null; // Server clock (event.ts)
  copilotLastSeenAtClient: number | null; // Client clock (Date.now()) - opsiyonel
  // ...
}
```

**StatusBar'da:**

```typescript
const ageMs = useMemo(() => {
  // Opsiyonel: Client clock kullan (clock drift koruması)
  if (copilotLastSeenAtClient) {
    return now - copilotLastSeenAtClient;
  }
  // Fallback: Server clock
  if (!copilotLastEventTs) return null;
  return now - copilotLastEventTs;
}, [now, copilotLastSeenAtClient, copilotLastEventTs]);
```

**Kabul:** Clock drift koruması mevcut; age saçmalamaz.

---

### 2. StatusBar'ın Store Selector'ı Render Budget

✅ **Mevcut Durum:**

- `useLiveStore((s) => ({...}))` doğru ✅

✅ **Ek Optimizasyon (Opsiyonel):**

- Store çok sık güncelleniyorsa StatusBar da çok render olur
- **Çözüm:** StatusBar'da sadece telemetry alanlarını seçmek + `shallow` (zustand) kullanmak

**StatusBar'da:**

```typescript
import { shallow } from "zustand/shallow";

const {
  copilotStatus,
  copilotLastEventTs,
  copilotStaleness,
  backpressureDrops,
  invalidEvents,
} = useLiveStore(
  (s) => ({
    copilotStatus: s.copilotStatus,
    copilotLastEventTs: s.copilotLastEventTs,
    copilotStaleness: s.copilotStaleness,
    backpressureDrops: s.backpressureDrops,
    invalidEvents: s.invalidEvents,
  }),
  shallow // ⚠️ Critical: Sadece seçilen alanlar değiştiyse render
);
```

**Kabul:** StatusBar render budget korunur; gereksiz render'lar azalır.

---

### 3. "Idle İken Staleness" Semantiği

✅ **Kural:**

- `copilotStatus === 'streaming'` değilse `copilotStaleness = null` (veya StatusBar'da staleness satırı gizlenir)
- Yoksa idle'da "stale" görünüp yanlış alarm verir

**Store'da:**

```typescript
// Event handler'da:
if (event.event === "message_done" || event.event === "error") {
  // Stream bitti → staleness'i temizle
  setCopilotStaleness(null);
}
```

**StatusBar'da:**

```typescript
{/* Staleness - sadece streaming sırasında göster */}
{copilotStatus === 'streaming' && copilotStaleness && (
  <div className={`flex items-center gap-2 ${staleBadge}`}>
    <span>Stale</span>
    <span>
      {`${copilotStaleness.status} (${copilotStaleness.seconds.toFixed(1)}s)`}
    </span>
  </div>
)}
```

**Kabul:** Idle'da staleness görünmez; yanlış alarm verilmez.

---

## Sonuç (Güncellenmiş)

**Şu an geldiğiniz nokta: P1.2'yi uygulamak artık mühendislik değil, neredeyse montaj işi (iyi anlamda).**

Bu checklist ile:

- ✅ UI refactor-safe omurga kurulur
- ✅ "Canlı sinir sistemi" yerinden oynamaz
- ✅ P1.3'e geçiş köprüsü hazır
- ✅ Prod'da naz yapmayacak saha dayanıklılığı
- ✅ Kanıtlı çalışıyor (proof pack)
- ✅ Script'lenebilir doğrulamalar (%70 otomasyon)
- ✅ Nice-to-have guardrails (clock drift, render budget, idle staleness) - opsiyonel ama prod hissiyatını cilar

**Not:** Nice-to-have guardrails P1.2 Done için zorunlu değil, ama prod'da "son pürüzler"i temizler.

**Sonraki Mantıklı Adım:**
P1.3'te market WS'yi aynı envelope + store kalıbına sokmak (fiyat/candle/orderbook) ve StatusBar'ı gerçek "canlılık kanıtı paneli"ne çevirmek.

---

## Go/No-Go Kapıları (P1.2'yi Kırmadan İlerletmek İçin)

**Her adımda çıkış kriteri:** Bir gate'i geçmeden sonrakine geçme.

### Gate A — live-core Tamam (Step 1)

**Hedef:** @spark/live-core (React yok) içinde:

- envelope + Zod doğrulama
- sse/SSEParser (CRLF + multi-line + split JSON dahil)
- copilot/startCopilotStream (abort, normal completion vs network error)
- subpath exports (server only envelope import edebilsin)
- testler (SSEParser 7/7, startCopilotStream 2+/2 PASS)

**Çalışma Sırası:**

1. packages/live-core oluştur/uyarla
2. Subpath exports: envelope, sse, staleness, copilot
3. SSEParser (buffer-based) + 7 test
4. startCopilotStream (request-scoped) + abort/normal completion/network error ayrımı testleri
5. Node/browser timer types: ReturnType<typeof setTimeout>
6. Build/test PASS ve Proof Pack GateA PASS

**Sonra:**

- `set GATE_NAME=GateA` → `tools\p1.2-proof-pack.cmd`
- `evidence/p1.2-live/proof_summary.txt` PASS ise tek commit

**Go Koşulları:**

✅ **SSEParser Testleri: 7/7 PASS**

- Chunk boundary (data satırı ortadan bölünmüş iki chunk)
- Multi-line data
- Çöp satır toleransı
- CRLF delimiter (`\r\n\r\n`)
- JSON split + multi-line birlikte
- (Diğer 2 test)

✅ **startCopilotStream Testleri: PASS**

- abort() garantisi
- Normal completion vs network error ayrımı

✅ **@spark/live-core Subpath Exports Çalışıyor:**

- Server import: `@spark/live-core/envelope` ✅
- Browser import: `@spark/live-core/sse`, `@spark/live-core/staleness` ✅
- `pnpm -w typecheck` PASS ✅

**No-Go:** SSEParser testleri flaky ise route/UI'ya geçme.

**Kabul Kriteri:**

- [ ] SSEParser testleri: 7/7 PASS
- [ ] startCopilotStream testleri: abort + normal completion + network error ayrımı PASS
- [ ] Subpath exports çalışıyor (server/browser ayrımı)
- [ ] `pnpm -w typecheck` PASS
- [ ] Proof Pack GateA PASS (exit 0)

---

### Gate B — route.ts Envelope/Seq Sabit (Step 2)

**Go Koşulları:**

✅ **route.ts Streaming Stabilitesi:**

- `runtime = "nodejs"` ✅
- `dynamic = "force-dynamic"` ✅
- Header setleri tamam (Content-Type, Cache-Control, Connection) ✅

✅ **Seq Semantiği:**

- Her request'te `seq = 0` reset ✅
- Stream içinde monoton artış ✅
- `message_done` ile stream kapanıyor ✅

✅ **Gateway Çıkışında Zod Validation:**

- `validateLiveEvent()` aktif ✅
- Invalid drop + metric artıyor ✅

✅ **Manuel Test:**

- 1 istek → event'lerde seq düzgün + `message_done` ile kapanıyor ✅

**No-Go:** "message_done geldi ama status idle olmuyor" görülürse live-react'a geçme.

**Kabul Kriteri:**

- [ ] route.ts: runtime=nodejs, dynamic=force-dynamic, header setleri tamam
- [ ] Her request'te seq=0 reset, stream içinde monoton artış
- [ ] validateLiveEvent() gateway çıkışında aktif; invalid drop + metric artıyor
- [ ] Manuel: 1 istek → event'lerde seq düzgün + message_done ile kapanıyor

---

### Gate C — live-react Session/Assembly/Limits (Step 3)

**Go Koşulları:**

✅ **Singleton + RefCount Test PASS:**

- Dock + StatusBar = tek stream ✅

✅ **Token Assembly Test PASS:**

- 1000 token → 1 mesaj ✅
- `message_done` finalize ✅

✅ **Limitler PASS:**

- `messages <= 200` ✅
- `timeline <= 300` ✅
- `activeMessageBytes` byte bazlı (`TextEncoder`) ✅

✅ **Telemetry Kuralı PASS:**

- Her valid event → `copilotLastEventTs = event.ts` ✅
- Nice-to-have: `copilotLastSeenAtClient = Date.now()` da güncelleniyor ✅

✅ **Status Semantiği:**

- `idle | streaming | error` deterministik ✅

**No-Go:** "token başına mesaj patlıyor" veya "ikiz bağlantı" varsa UI migration'a geçme.

**Kabul Kriteri:**

- [ ] Singleton + refCount test PASS (Dock + StatusBar = tek stream)
- [ ] Token assembly test PASS (1000 token → 1 mesaj; message_done finalize)
- [ ] Limitler PASS: messages<=200, timeline<=300, activeMessageBytes byte bazlı
- [ ] Telemetry kuralı PASS: her valid event → copilotLastEventTs = event.ts
- [ ] Status semantiği: idle | streaming | error deterministik

---

### Gate D — UI + Smoke + Proof Pack (Step 4-5)

**Go Koşulları:**

✅ **UI Grep Guard PASS:**

- `packages/live-*` hariç: `getReader(`, `EventSource`, `new WebSocket`, `data:\s` → yok ✅

✅ **StatusBar:**

- `"use client"` + now tick çalışıyor → Last: X.s her saniye akıyor ✅
- Idle iken staleness görünmüyor (null / hidden) ✅

✅ **Proof Pack Dosyaları Dolu:**

- `grep_ui_parsing.txt` ✅
- `jest_live_core.txt` ✅
- `jest_live_react.txt` ✅
- `network_single_request.png` ✅
- `statusbar_live_proof.png` ✅
- `60s_stress_metrics.txt` ✅

**Kabul Kriteri:**

- [ ] UI grep guard PASS (packages/live-\* hariç)
- [ ] StatusBar: "use client" + now tick çalışıyor → Last: X.s her saniye akıyor
- [ ] StatusBar: idle iken staleness görünmüyor (null / hidden)
- [ ] Proof Pack dosyaları dolu (en az grep + jest + metrics snapshot)

---

## Nice-to-Have Guardrails Kural Seti (Koda Dökerken)

**Bunları store'da çok küçük ek alanlarla kapat:**

✅ **Clock Drift Koruması:**

```typescript
interface LiveStoreState {
  // ...
  copilotLastEventTs: number | null; // Server ts (event.ts)
  copilotLastSeenAtClient: number | null; // Client now (Date.now()) - opsiyonel
  // ...
}

// Event handler'da:
if (validEvent) {
  setCopilotLastEventTs(event.ts); // Server clock
  setCopilotLastSeenAtClient(Date.now()); // Client clock (opsiyonel)
}
```

**StatusBar'da:**

```typescript
const ageMs = useMemo(() => {
  // Opsiyonel: Client clock kullan (clock drift koruması)
  if (copilotLastSeenAtClient) {
    return now - copilotLastSeenAtClient;
  }
  // Fallback: Server clock
  if (!copilotLastEventTs) return null;
  return now - copilotLastEventTs;
}, [now, copilotLastSeenAtClient, copilotLastEventTs]);
```

✅ **Render Budget Koruması:**

```typescript
import { shallow } from "zustand/shallow";

const {
  copilotStatus,
  copilotLastEventTs,
  copilotStaleness,
  backpressureDrops,
  invalidEvents,
} = useLiveStore(
  (s) => ({
    copilotStatus: s.copilotStatus,
    copilotLastEventTs: s.copilotLastEventTs,
    copilotStaleness: s.copilotStaleness,
    backpressureDrops: s.backpressureDrops,
    invalidEvents: s.invalidEvents,
  }),
  shallow // ⚠️ Critical: Sadece seçilen alanlar değiştiyse render
);
```

✅ **Idle Staleness Koruması:**

```typescript
// Store'da:
if (event.event === "message_done" || event.event === "error") {
  setCopilotStaleness(null); // Stream bitti → staleness'i temizle
}

// StatusBar'da:
{copilotStatus === 'streaming' && copilotStaleness && (
  // Staleness satırı sadece streaming sırasında göster
)}
```

**Kabul:** Clock drift ve render budget iki taraftan kilitlenmiş olur.

---

## Cursor'a Tek Blok Görev (Direkt Uygulanabilir)

**P1.2 Live Layer Uygulaması**

**Hedef:** Checklist'teki Gate A→B→C→D sırasını bozmadan minimum patch'i implemente etmek ve `evidence/p1.2-live` Proof Pack üretmek.

**SCOPE (Öncelik Sırası):**

1. **packages/live-core:**
   - SSEParser (CRLF dahil) + 7 test
   - startCopilotStream (abort + normal completion + network error) + testler
   - Subpath exports: `envelope`/`staleness`/`sse`

2. **apps/web-next api route:**
   - `/api/copilot/chat/route.ts`: `runtime=nodejs`, `dynamic=force-dynamic`, doğru SSE headers
   - LiveEvent envelope + `validateLiveEvent()` ile gateway çıkış doğrulaması
   - Seq reset: her request `seq=0`, stream içinde monoton, `message_done` ile kapanış
   - Metrikler: `copilot_live_event_invalid_total`, `copilot_backpressure_drop_total` (minimum wiring)

3. **packages/live-react:**
   - Store: `ts:number` (Date yok), telemetry alanları + byte limit (`TextEncoder`)
   - copilotSessionManager singleton + refCount
   - Token assembly: token→active buffer, `message_done`→finalize
   - Nice-to-have: `copilotLastSeenAtClient` ekle ve her valid event'te `Date.now()` set et
   - StatusBar shallow selector önerisine uygun örnek kullanım

4. **UI migration:**
   - CopilotDock raw parsing kaldır → `useCopilotChat()`
   - StatusBar sadece store'dan okur; `useCopilotChat` import edilmez
   - StatusBar now-tick (1s) ile Last: X.s akacak; idle iken staleness satırı gizli/null

5. **tools:**
   - `copilot-smoke-test.ps1` grep kuralları + StatusBar "useCopilotChat yok" guard
   - Proof Pack çıktıları `evidence/p1.2-live/` altına yazılsın (`grep_ui_parsing.txt`, `jest_live_core.txt`, `jest_live_react.txt`, `60s_stress_metrics.txt`)

**KOMUTLAR (Çalıştır ve Çıktıları Evidence'e Yaz):**

- `pnpm -w typecheck`
- `pnpm --filter @spark/live-core test`
- `pnpm --filter @spark/live-react test`
- (varsa) `pnpm --filter web-next test / build`
- `tools/copilot-smoke-test.ps1`

**ÇIKIŞ:**

- Sadece **FINAL SUMMARY** formatında raporla:
  - Başlık
  - Durum
  - Çalıştırılan komutlar
  - Eklenen/Değişen dosyalar
  - Test sonuçları
  - Hatalar/Uyarılar
  - Proof Pack dosya listesi
  - Sonraki adımlar

**Not:** Bu noktadan sonra iş "montaj"a dönüyor: Gate A'yı geçince diğerleri mekanikleşir. P1.2 bitince P1.3 Market WS entegrasyonu gerçekten "aynı kalıbı çoğalt" seviyesine iner (çünkü en pahalı şey olan kanıt + guardrails altyapısı kurulmuş olur).

---

## Proof Pack (Kanıt Paketi) Standardı

**P1.2 bittiğinde tek seferde kanıt üretmek için şunu hedefleyin:**

✅ **Klasör Yapısı:**

```
evidence/p1.2-live/
├── grep_ui_parsing.txt          # Smoke test grep çıktısı (UI parsing yok + StatusBar kuralları)
├── env.txt                      # Ortam kanıtı (node -v, pnpm -v)
├── git.txt                      # Commit kanıtı (git rev-parse HEAD, git status)
├── typecheck.txt                # Typecheck çıktısı
├── jest_live_core.txt           # SSEParser + startCopilotStream test log
├── jest_live_react.txt          # refCount + assembly + limits test log
├── 60s_stress_metrics.txt       # drops + invalid event metrik snapshot (best-effort)
├── proof_summary.txt            # PASS/FAIL + gate adı + commit hash + timestamp
├── network_single_request.png  # Dock+StatusBar açıkken tek request ekran görüntüsü (manuel)
└── statusbar_live_proof.png     # Streaming sırasında pulsing dot + stale/drops/invalid görünürken (manuel)
```

**Kabul Kriteri:**

- [ ] `evidence/p1.2-live/` klasörü oluşturuldu
- [ ] Tüm proof pack dosyaları mevcut:
  - `grep_ui_parsing.txt` → PASS (UI parsing yok + StatusBar kuralları)
  - `env.txt` → node -v, pnpm -v
  - `git.txt` → commit hash + status
  - `typecheck.txt` → PASS
  - `jest_live_core.txt` → Tüm testler PASS
  - `jest_live_react.txt` → Tüm testler PASS
  - `60s_stress_metrics.txt` → Bellek sınırları çalışıyor (best-effort)
  - `proof_summary.txt` → PASS/FAIL + gate adı + commit hash
- [ ] Network screenshot → Tek request görünüyor (manuel)
- [ ] StatusBar live proof screenshot → Pulsing dot + stale/drops/invalid görünüyor (manuel)
- [ ] Proof Pack runner exit code 0 (FAIL yoksa)

**Avantaj:**

- "Çalışıyor" yerine kanıtlı çalışıyor diyorsun
- Audit/geri dönüşlerde altın
- P1.3'e geçerken aynı harness'i Market WS için aynen kullanırsın

**⚠️ Proof Pack Runner Script (Tek Komut, Kanıt Üretir)**

✅ **Otomasyon:** Checklist'teki "script'lenebilir doğrulamalar" bölümünü pratikte %90 otomasyona çeker.

**Dosya:** `tools/p1.2-proof-pack.ps1`

```powershell
# tools/p1.2-proof-pack.ps1
$ErrorActionPreference = "Continue"

$root = Resolve-Path "."
$ev = Join-Path $root "evidence/p1.2-live"
New-Item -ItemType Directory -Force -Path $ev | Out-Null

function Run-Cmd($cmd, $outFile) {
  Write-Host "==> $cmd"
  $outPath = Join-Path $ev $outFile
  cmd /c "$cmd" 2>&1 | Tee-Object -FilePath $outPath
}

# 1) UI parsing guard (packages/live-* hariç + md/test hariç)
$grepOut = Join-Path $ev "grep_ui_parsing.txt"
"UI RAW PARSING GUARD (exclude: packages/live-*, *.md, *.test.*, __tests__)" | Out-File $grepOut

$patterns = @("getReader\(", "EventSource", "new WebSocket", "data:\s")
$searchRoots = @("apps/web-next/src/components", "apps/web-next/src/app")

foreach ($p in $patterns) {
  "`n--- PATTERN: $p ---" | Out-File $grepOut -Append

  $hits = Get-ChildItem -Path $searchRoots -Recurse -File -Include *.ts,*.tsx `
    | Where-Object { $_.FullName -notmatch "\\packages\\live-" } `
    | Where-Object { $_.FullName -notmatch "\.md$" } `
    | Where-Object { $_.FullName -notmatch "\.test\." } `
    | Where-Object { $_.FullName -notmatch "\\__tests__\\" } `
    | Select-String -Pattern $p -SimpleMatch -ErrorAction SilentlyContinue

  if ($hits) {
    "FAIL: Found matches" | Out-File $grepOut -Append
    $hits | ForEach-Object { "$($_.Path):$($_.LineNumber) $($_.Line.Trim())" } | Out-File $grepOut -Append
  } else {
    "PASS: No matches" | Out-File $grepOut -Append
  }
}

# 2) Typecheck + Jest logs (workspace)
Run-Cmd "pnpm -w typecheck" "typecheck.txt"
Run-Cmd "pnpm --filter @spark/live-core test" "jest_live_core.txt"
Run-Cmd "pnpm --filter @spark/live-react test" "jest_live_react.txt"

# 3) Metrics snapshot (opsiyonel: endpoint ayaktaysa)
# Not: URL'i projene göre gerekirse güncelle (web-next dev: http://localhost:3003/api/public/metrics)
$metricsOut = Join-Path $ev "60s_stress_metrics.txt"
"METRICS SNAPSHOT (best-effort)" | Out-File $metricsOut
try {
  $url = "http://localhost:3003/api/public/metrics"
  (Invoke-WebRequest -UseBasicParsing -Uri $url -TimeoutSec 8).Content | Out-File $metricsOut -Append
} catch {
  "SKIP: metrics endpoint not reachable: $($_.Exception.Message)" | Out-File $metricsOut -Append
}

Write-Host "`nProof Pack ready: $ev"
```

**Dosya:** `tools/p1.2-proof-pack.cmd` (CMD wrapper)

```cmd
:: tools\p1.2-proof-pack.cmd
@echo off
powershell -ExecutionPolicy Bypass -File "%~dp0p1.2-proof-pack.ps1"
```

**Kullanım:**

```bash
# PowerShell
.\tools\p1.2-proof-pack.ps1

# CMD
tools\p1.2-proof-pack.cmd

# Gate adı ile (opsiyonel)
$env:GATE_NAME="Gate A"; .\tools\p1.2-proof-pack.ps1
```

**Özellikler:**

✅ **Regex Pattern Matching:**

- `getReader\(` → gerçek ihlalleri yakalar
- `\bEventSource\b` → word boundary ile hassas eşleşme
- `new\s+WebSocket` → arada boşluk/tab olsa da yakalar
- `data:\s` → gerçekten "SSE satırı" kokusunu yakalar
- `response\.body\.getReader` → ReadableStream parsing kokusu (React'ta SSE parsing bazen gizleniyor)

✅ **Exit Code (CI/Gate için):**

- FAIL olunca script exit code 1 döner
- Grep guard PASS değilse Gate D otomatik "No-Go" olur
- PowerShell bazen pipeline'da exit code'u yutabilir; `$LASTEXITCODE` kontrolü ile garanti altına alındı
- Typecheck/jest fail olsa bile "proof_summary PASS" gibi bir saçmalık olmaz

✅ **Ortam + Commit Kanıtı:**

- `env.txt`: node -v, pnpm -v
- `git.txt`: git rev-parse HEAD, git status --porcelain
- Audit altın madalyası: her proof pack'te ortam + commit sabitleniyor

✅ **StatusBar Kuralları (Otomatik Doğrulama):**

- StatusBar `useCopilotChat` import etmez → FAIL
- StatusBar `"use client"` içerir → FAIL yoksa
- StatusBar bazen `StatusBar.tsx` değil `TopStatusBar.tsx` gibi ayrılıyor; glob ile tüm `*StatusBar*.tsx` dosyaları kontrol edilir
- UI canlılık tarafındaki en büyük "kaza" sınıfını otomatik engeller

✅ **Proof Summary:**

- `proof_summary.txt`: PASS/FAIL + gate adı + commit hash + timestamp
- Makine okunabilir format: `RESULT=PASS GATE=GateD COMMIT=... TIME=... EXIT=0`
- İnsan okunabilir format: Aynı dosyada detaylı özet
- "Gate D PASS" cümlesi tek satır kanıtla sabitleniyor
- P1.3'te aynı parser ile otomatik rapor üretilebilir

**Son Rötuşlar (Prod Hissiyatı + Determinism):**

✅ **Jest Flaky Yakalama:**

- Jest `--runInBand` modda çalıştırılır (Windows + IO'da stabiliteyi artırır)
- Gate A'da parser testleri flake olursa yakalanır

✅ **Metrics Snapshot Timestamp:**

- `60s_stress_metrics.txt` başına ISO timestamp, URL, HTTP status eklenir
- Audit için harika: her snapshot'ta zaman + durum sabitleniyor

**Son Rötuşlar (Prod Hissiyatı + Determinism):**

✅ **Jest Flaky Yakalama:**

- Jest `--runInBand` modda çalıştırılır (Windows + IO'da stabiliteyi artırır)
- Gate A'da parser testleri flake olursa yakalanır

✅ **Metrics Snapshot Timestamp:**

- `60s_stress_metrics.txt` başına ISO timestamp, URL, HTTP status eklenir
- Audit için harika: her snapshot'ta zaman + durum sabitleniyor

**Kabul:** Proof Pack tek komutla üretiliyor; script'lenebilir doğrulamalar %90 otomasyona çekildi. FAIL olunca CI/gate otomatik "No-Go" olur. Prod hissiyatı ve determinism iyice cilalandı. Prod hissiyatı ve determinism iyice cilalandı.

**⚠️ Montaj Hattı Best Practices:**

✅ **Gate A Bitmeden Route/UI'ya Dokunma:**

- Her gate sonunda Proof Pack güncelle → regresyon olursa geri dönüş "kanıtlı" olur
- İdeal: 1 gate = 1 commit (geri sarma kristal netliği)

✅ **Proof Pack Güncelleme:**

- Her gate sonunda `tools/p1.2-proof-pack.ps1` çalıştır
- Proof Pack dosyaları `evidence/p1.2-live/` altına yazılsın
- Regresyon olursa geri dönüş "kanıtlı" olur

✅ **Doğal Bir Sonraki Adım:**

- Checklist güncel olduğuna göre sıradaki gerçek iş: Cursor'a Gate A uygulaması (live-core kontrat + parser + stream + testler) ve ardından Proof Pack runner ile kanıt basmak
- Bu akış oturduğunda P1.3'te Market WS'ye geçiş gerçekten "aynı kalıp + farklı channel" seviyesine düşer; çünkü asıl zorluk olan determinism + guardrails + kanıt üretimi zaten çözülmüş olacak

✅ **UI'da "Canlılık Görelim" İsteği:**

- StatusBar dot + Last: X.s her saniye akar (now tick ✅)
- Streaming sırasında staleness/drops/invalid gerçek rakamla görünür
- Stream biter bitmez idle olur (ama Last akmaya devam eder)
- Bunlar olduğunda kullanıcı artık "sistem çalışıyor mu?" sorusunu hiç sormaz. Çünkü sistem kendini gösterir.

✅ **Montaj Hattı Mantığı:**

- Gate A → Proof Pack koş → tek commit. Sonra Gate B'ye geç.
- Bu sırada P1.2'nin riski dramatik şekilde düşer, P1.3 WS işi kopyala-yapıştır kalıbına yaklaşır.

---

## Cursor'a Tek Blok Görev (Gate A Montajı)

**PATCH — P1.2 Gate A (TEST-FIRST) / @spark/live-core omurga**

**AMAÇ:**

- YALNIZCA packages/live-core içinde: envelope + staleness + SSEParser + startCopilotStream + subpath exports + testler.
- Gate A PASS olmadan Gate B'ye geçme.

**SCOPE (KESİN):**

- ✅ Değiştir/ekle: packages/live-core/\*\*
- ❌ Dokunma: apps/**, packages/live-react/**, route.ts, UI

**GATE A PASS (KABUL KRİTERLERİ):**

- pnpm -w typecheck PASS
- pnpm --filter @spark/live-core test -- --runInBand PASS (flake yok)
- Subpath exports çalışıyor:
  - @spark/live-core/envelope
  - @spark/live-core/sse
  - @spark/live-core/staleness
  - @spark/live-core/copilot
- SSEParser: 7/7 test PASS (chunk boundary + CRLF + multiline + garbage + incomplete + multi-event + combo)
- startCopilotStream: 3 test PASS (abort / normal completion / network error)
- set GATE_NAME=GateA && tools\p1.2-proof-pack.cmd => exit 0 + evidence/p1.2-live/proof_summary.txt RESULT=PASS

**ÇALIŞMA SIRASI (TEST-FIRST):**

1. Test dosyalarını ve helper'ları yaz (SSEParser + startCopilotStream) → FAIL gör
2. live-core paket iskeleti + exports/subpath (dist path'ler)
3. SSEParser implement et → 7 test PASS
4. Envelope + Zod + minimal validation ekle
5. Staleness (policy + compute + export) ekle
6. startCopilotStream implement et (SSEParser + abort/complete/error semantiği) → 3 test PASS
7. Komutlar + Proof Pack + tek commit

**DOSYA YAPISI (HEDEF):**

```
packages/live-core/
  package.json
  tsconfig.json
  src/
    envelope/
      LiveEvent.ts
      index.ts
    staleness/
      policies.ts
      computeStaleness.ts
      index.ts
    sse/
      SSEParser.ts
      index.ts
    copilot/
      startCopilotStream.ts
      index.ts
    index.ts
  __tests__/
    SSEParser.test.ts
    startCopilotStream.test.ts
    testHelpers.ts
```

**SUBPATH EXPORTS (KESİN KURAL):**

- package.json exports:
  - `"."` -> dist/index.js + dist/index.d.ts
  - `"./envelope"` -> dist/envelope/index.js + dist/envelope/index.d.ts
  - `"./staleness"` -> dist/staleness/index.js + dist/staleness/index.d.ts
  - `"./sse"` -> dist/sse/index.js + dist/sse/index.d.ts
  - `"./copilot"` -> dist/copilot/index.js + dist/copilot/index.d.ts
- Her subpath için hem "import" hem "types" verilecek.

**1) PAKET İSKELETİ + EXPORTS**

**Oluştur:**

```
packages/live-core/
  package.json
  tsconfig.json
  src/
    envelope/index.ts
    sse/index.ts
    staleness/index.ts
    copilot/index.ts
    (opsiyonel) index.ts  (DİKKAT: root barrel minimal olsun; kritik şeyleri subpath'ten export et)
```

**package.json EXPORTS (örnek şablon; TS build dist'e çıkacak):**

- `"type": "module"`
- `"files": ["dist"]`
- exports içinde "." + subpath'ler:
  - `"."` → `dist/index.js` (minimal)
  - `"./envelope"` → `dist/envelope/index.js`
  - `"./sse"` → `dist/sse/index.js`
  - `"./staleness"` → `dist/staleness/index.js`
  - `"./copilot"` → `dist/copilot/index.js`

**NOT:** Gate A'da "server bundle'a browser kodu sızmasın" kuralı için:

- startCopilotStream sadece @spark/live-core/copilot'ta kalsın
- validateLiveEvent sadece @spark/live-core/envelope'ta kalsın
- root export (".") mümkünse SADECE types/const minimal; kritik importlar subpath'ten yapılacak.

---

**2) ENVELOPE (ZOD)**

**Dosya:** `packages/live-core/src/envelope/LiveEvent.ts`

- LiveEventSchema (v,event,channel,seq,ts,ok,data, errorCode?)
- validateLiveEvent(raw) -> {valid,event?,error?}
- validateLiveEventMinimal(raw) -> boolean (hafif kontrol)

**Dosya:** `packages/live-core/src/envelope/index.ts`

- `export * from "./LiveEvent.js"`

---

**3) STALENESS**

**Dosya:** `packages/live-core/src/staleness/policies.ts`

- STALENESS_POLICIES
- getStalenessPolicy(eventType) export (EKSİK KALMAYACAK)

**Dosya:** `packages/live-core/src/staleness/computeStaleness.ts`

- computeStaleness(now,lastTs,policy) => {status:'ok'|'warn'|'stale', seconds:number}

**Dosya:** `packages/live-core/src/staleness/index.ts`

- `export * from "./policies.js"`
- `export * from "./computeStaleness.js"`

---

**4) SSE PARSER (SSEParser)**

**Dosya:** `packages/live-core/src/sse/SSEParser.ts`

**API (KESİN):**

```typescript
class SSEParser {
  feed(chunk: string): void;
  parse(): string[]; // "data payload" string listesi (JSON parse burada yapılmaz)
}
```

**SSEParser KURALLARI (KESİN):**

- delimiter: event ayıracı hem `"\n\n"` hem `"\r\n\r\n"` destekler
- buffer: feed ile gelen parçaları biriktir; delimiter yoksa parse() boş döner, buffer korunur
- multiline data: aynı event içindeki birden fazla `"data:"` satırını `"\n"` ile birleştir
  örn:
  ```
  data: {"a":1
  data: ,"b":2}
  \n\n
  ```
  => payload = `{"a":1\n,"b":2}` (birleştirme `"\n"` ile)
- ignore/tolerans:
  - `":"` ile başlayan comment satırlarını at
  - `"event:"`, `"id:"`, `"retry:"` gibi alanları ignore et
  - bilinmeyen alanlar/çöp satır -> ignore
  - boş satırları ignore
- `"data:"` dışı satırlar payload'a girmez
- incomplete event: delimiter gelmeden payload üretmez

**Dosya:** `packages/live-core/src/sse/index.ts`

- `export * from "./SSEParser.js"`

---

**5) COPILOT (startCopilotStream) — REQUEST-SCOPED**

**Dosya:** `packages/live-core/src/copilot/startCopilotStream.ts`

**Interface (KESİN):**

```typescript
type CopilotStreamCallbacks = {
  onEvent: (event: import("../envelope/LiveEvent.js").LiveEvent) => void;
  onComplete?: () => void;
  onError?: (err: Error) => void;
};

type CopilotStreamSession = {
  abort: () => void;
  done: Promise<void>; // test ve üst katman için deterministik kapanış
};

export function startCopilotStream(
  payload: { message: string; requestId?: string },
  callbacks: CopilotStreamCallbacks,
  options?: { url?: string; fetchImpl?: typeof fetch } // test için inject edilebilir
): Promise<CopilotStreamSession>;
```

**Davranış (KESİN):**

- fetch POST {message, requestId?} -> response.body.getReader()
- TextDecoder + SSEParser:
  - reader.read() chunk -> decoder.decode -> parser.feed(str)
  - parser.parse() => payload stringleri
  - her payload string için:
    - JSON.parse
    - validateLiveEventMinimal true ise: callbacks.onEvent(event), invalid değilse last-seen güncellenebilir (live-react'ta yapılacak)
    - invalid JSON veya invalid event => DROP (burada metrik yok; Gate A'da sadece drop)
- Normal completion:
  - reader.read() done=true -> callbacks.onComplete() (varsa) ve done resolve
  - onError ÇAĞRILMAZ, reconnect yok
- Network error:
  - fetch non-ok -> throw -> onError(err) ve done reject/resolve (tercihen reject)
- Abort semantiği:
  - session.abort() => AbortController.abort()
  - abort kaynaklı hata onError sayılmayacak
  - done resolve olmalı (test deterministic)

**Dosya:** `packages/live-core/src/copilot/index.ts`

- `export * from "./startCopilotStream.js"`

---

**TESTLER (ÖNCE YAZ) — SSEParser (7 test)**

**SSEParser API (KESİN):**

- `parser.feed(chunk: string): void`
- `parser.parse(): string[]` // "data:" payload string'leri (bir event = tek birleşik data string)

**Kurallar (KESİN):**

- Delimiter: `"\n\n"` ve `"\r\n\r\n"` destekle
- Multi-line data: `"data: a\ndata: b\n\n"` => `"a\nb"`
- Garbage toleransı: `":comment"`, `"event:"`, `"id:"`, `"retry:"` satırlarını ignore
- Incomplete event: delimiter yoksa parse() boş dönmeli
- "data:" satırları yoksa event drop (boş payload üretme)

**Test 1: Chunk boundary (iki parçaya bölünmüş data satırı)**

- feed('data: {"a":1')
- feed('}\n\n')
- parse() => ['{"a":1}']

**Test 2: Multi-line data birleşimi**

- feed('data: line1\ndata: line2\n\n')
- parse() => ['line1\nline2']

**Test 3: CRLF delimiter**

- feed('data: {"ok":true}\r\n\r\n')
- parse() => ['{"ok":true}']

**Test 4: Garbage toleransı**

- feed(':comment\nevent: msg\ndata: {"x":1}\n\n')
- parse() => ['{"x":1}']

**Test 5: Incomplete event boş dönmeli**

- feed('data: {"x":1}')
- parse() => [] // delimiter yok
- feed('\n\n')
- parse() => ['{"x":1}']

**Test 6: JSON split + multi-line birlikte (en zor)**

- feed('data: {"a":"hel')
- feed('lo"}\ndata: {"b":2}\n\n')
- parse() => ['{"a":"hello"}\n{"b":2}']

**Test 7: Unknown field satırları ignore**

- feed('foo: bar\ndata: {"z":9}\n\n')
- parse() => ['{"z":9}']

**TESTLER (ÖNCE YAZ) — startCopilotStream (3 test)**

**Interface (KESİN):**

- `startCopilotStream(payload, callbacks)` => `Promise<{ abort(): void }>`
- callbacks:
  - `onEvent(rawJsonText: string)` // SSEParser'dan çıkan data string
  - `onComplete()`
  - `onError(err)`

**Davranış (KESİN):**

- fetch + response.body.getReader + TextDecoder + SSEParser kullanır
- reader done:true => onComplete (reconnect yok)
- AbortError => onComplete gibi davranabilir ama onError ASLA çağrılmaz
- Network/parse error => onError çağrılır

**Test A: Abort garantisi**

- Fake reader sonsuz okumada kalsın, session.abort() çağır
- onError çağrılmamalı

**Test B: Normal completion**

- Reader iki chunk + done:true döndürsün
- onEvent doğru sayıda çağrılsın, onComplete çağrılsın, onError yok

**Test C: Network error**

- reader.read() throw etsin (AbortError değil)
- onError çağrılsın

**TEST HELPER NOTU:**

- Minimal fake ReadableStream reader yaz (dependency ekleme).
- TextEncoder/TextDecoder yoksa Node'da global mevcut; yoksa test helper'da minimal polyfill (string->utf8 length için gerekirse).

**5 "SON KONTROL" (GİZLİ MAYINLAR):**

1. Subpath exports + types: her subpath import+types
2. Jest/TS modu tutarlı: **Testler src üzerinden koşsun** (ts-jest/transform vs nasıl ayarlıysa o düzenle). Dist üzerinden test etmeye kalkarsan export path + ESM/CJS farkları yüzünden Windows'ta ekstra sürtünme çıkar. **Hedef: minimum friction → maksimum determinism.**
3. ReadableStream/TextEncoder ortamı: native varsa kullan, yoksa minimal polyfill
4. SSEParser parse(): delimiter görmeden asla payload döndürme
5. AbortError: onError YOK, normal kapanış gibi

**Gate A için 5 saniyelik "son son kontrol" listesi (pratik):**

1. SSEParser.parse() delimiter görmeden asla payload döndürmüyor ✅
2. CRLF delimiter testi gerçekten `\r\n\r\n` ile ayrıyor ✅
3. AbortError: onError yok; normal kapanış ✅
4. package.json exports her subpath'te import + types ✅
5. Proof Pack GateA: `set GATE_NAME=GateA` ile fazlandırılmış runner ✅

**KOMUTLAR:**

- `pnpm --filter @spark/live-core test -- --runInBand`
- `pnpm -w typecheck`
- `set GATE_NAME=GateA`
- `tools\p1.2-proof-pack.cmd`

**COMMIT (TEK):**

- "P1.2 GateA: live-core envelope + SSEParser + startCopilotStream"

**ÇIKIŞ (Cursor FINAL SUMMARY):**

- Başlık, Durum, Çalıştırılan Komutlar, Eklenen/Değişen Dosyalar, Test Sonuçları, Hatalar/Uyarılar, Evidence çıktıları, Next Step (Gate B)
- Ara log yok; tek final özet.

**Gate A bitince (Proof Pack exit 0) Gate B için de aynı formatta "tek blok görev"i çıkarabiliriz; orada iş gerçekten route.ts envelope/seq/runtime/headers + zod validate montajına dönüyor.**

---

## Cursor'a Tek Blok Görev (Gate B Montajı)

**PATCH — P1.2 Gate B (route.ts) / Copilot SSE → Envelope + Seq Reset + Streaming Stabilitesi**

**SCOPE (KESİN):**

- ✅ Dokun: `apps/web-next/src/app/api/copilot/chat/route.ts` (ve gerekirse aynı route'un yan helper'ları)
- ✅ İzinli küçük ek: `apps/web-next/src/lib/**` (pure helper fonksiyonları) — opsiyonel
- ❌ Dokunma: `packages/live-core/**` (Gate A bitti), `packages/live-react/**`, UI componentleri
- ❌ UI tarafında raw parsing ekleme (zaten Gate D guard yakalayacak)

**AMAÇ:**

- Copilot SSE çıkışı TEK format: LiveEvent envelope (v1)
- Seq reset kuralı: her request'te seq=0'dan başlar, stream içinde monoton artar
- Streaming stabilitesi: runtime/dynamic/headers doğru
- Zod validation gateway çıkışında: invalid event gönderilmez (logla + drop)
- Normal completion: message_done gönder, stream'i kapat
- AbortError: "normal kapanış" (error event yok)

**GATE B PASS (KABUL KRİTERLERİ):**

1. route.ts SSE payload'larının TAMAMI LiveEvent envelope (`v`, `event`, `channel`, `seq`, `ts`, `ok`, `data`[, `errorCode`])
2. Seq semantiği: her request seq=0'dan başlar; aynı request içinde 0,1,2... (message_done dahil)
3. route.ts üstünde streaming stabilitesi export'ları var:
   - `export const runtime = "nodejs"`
   - `export const dynamic = "force-dynamic"`
   - Response headers doğru (Content-Type text/event-stream; cache-control no-cache/no-transform; keep-alive; x-accel-buffering no)
4. Server import kuralı: SADECE `@spark/live-core/envelope` (root import YOK)
5. Typecheck PASS: `pnpm -w typecheck`
6. Proof Pack GateB PASS: `set GATE_NAME=GateB` + `tools\p1.2-proof-pack.cmd` → exit 0

**UYGULAMA PLANI (PRATİK):**

**A) route.ts'e stabilite export'larını ekle:**

- `export const runtime = "nodejs"`
- `export const dynamic = "force-dynamic"`

**B) SSE yazma yardımcılarını oluştur (route.ts içinde olabilir):**

- `encoder = new TextEncoder()`
- `function writeEvent(writer, liveEventObj): JSON.stringify + "data: ...\n\n"`
- Header'lar:
  - `Content-Type: text/event-stream; charset=utf-8`
  - `Cache-Control: no-cache, no-transform`
  - `Connection: keep-alive`
  - `X-Accel-Buffering: no`

**C) Envelope builder (seq + ts + channel sabit):**

- `channel: "copilot:chat"`
- `let seq = 0` (request scope)
- `make(eventType, data, ok=true, errorCode?)` → `{ v:1, event, channel, seq: seq++, ts: Date.now(), ok, ...(errorCode?), data }`

**D) Validation (GATE B'nin kilidi):**

- `import { validateLiveEvent, type LiveEvent } from "@spark/live-core/envelope";`
- gönderim öncesi `validateLiveEvent(event).valid` değilse:
  - `console.error` + DROP (writer.write yapma)
- NOT: Gate A'daki subpath export kuralı bozulmasın: root import kullanma

**E) Event tipleri (en az):**

- `token` → `data:{ content:string }`
- `tool_call` / `tool_result` → `data:{ ... }`
- `job_started` / `job_progress` / `job_done` / `job_failed` → `data:{ ... }`
- `error` → `ok:false`, `data:{ message, errorCode? }`, + `errorCode` alanı mümkünse set
- `message_done` → `data:{}`

**F) Normal completion / abort / error semantiği:**

- Stream normal biterse: `message_done` gönder → `writer.close()`
- AbortError ise: error event YOK, sadece close (normal kapanış)
- Network/unknown error ise: error event gönder (`ok:false`) → close

**G) Seq reset doğrulaması (kod içi pratik):**

- `seq` değişkeni route handler scope'unda (her request'te yeniden 0)
- `message_done` da seq tüketir (son event)

**6 "SON KONTROL" (GİZLİ MAYINLAR — PROD'DA CAN YAKAN TÜRDEN):**

1. **SSE flush / buffering kilidi:**
   - Header'a `X-Accel-Buffering: no` (Nginx) kesin.
   - `Cache-Control: no-cache, no-transform` kesin.
   - Eğer platform proxy araya giriyorsa, `no-transform` çok kritik (SSE'yi "optimize" etmeye kalkıp bozar).

2. **Her event "tek satır JSON" olmalı:**
   - `data: ${JSON.stringify(event)}\n\n` dışında multi-line JSON üretme.
   - Multi-line olursa client parser'ın multiline SSE desteğine güvenirsin; ama Gate B'de server tarafında bunu sıfır riskli yap: tek satır.

3. **seq mutlak suretle "request scope":**
   - `let seq = 0;` handler scope'unda olmalı.
   - Module-level seq gördün mü direkt kırmızı alarm (replay/debug kabusu).

4. **ts kaynağı tek: Date.now():**
   - Event üretiminde ts için farklı kaynak/clock karışmasın.
   - `message_done` da ts alsın (telemetry "last event" kuralı için).

5. **AbortError kuralı: "error event yok":**
   - AbortError yakalanınca:
     - error envelope basma
     - sadece stream'i kapat
   - Bu, live-react tarafında "cancel → idle" determinism'ini korur.

6. **Validation drop davranışı "sessiz değil, kanıtlı":**
   - Invalid event drop ediyorsan:
     - `console.error("Invalid LiveEvent dropped", {error, eventType})`
     - ama SSE'ye invalid şey yollama
   - (İstersen Gate D'de metriğe bağlarsın; Gate B'de log yeter.)

**SMOKE TEST:**

- `pnpm -w typecheck`
- (opsiyonel) Dev server açıkken hızlı göz testi:
  - CopilotDock'ta 1 mesaj gönder → network response'ta `data: { "v":1, "channel":"copilot:chat", "seq":0 ... }` görülmeli
- Proof Pack:
  - `set GATE_NAME=GateB`
  - `tools\p1.2-proof-pack.cmd`
  - `evidence/p1.2-live/proof_summary.txt` RESULT=PASS olmalı

**Gate B için "Proof Pack" pratik notu:**

- GateB fazında runner UI guard'ı çalıştırmıyor; doğru.
- Ama Gate B'nin kendisini doğrulamak için `evidence/p1.2-live/typecheck.txt` ve `jest_live_core.txt` yanında route.ts değişikliğinin diff'ini de eklemek istersen, runner'a ileride `git diff --name-only` gibi bir satır ekleyebilirsin. (Şart değil, audit için şahane.)

**COMMIT:**

- Tek commit: `P1.2 GateB: route.ts envelope + seq reset + streaming headers`

**ÇIKIŞ (Cursor FINAL SUMMARY):**

- Başlık
- Durum (PASS/FAIL)
- Çalıştırılan komutlar
- Değişen dosyalar
- Kanıt dosyaları (evidence/p1.2-live/\*)
- Hatalar/uyarılar
- Next step: Gate C (live-react session/assembly/limits)

**Not:** Proof Pack'in GateB fazında UI guard çalışmıyor (doğru); Gate D'de "UI parsing yok + StatusBar kuralları" zaten otomatik kilit olacak.

**Gate B bittiğinde artık "server → standard envelope" hattın oturmuş olacak. Ondan sonra Gate C (live-react session manager + token assembly + limits + telemetry) gerçekten montaj: store/hook'lar, refCount ve assembly testleri.**

**Montaj hattındaki sonraki adım (Gate C) için hazır şablon:**

- Gate B PASS olunca Gate C'nin özü şu: live-react session manager + token assembly + limits + telemetry.
- En kritik kilit: Dock + StatusBar aynı anda açıkken tek stream ve token başına mesaj patlamaması.

**⚠️ Ek "minik ama can yakıcı" iki not (Gate A'da genelde bunlar patlatır):**

1. **Abort semantiği:** AbortError'ı "normal kapanış" say; onError'a düşürme. (Aksi halde cancel her zaman kırmızı alarm üretir.)

2. **SSEParser delimiter:** CRLF (`\r\n\r\n`) desteği yoksa Windows/Proxy katmanlarında "arada bozuldu" diye hayalet bug çıkar.

**⚠️ 5 Küçük "Son Kontrol" (Windows/ESM/Stream Tarafında Gizli Mayın):**

1. **Subpath exports + types:**
   - exports her subpath için hem "import" hem "types" versin.
   - Aksi halde TS editor'da importlar "çalışıyor gibi" görünüp typecheck'te sürpriz yapabiliyor.
   - Örnek: `"./envelope": { "import": "./dist/envelope/index.js", "types": "./dist/envelope/index.d.ts" }`

2. **Jest/TS çalıştırma modu tutarlılığı:**
   - Repo jest/ts-jest mi kullanıyor, yoksa transpile edilmiş dist üstünden mi test koşuyor?
   - Gate A'da ideal: testler src üstünden (ts-jest/swc) koşsun ya da önce build alıp dist test etsin; iki mod karışınca "flake" çıkar.

3. **ReadableStream / TextEncoder ortamı:**
   - Node ortamında ReadableStream/TextEncoder bazen konfigürasyona göre yok olabiliyor.
   - Test helper'da "varsa native kullan, yoksa minimal polyfill" yaklaşımı Gate A'yı stabil tutar (yeni dependency eklemeden).

4. **SSEParser parse() davranışı (çok kritik):**
   - parse() sadece tam event (delimiter gördü) döndürsün.
   - feed() sonrası delimiter yokken parse() boş dönmeli (incomplete event testi zaten bunu kilitliyor).

5. **AbortError kesin kural:**
   - AbortError → onError yok, session "normal kapandı" gibi davranacak.
   - Bu kural ileride UI'da "Cancel" basınca kırmızı alarm patlamasını engelliyor.

**Montaj Hattında Bir Sonraki "Mekanik" Adım:**

Gate A tamamlanınca yapman gereken akış net:

1. `set GATE_NAME=GateA`
2. `tools\p1.2-proof-pack.cmd` → exit 0
3. tek commit: `P1.2 GateA: live-core envelope + SSEParser + startCopilotStream`
4. Sonra Gate B'ye geçiş (route.ts envelope/seq/runtime/headers + zod validate) gerçekten "kopyala-yapıştır disiplininde" ilerler; çünkü canlılık omurgasının en riskli kısmı Gate A'da taş gibi kilitlenmiş olur.

**Bu blokla Gate A gerçekten "testleri geçirene kadar ilerleme yok" disiplinine kilitleniyor. Gate A PASS olunca Gate B (route.ts envelope/seq/runtime/headers + zod validate) zaten mekanikleşiyor.**

---

## Real-World Check'leri Script'lenebilir Hale Getir

**Tam otomasyon zor (DevTools ekranı vs), ama %70'i komutla olur:**

✅ **Script'lenebilir Check'ler:**

1. **UI Parsing Yok Grep:**

   ```powershell
   # tools/copilot-smoke-test.ps1
   # → grep_ui_parsing.txt dosyasına yaz
   ```

2. **Unit Test Paketleri:**

   ```bash
   # jest_live_core.txt
   npm test -- packages/live-core > evidence/p1.2-live/jest_live_core.txt

   # jest_live_react.txt
   npm test -- packages/live-react > evidence/p1.2-live/jest_live_react.txt
   ```

3. **60s Stress Sonrası Metrik Snapshot:**

   ```bash
   # 60s_stress_metrics.txt
   curl http://localhost:3000/api/public/metrics > evidence/p1.2-live/60s_stress_metrics.txt
   ```

4. **Network Single Request:**
   - Manuel: DevTools → Network tab → Screenshot
   - Otomasyon: Playwright/Puppeteer ile screenshot alınabilir (opsiyonel)

**Kabul Kriteri:**

- [ ] Grep çıktısı → `grep_ui_parsing.txt` dosyasına yazılıyor
- [ ] Jest test logları → `jest_live_core.txt` ve `jest_live_react.txt` dosyalarına yazılıyor
- [ ] Metrik snapshot → `60s_stress_metrics.txt` dosyasına yazılıyor
- [ ] Network screenshot → `network_single_request.png` mevcut (manuel veya otomatik)

**Avantaj:**

- P1.3'e geçerken aynı harness'i Market WS için aynen kullanırsın
- Regressions yakalanır
- Kanıt üretimi otomatikleşir

---

## Uygulama Sırası (Kritik Hatırlatma)

**Önce live-core kontrat + parser + stream session (ve testleri), sonra route.ts envelope/seq, sonra live-react session manager + assembly/limits, en son UI migration + smoke guard.**

**Bu sırayı bozarsan sistem "çalışıyormuş gibi" yapıp prod'da sürpriz çıkarma ihtimali artar.**

✅ **Kritik Sıra:**

1. **live-core → Çekirdek Kontrat + SSEParser + Copilot Session**
   - Paket oluşturma
   - Envelope + Zod validation
   - SSEParser (chunk boundary, multi-line, çöp satır, CRLF, JSON split)
   - startCopilotStream (abort, normal completion vs network error)
   - **Testler:** SSEParser (5 test), startCopilotStream (2 test)

2. **route.ts → Tek Çıkış Formatı (Envelope) + Seq Semantiği**
   - Envelope formatına çevir
   - Seq semantiği (reset kuralı)
   - Event tipleri standardize
   - Gateway çıkışında Zod validation
   - Streaming stabilitesi (runtime, dynamic, headers)

3. **live-react → Store + Session Manager + Assembly**
   - copilotSessionManager (singleton + refCount)
   - liveStore (bellek sınırları, token assembly, backpressure_drop semantiği)
   - useCopilotChat hook
   - **Testler:** refCount, ikiz bağlantı, bellek sınırları, token assembly

4. **UI Migration**
   - CopilotDock.tsx → useCopilotChat() kullanımı
   - StatusBar.tsx → store'dan okuma (client başlatmaz)
   - Raw SSE parsing kaldırma

5. **Smoke Test + Proof Pack**
   - Grep "UI parsing yok"
   - Unit testler
   - Proof pack oluşturma

**Kabul Kriteri:**

- [ ] Sıra bozulmadı (live-core → route.ts → live-react → UI → smoke)
- [ ] Her adım testleri ile birlikte tamamlandı
- [ ] Proof pack oluşturuldu

---

## Sonuç

**Şu an geldiğiniz nokta: P1.2'yi uygulamak artık mühendislik değil, neredeyse montaj işi (iyi anlamda).**

Bu checklist ile:

- ✅ UI refactor-safe omurga kurulur
- ✅ "Canlı sinir sistemi" yerinden oynamaz
- ✅ P1.3'e geçiş köprüsü hazır
- ✅ Prod'da naz yapmayacak saha dayanıklılığı
- ✅ Kanıtlı çalışıyor (proof pack)
- ✅ Script'lenebilir doğrulamalar (%70 otomasyon)

**Sonraki Mantıklı Adım:**
P1.3'te market WS'yi aynı envelope + store kalıbına sokmak (fiyat/candle/orderbook) ve StatusBar'ı gerçek "canlılık kanıtı paneli"ne çevirmek.
