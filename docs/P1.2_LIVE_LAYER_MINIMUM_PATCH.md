# P1.2 Live Layer Minimum Patch Plan ‚Äî Copilot'u Live Layer'a Ta≈üƒ±ma

## ‚ö†Ô∏è √ñNEMLƒ∞: Delta D√ºzeltmeleri

Bu plan, **8 kritik sorun** i√ßeriyordu. D√ºzeltmeler i√ßin **`P1.2_LIVE_LAYER_MINIMUM_PATCH_DELTA.md`** dosyasƒ±na bakƒ±n.

**Delta'da d√ºzeltilen sorunlar:**
1. Copilot akƒ±≈üƒ±: "Subscribe" deƒüil, request-scoped stream
2. SSE parsing: Chunk boundary problemi
3. Hook'larƒ±n ikiz baƒülantƒ± a√ßma riski
4. Token ba≈üƒ±na "yeni mesaj" patlamasƒ±
5. Server import: "Barrel export" tuzaƒüƒ±
6. NodeJS.Timeout tipi browser'da problem
7. Stream normal bittiƒüinde status "connected" kalƒ±yor
8. getStalenessPolicy export eksik + event tipleri uyu≈ümazlƒ±ƒüƒ±

**Delta dosyasƒ±nƒ± okuyup bu planƒ± g√ºncelleyin.**

---

## Hedef

**En d√º≈ü√ºk riskli adƒ±m:** Copilot'u Live Layer'a ta≈üƒ±. Market WS'yi ikinci dalga (P1.3) yaparsƒ±n; ama omurga P1.2'de oturur.

**Sonu√ß:**
- UI'da hi√ßbir yerde "raw SSE parsing" kalmƒ±yor (yasak)
- Copilot stream Live Layer √ºzerinden √ßalƒ±≈üƒ±yor
- Omurga hazƒ±r, Market WS i√ßin zemin var

---

## 1. Paket Olu≈üturma

### @spark/live-core (React YOK)

**Dosya:** `packages/live-core/package.json`

```json
{
  "name": "@spark/live-core",
  "version": "0.1.0",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "dependencies": {
    "zod": "^3.22.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  }
}
```

**Dosya:** `packages/live-core/tsconfig.json`

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src/**/*"]
}
```

### @spark/live-react (React VAR)

**Dosya:** `packages/live-react/package.json`

```json
{
  "name": "@spark/live-react",
  "version": "0.1.0",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "dependencies": {
    "@spark/live-core": "workspace:*",
    "zustand": "^4.4.0",
    "react": "^18.0.0"
  },
  "devDependencies": {
    "@types/react": "^18.0.0",
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  },
  "peerDependencies": {
    "react": "^18.0.0"
  }
}
```

**Dosya:** `packages/live-react/tsconfig.json`

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "declaration": true,
    "declarationMap": true,
    "jsx": "react-jsx"
  },
  "include": ["src/**/*"]
}
```

---

## 2. Envelope + Validation (Core)

### LiveEvent Type + Zod Schema

**Dosya:** `packages/live-core/src/envelope/LiveEvent.ts`

```typescript
import { z } from 'zod';

/**
 * Standard Live Event Envelope
 *
 * P1.2: Runtime validation with Zod schema
 */
export const LiveEventSchema = z.object({
  v: z.number().int().min(1).max(10), // Version (1-10)
  event: z.string().min(1).max(100),   // Event type
  channel: z.string().min(1).max(200), // Channel identifier
  seq: z.number().int().min(0),        // Monoton artan sequence
  ts: z.number().int().positive(),     // Timestamp (ms)
  ok: z.boolean(),                      // Success/failure
  errorCode: z.string().optional(),     // Error code
  data: z.any(),                        // Event-specific payload
});

export type LiveEvent = z.infer<typeof LiveEventSchema>;

/**
 * Validate LiveEvent at runtime (gateway √ßƒ±kƒ±≈üƒ±nda + client giri≈üinde)
 */
export function validateLiveEvent(raw: unknown): { valid: boolean; event?: LiveEvent; error?: string } {
  try {
    const event = LiveEventSchema.parse(raw);
    return { valid: true, event };
  } catch (error) {
    return {
      valid: false,
      error: error instanceof Error ? error.message : 'Invalid LiveEvent',
    };
  }
}

/**
 * Minimal validation (client giri≈üinde - hafif doƒürulama)
 */
export function validateLiveEventMinimal(raw: unknown): boolean {
  if (!raw || typeof raw !== 'object') return false;
  const obj = raw as Record<string, unknown>;
  return (
    typeof obj.v === 'number' &&
    typeof obj.event === 'string' &&
    typeof obj.channel === 'string' &&
    typeof obj.seq === 'number' &&
    typeof obj.ts === 'number' &&
    typeof obj.ok === 'boolean'
  );
}
```

**Dosya:** `packages/live-core/src/envelope/versioning.ts`

```typescript
/**
 * Version handling for backward compatibility
 */
export interface VersionHandler {
  parse(event: LiveEvent): LiveEvent;
  serialize(event: Omit<LiveEvent, 'v'>): LiveEvent;
}

const V1_HANDLER: VersionHandler = {
  parse: (event) => event, // v1 = passthrough
  serialize: (event) => ({ ...event, v: 1 }),
};

const VERSION_HANDLERS: Record<number, VersionHandler> = {
  1: V1_HANDLER,
};

export function getVersionHandler(version: number): VersionHandler | null {
  return VERSION_HANDLERS[version] || null;
}
```

**Dosya:** `packages/live-core/src/index.ts`

```typescript
export * from './envelope/LiveEvent.js';
export * from './envelope/versioning.js';
export * from './client/LiveClient.js';
export * from './staleness/computeStaleness.js';
export * from './backpressure/QueueManager.js';
```

---

## 3. Staleness (Core)

**Dosya:** `packages/live-core/src/staleness/policies.ts`

```typescript
export interface StalenessPolicy {
  okThreshold: number;    // ms
  warnThreshold: number;  // ms
  staleThreshold: number; // ms
}

export const STALENESS_POLICIES: Record<string, StalenessPolicy> = {
  market_tick: { okThreshold: 1000, warnThreshold: 3000, staleThreshold: 10000 },
  candle: { okThreshold: 2000, warnThreshold: 5000, staleThreshold: 15000 },
  job_progress: { okThreshold: 5000, warnThreshold: 15000, staleThreshold: 30000 },
  copilot_stream: { okThreshold: 2000, warnThreshold: 5000, staleThreshold: 10000 },
};

export function getStalenessPolicy(eventType: string): StalenessPolicy {
  return STALENESS_POLICIES[eventType] || STALENESS_POLICIES.copilot_stream;
}
```

**Dosya:** `packages/live-core/src/staleness/computeStaleness.ts`

```typescript
import { getStalenessPolicy, type StalenessPolicy } from './policies.js';

export interface StalenessResult {
  status: 'ok' | 'warn' | 'stale';
  seconds: number;
}

/**
 * Compute staleness status (tek yerde hesaplama)
 *
 * P1.2: UI sadece ok|warn|stale + seconds g√∂rs√ºn (hesaplama core'da)
 */
export function computeStaleness(
  now: number,
  lastTs: number,
  policy: StalenessPolicy
): StalenessResult {
  const seconds = (now - lastTs) / 1000;

  if (seconds <= policy.okThreshold / 1000) {
    return { status: 'ok', seconds };
  } else if (seconds <= policy.warnThreshold / 1000) {
    return { status: 'warn', seconds };
  } else {
    return { status: 'stale', seconds };
  }
}
```

---

## 4. Backpressure (Core)

**Dosya:** `packages/live-core/src/backpressure/QueueManager.ts`

```typescript
import type { LiveEvent } from '../envelope/LiveEvent.js';

export interface QueueConfig {
  maxSize: number;        // 100-200 event/channel
  dropOldest: boolean;    // true
  emitWarnEvent: boolean; // true
}

export interface BackpressureDropEvent {
  event: 'backpressure_drop';
  channel: string;
  data: {
    droppedSeq: number;
    queueSize: number;
  };
}

export class QueueManager {
  private queues = new Map<string, LiveEvent[]>();
  private dropCallbacks: Array<(event: BackpressureDropEvent) => void> = [];

  constructor(private config: QueueConfig) {}

  add(channel: string, event: LiveEvent): void {
    const queue = this.queues.get(channel) || [];

    if (queue.length >= this.config.maxSize) {
      // Drop oldest
      const dropped = queue.shift();
      // Emit backpressure_drop event
      if (this.config.emitWarnEvent && dropped) {
        this.emitBackpressureDrop(channel, dropped.seq, queue.length);
      }
    }

    queue.push(event);
    this.queues.set(channel, queue);
  }

  get(channel: string): LiveEvent[] {
    return this.queues.get(channel) || [];
  }

  clear(channel: string): void {
    this.queues.delete(channel);
  }

  onDrop(callback: (event: BackpressureDropEvent) => void): void {
    this.dropCallbacks.push(callback);
  }

  private emitBackpressureDrop(channel: string, droppedSeq: number, queueSize: number): void {
    const dropEvent: BackpressureDropEvent = {
      event: 'backpressure_drop',
      channel,
      data: { droppedSeq, queueSize },
    };

    for (const callback of this.dropCallbacks) {
      callback(dropEvent);
    }
  }
}
```

---

## 5. LiveClient (Core)

**Dosya:** `packages/live-core/src/client/types.ts`

```typescript
export type LiveClientStatus = 'disconnected' | 'connecting' | 'connected' | 'reconnecting' | 'degraded';

export interface LiveClientConfig {
  url: string;
  reconnectDelays: number[]; // [1000, 2000, 4000, 8000, 16000]
  heartbeatInterval: number;  // 10000 ms
  maxReconnectAttempts: number; // 10
}

export interface LiveClientCallbacks {
  onEvent?: (event: LiveEvent) => void;
  onStatusChange?: (status: LiveClientStatus) => void;
  onError?: (error: Error) => void;
}
```

**Dosya:** `packages/live-core/src/client/LiveClient.ts`

```typescript
import type { LiveEvent } from '../envelope/LiveEvent.js';
import { validateLiveEventMinimal } from '../envelope/LiveEvent.js';
import type { LiveClientConfig, LiveClientStatus, LiveClientCallbacks } from './types.js';

/**
 * LiveClient - WS/SSE baƒülantƒ± y√∂netimi (React yok)
 *
 * P1.2: SSE adapter (mevcut SSE'yi LiveClient i√ßine al)
 */
export class LiveClient {
  private status: LiveClientStatus = 'disconnected';
  private reconnectAttempt = 0;
  private reconnectTimer: NodeJS.Timeout | null = null;
  private heartbeatTimer: NodeJS.Timeout | null = null;
  private lastHeartbeat = 0;
  private abortController: AbortController | null = null;

  constructor(
    private config: LiveClientConfig,
    private callbacks: LiveClientCallbacks
  ) {}

  connect(): void {
    if (this.status === 'connected' || this.status === 'connecting') {
      return;
    }

    this.status = 'connecting';
    this.callbacks.onStatusChange?.(this.status);

    // P1.2: SSE adapter (mevcut SSE'yi LiveClient i√ßine al)
    this.connectSSE();
  }

  private async connectSSE(): Promise<void> {
    this.abortController = new AbortController();

    try {
      const response = await fetch(this.config.url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ type: 'subscribe', channels: ['copilot:chat'] }),
        signal: this.abortController.signal,
      });

      if (!response.ok) {
        throw new Error(`SSE connection failed: ${response.status}`);
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error('No response body');
      }

      const decoder = new TextDecoder();
      this.status = 'connected';
      this.reconnectAttempt = 0;
      this.callbacks.onStatusChange?.(this.status);
      this.startHeartbeat();

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value, { stream: true });
        const lines = chunk.split('\n').filter(line => line.trim() !== '');

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6);
            try {
              const raw = JSON.parse(data);

              // P1.2: Minimal validation (client giri≈üinde)
              if (validateLiveEventMinimal(raw)) {
                const event = raw as LiveEvent;
                this.lastHeartbeat = Date.now();
                this.callbacks.onEvent?.(event);
              } else {
                // Invalid event ‚Üí drop
                console.warn('Invalid LiveEvent dropped:', raw);
              }
            } catch (error) {
              // Malformed JSON ‚Üí drop
              console.warn('Malformed JSON dropped:', data);
            }
          }
        }
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        // Client disconnect ‚Üí don't reconnect
        return;
      }

      this.status = 'disconnected';
      this.callbacks.onStatusChange?.(this.status);
      this.scheduleReconnect();
    }
  }

  private scheduleReconnect(): void {
    if (this.reconnectAttempt >= this.config.maxReconnectAttempts) {
      this.status = 'degraded';
      this.callbacks.onStatusChange?.(this.status);
      return;
    }

    const delay = this.config.reconnectDelays[
      Math.min(this.reconnectAttempt, this.config.reconnectDelays.length - 1)
    ];
    const jitter = Math.random() * 1000; // ¬±1s
    const totalDelay = delay + jitter;

    this.reconnectTimer = setTimeout(() => {
      this.reconnectAttempt++;
      this.status = 'reconnecting';
      this.callbacks.onStatusChange?.(this.status);
      this.connect();
    }, totalDelay);
  }

  private startHeartbeat(): void {
    this.heartbeatTimer = setInterval(() => {
      const now = Date.now();
      const elapsed = now - this.lastHeartbeat;

      if (elapsed > this.config.heartbeatInterval * 2) {
        // Heartbeat timeout ‚Üí reconnect
        this.disconnect();
        this.scheduleReconnect();
      }
    }, this.config.heartbeatInterval);
  }

  disconnect(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
    this.status = 'disconnected';
    this.callbacks.onStatusChange?.(this.status);
  }

  getStatus(): LiveClientStatus {
    return this.status;
  }
}
```

**Dosya:** `packages/live-core/src/client/DegradeMode.ts`

```typescript
/**
 * Degrade mode: baƒülantƒ± gidince UI "son bilinen deƒüer + amber"
 */
export interface DegradeModeState {
  active: boolean;
  lastKnownValue: any;
  degradedAt: number;
  message: string;
}

export class DegradeMode {
  private state: DegradeModeState = {
    active: false,
    lastKnownValue: null,
    degradedAt: 0,
    message: '',
  };

  activate(lastKnownValue: any, message: string = 'Live mode unavailable, showing last known value'): void {
    this.state = {
      active: true,
      lastKnownValue,
      degradedAt: Date.now(),
      message,
    };
  }

  deactivate(): void {
    this.state = {
      active: false,
      lastKnownValue: this.state.lastKnownValue, // Keep last value
      degradedAt: 0,
      message: '',
    };
  }

  getState(): DegradeModeState {
    return { ...this.state };
  }
}
```

---

## 6. Store + Hooks (React)

**Dosya:** `packages/live-react/src/store/liveStore.ts`

```typescript
import { create } from 'zustand';
import type { LiveEvent } from '@spark/live-core';
import type { LiveClientStatus } from '@spark/live-core';

interface LiveStoreState {
  // Copilot stream
  copilotMessages: Array<{ id: string; content: string; timestamp: Date }>;
  copilotStatus: LiveClientStatus;
  copilotStaleness: { status: 'ok' | 'warn' | 'stale'; seconds: number } | null;

  // Backpressure
  backpressureDrops: number;

  // Actions
  addCopilotMessage: (message: { id: string; content: string; timestamp: Date }) => void;
  setCopilotStatus: (status: LiveClientStatus) => void;
  setCopilotStaleness: (staleness: { status: 'ok' | 'warn' | 'stale'; seconds: number } | null) => void;
  incrementBackpressureDrops: () => void;
  clearCopilotMessages: () => void;
}

export const useLiveStore = create<LiveStoreState>((set) => ({
  copilotMessages: [],
  copilotStatus: 'disconnected',
  copilotStaleness: null,
  backpressureDrops: 0,

  addCopilotMessage: (message) =>
    set((state) => ({
      copilotMessages: [...state.copilotMessages, message],
    })),

  setCopilotStatus: (status) => set({ copilotStatus: status }),

  setCopilotStaleness: (staleness) => set({ copilotStaleness: staleness }),

  incrementBackpressureDrops: () =>
    set((state) => ({
      backpressureDrops: state.backpressureDrops + 1,
    })),

  clearCopilotMessages: () => set({ copilotMessages: [] }),
}));
```

**Dosya:** `packages/live-react/src/hooks/useCopilotStream.ts`

```typescript
import { useEffect, useRef } from 'react';
import { LiveClient } from '@spark/live-core';
import { computeStaleness, getStalenessPolicy } from '@spark/live-core';
import { useLiveStore } from '../store/liveStore.js';

/**
 * useCopilotStream - Copilot chat stream hook
 *
 * P1.2: UI sadece hook kullanƒ±r, raw SSE parsing yapmaz
 */
export function useCopilotStream() {
  const {
    copilotMessages,
    copilotStatus,
    copilotStaleness,
    backpressureDrops,
    addCopilotMessage,
    setCopilotStatus,
    setCopilotStaleness,
    incrementBackpressureDrops,
  } = useLiveStore();

  const clientRef = useRef<LiveClient | null>(null);
  const lastEventTsRef = useRef<number>(0);

  useEffect(() => {
    // Initialize LiveClient
    const client = new LiveClient(
      {
        url: '/api/copilot/chat',
        reconnectDelays: [1000, 2000, 4000, 8000, 16000],
        heartbeatInterval: 10000,
        maxReconnectAttempts: 10,
      },
      {
        onEvent: (event) => {
          // Handle copilot events
          if (event.channel === 'copilot:chat') {
            lastEventTsRef.current = event.ts;

            // Update staleness
            const policy = getStalenessPolicy('copilot_stream');
            const staleness = computeStaleness(Date.now(), event.ts, policy);
            setCopilotStaleness(staleness);

            // Handle event types
            if (event.event === 'token' && event.data?.content) {
              addCopilotMessage({
                id: `msg_${event.seq}`,
                content: event.data.content,
                timestamp: new Date(event.ts),
              });
            } else if (event.event === 'backpressure_drop') {
              incrementBackpressureDrops();
            }
          }
        },
        onStatusChange: (status) => {
          setCopilotStatus(status);
        },
        onError: (error) => {
          console.error('LiveClient error:', error);
        },
      }
    );

    clientRef.current = client;
    client.connect();

    // Staleness check interval
    const stalenessInterval = setInterval(() => {
      if (lastEventTsRef.current > 0) {
        const policy = getStalenessPolicy('copilot_stream');
        const staleness = computeStaleness(Date.now(), lastEventTsRef.current, policy);
        setCopilotStaleness(staleness);
      }
    }, 1000);

    return () => {
      client.disconnect();
      clearInterval(stalenessInterval);
    };
  }, [addCopilotMessage, setCopilotStatus, setCopilotStaleness, incrementBackpressureDrops]);

  return {
    messages: copilotMessages,
    status: copilotStatus,
    staleness: copilotStaleness,
    backpressureDrops,
  };
}
```

**Dosya:** `packages/live-react/src/index.ts`

```typescript
export * from './store/liveStore.js';
export * from './hooks/useCopilotStream.js';
```

---

## 7. Copilot Migration

### SSE Route ‚Üí Envelope Format

**Dosya:** `apps/web-next/src/app/api/copilot/chat/route.ts`

**Deƒüi≈üiklik:** Mevcut SSE event'lerini envelope formatƒ±na uyumlu hale getir:

```typescript
// √ñnce:
write(JSON.stringify({
  event: 'token',
  requestId,
  ts: Date.now(),
  data: { content: chunk.content },
  ok: true,
}));

// Sonra:
write(JSON.stringify({
  v: 1,
  event: 'token',
  channel: 'copilot:chat',
  seq: sseEventCount++,
  ts: Date.now(),
  ok: true,
  data: { content: chunk.content },
}));
```

**Gateway √ßƒ±kƒ±≈üƒ±nda Zod validation:**
```typescript
import { validateLiveEvent } from '@spark/live-core';

// Event g√∂ndermeden √∂nce:
const validation = validateLiveEvent(event);
if (!validation.valid) {
  console.error('Invalid LiveEvent:', validation.error);
  return; // Drop invalid event
}
```

### CopilotDock ‚Üí Hook Kullanƒ±mƒ±

**Dosya:** `apps/web-next/src/components/copilot/CopilotDock.tsx`

**Deƒüi≈üiklik:** Raw SSE parsing kaldƒ±r, sadece hook kullan:

```typescript
// √ñnce:
fetch('/api/copilot/chat', ...).then(async (response) => {
  const reader = response.body?.getReader();
  // ... SSE parsing
});

// Sonra:
import { useCopilotStream } from '@spark/live-react';

const copilotStream = useCopilotStream();
const messages = copilotStream.messages; // Store'dan okur
const status = copilotStream.status;      // connected | reconnecting | degraded
const staleness = copilotStream.staleness; // ok | warn | stale
```

---

## 8. StatusBar Integration

**Dosya:** `apps/web-next/src/components/StatusBar.tsx`

**Eklemeler:**
```typescript
import { useCopilotStream } from '@spark/live-react';

const copilotStream = useCopilotStream();

// StatusBar'da:
<div>
  <span>WS: {copilotStream.status}</span>
  <span>Copilot: {copilotStream.status === 'connected' ? 'active' : 'idle'}</span>
  {copilotStream.staleness && (
    <span>Staleness: {copilotStream.staleness.status} ({copilotStream.staleness.seconds.toFixed(1)}s)</span>
  )}
</div>
```

---

## 9. G√ºvenlik (P1.2 Kritik)

**Dosya:** `apps/web-next/src/app/api/live/auth/channelAllowlist.ts`

```typescript
/**
 * Channel allowlist + auth (kullanƒ±cƒ±/rol bazlƒ±)
 */
export interface ChannelPermission {
  pattern: string;        // 'binance:*' | 'executor:*' | 'copilot:chat'
  roles: string[];         // ['readonly', 'analyst', ...] | ['operator', 'admin']
  authenticated: boolean;  // true = requires auth
}

export const CHANNEL_PERMISSIONS: ChannelPermission[] = [
  { pattern: 'binance:*', roles: [], authenticated: false }, // Herkes
  { pattern: 'executor:*', roles: ['operator', 'admin'], authenticated: true },
  { pattern: 'copilot:chat', roles: [], authenticated: true }, // Authenticated users
];

export function canSubscribe(userRole: string, isAuthenticated: boolean, channel: string): boolean {
  for (const perm of CHANNEL_PERMISSIONS) {
    if (matchesPattern(channel, perm.pattern)) {
      if (perm.authenticated && !isAuthenticated) return false;
      if (perm.roles.length > 0 && !perm.roles.includes(userRole)) return false;
      return true;
    }
  }
  return false; // Default deny
}

function matchesPattern(channel: string, pattern: string): boolean {
  // Simple wildcard matching (binance:* matches binance:BTCUSDT:1m)
  const regex = new RegExp('^' + pattern.replace(/\*/g, '.*') + '$');
  return regex.test(channel);
}
```

**Dosya:** `apps/web-next/src/app/api/live/auth/rateLimit.ts`

```typescript
/**
 * Rate limit / max channel count / max msg size
 */
export interface RateLimitConfig {
  maxChannels: number;    // 10
  maxMsgSize: number;     // 32KB
  maxSubscribesPerMinute: number; // 20
}

export const RATE_LIMIT_CONFIG: RateLimitConfig = {
  maxChannels: 10,
  maxMsgSize: 32 * 1024,
  maxSubscribesPerMinute: 20,
};

export function checkRateLimit(
  channelCount: number,
  msgSize: number,
  subscribeCount: number
): { allowed: boolean; reason?: string } {
  if (channelCount > RATE_LIMIT_CONFIG.maxChannels) {
    return { allowed: false, reason: 'Max channel count exceeded' };
  }
  if (msgSize > RATE_LIMIT_CONFIG.maxMsgSize) {
    return { allowed: false, reason: 'Max message size exceeded' };
  }
  if (subscribeCount > RATE_LIMIT_CONFIG.maxSubscribesPerMinute) {
    return { allowed: false, reason: 'Max subscribes per minute exceeded' };
  }
  return { allowed: true };
}
```

---

## 10. Smoke Test G√ºncellemesi

**Dosya:** `tools/copilot-smoke-test.ps1`

**Eklemeler:**

```powershell
# Test 15: UI parsing yok (yasak)
Write-Host "[15/16] UI Raw Parsing Kontrol√º (Yasak)..." -ForegroundColor Yellow
$uiFiles = Get-ChildItem -Path "apps/web-next/src/components" -Recurse -Filter "*.tsx" | Select-String -Pattern "fetch.*SSE|EventSource|WebSocket" -CaseSensitive:$false
if ($uiFiles) {
    Write-Host "  ‚ùå FAIL: UI'da raw SSE/WS parsing bulundu:" -ForegroundColor Red
    $uiFiles | ForEach-Object { Write-Host "    $($_.Path):$($_.LineNumber)" -ForegroundColor Red }
} else {
    Write-Host "  ‚úÖ PASS: UI'da raw SSE/WS parsing yok (sadece hooks kullanƒ±lƒ±yor)" -ForegroundColor Green
}

# Test 16: Backpressure drop event
Write-Host "[16/16] Backpressure Drop Event Testi..." -ForegroundColor Yellow
Write-Host "  ‚ö†Ô∏è  SKIP: Sentetik flood testi gerekiyor (manuel test √∂nerilir)" -ForegroundColor Yellow
Write-Host "  üìù Manuel test:" -ForegroundColor Yellow
Write-Host "     1. CopilotDock a√ß" -ForegroundColor Gray
Write-Host "     2. Y√ºksek frekanslƒ± event flood (sentetik)" -ForegroundColor Gray
Write-Host "     3. backpressure_drop event beklenir" -ForegroundColor Gray
Write-Host "     4. StatusBar'da amber uyarƒ± g√∂r√ºn√ºr" -ForegroundColor Gray
```

---

## 11. Interface √ñzeti

### LiveClient Interface

```typescript
class LiveClient {
  connect(): void;
  disconnect(): void;
  getStatus(): LiveClientStatus;
}
```

### Store Shape

```typescript
interface LiveStoreState {
  copilotMessages: Array<{ id: string; content: string; timestamp: Date }>;
  copilotStatus: LiveClientStatus;
  copilotStaleness: { status: 'ok' | 'warn' | 'stale'; seconds: number } | null;
  backpressureDrops: number;
}
```

### Hook ƒ∞mzasƒ±

```typescript
function useCopilotStream(): {
  messages: Array<{ id: string; content: string; timestamp: Date }>;
  status: LiveClientStatus;
  staleness: { status: 'ok' | 'warn' | 'stale'; seconds: number } | null;
  backpressureDrops: number;
}
```

---

## 12. Dosya Listesi (Minimum Patch)

### Yeni Dosyalar

**Core (React yok):**
- `packages/live-core/package.json`
- `packages/live-core/tsconfig.json`
- `packages/live-core/src/envelope/LiveEvent.ts`
- `packages/live-core/src/envelope/versioning.ts`
- `packages/live-core/src/staleness/policies.ts`
- `packages/live-core/src/staleness/computeStaleness.ts`
- `packages/live-core/src/backpressure/QueueManager.ts`
- `packages/live-core/src/client/types.ts`
- `packages/live-core/src/client/LiveClient.ts`
- `packages/live-core/src/client/DegradeMode.ts`
- `packages/live-core/src/index.ts`

**React:**
- `packages/live-react/package.json`
- `packages/live-react/tsconfig.json`
- `packages/live-react/src/store/liveStore.ts`
- `packages/live-react/src/hooks/useCopilotStream.ts`
- `packages/live-react/src/index.ts`

**Backend:**
- `apps/web-next/src/app/api/live/auth/channelAllowlist.ts`
- `apps/web-next/src/app/api/live/auth/rateLimit.ts`

### Deƒüi≈ütirilecek Dosyalar

- `apps/web-next/src/app/api/copilot/chat/route.ts` ‚Üí envelope format
- `apps/web-next/src/components/copilot/CopilotDock.tsx` ‚Üí hook kullanƒ±mƒ±
- `apps/web-next/src/components/StatusBar.tsx` ‚Üí Live status indicators
- `tools/copilot-smoke-test.ps1` ‚Üí yeni testler

---

## 13. P1.2 "Done" Kriteri (Tekrar)

1. ‚úÖ LiveClient + store + hooks √ßalƒ±≈üƒ±yor (en az Copilot stream)
2. ‚úÖ UI'da hi√ßbir yerde "raw SSE/WS parsing" kalmƒ±yor (yasak)
3. ‚úÖ StatusBar canlƒ±lƒ±k g√∂steriyor: WS / Copilot / Staleness
4. ‚úÖ Degrade mode √ßalƒ±≈üƒ±yor: baƒülantƒ± gidince UI "son bilinen deƒüer + amber"
5. ‚úÖ Smoke test'e 2 kontrol ekli: "UI parsing yok" + "backpressure_drop event"

---

## Sonu√ß

Bu minimum patch ile:
- Copilot Live Layer'a ta≈üƒ±nƒ±r
- UI refactor safe (raw parsing yok)
- Omurga hazƒ±r (Market WS i√ßin zemin var)
- P1.2 "Done" kriterleri kar≈üƒ±lanƒ±r

