# v1.3 Guardrails + Optimization

## Hedef
Aynı SLO ile daha düşük jitter/CPU; daha güvenli hata modları.

## Network Optimizasyonu

### HTTP Keep-Alive + Connection Reuse
```typescript
import http from "http";
import https from "https";
import axios from "axios";

const httpAgent = new http.Agent({ 
  keepAlive: true, 
  maxSockets: 50,
  timeout: 10000
});

const httpsAgent = new https.Agent({ 
  keepAlive: true, 
  maxSockets: 50,
  timeout: 10000
});

export const client = axios.create({ 
  httpAgent, 
  httpsAgent, 
  timeout: 10_000, 
  decompress: true 
});
```

### DNS Optimizasyonu
```typescript
// DNS ipv4first
const dns = require('dns');
dns.setDefaultResultOrder('ipv4first');
```

### Exponential Backoff + Jitter
```typescript
function exponentialBackoff(attempt: number, baseDelay = 1000): number {
  const delay = baseDelay * Math.pow(2, attempt);
  const jitter = Math.random() * 0.1 * delay;
  return delay + jitter;
}
```

## Circuit Breaker + Bulkhead

### Opossum Circuit Breaker
```typescript
import CircuitBreaker from 'opossum';

const options = {
  timeout: 3000,
  errorThresholdPercentage: 50,
  resetTimeout: 30000
};

const breaker = new CircuitBreaker(btcturkRequest, options);

breaker.on('open', () => {
  console.log('Circuit breaker opened');
});

breaker.on('halfOpen', () => {
  console.log('Circuit breaker half-open');
});

breaker.on('close', () => {
  console.log('Circuit breaker closed');
});
```

### Symbol Başına Kuyruk (Bulkhead)
```typescript
class SymbolQueue {
  private queues = new Map<string, Queue>();
  
  async processOrder(symbol: string, order: Order) {
    if (!this.queues.has(symbol)) {
      this.queues.set(symbol, new Queue({ concurrency: 1 }));
    }
    
    return this.queues.get(symbol)!.add(() => 
      this.executeOrder(order)
    );
  }
}
```

## Precision/Commission Cache

### ExchangeInfo Pull-on-Boot + TTL/Refresh
```typescript
class ExchangeInfoCache {
  private cache = new Map<string, SymbolInfo>();
  private lastUpdate = 0;
  private ttl = 3600000; // 1 hour

  async getSymbolInfo(symbol: string): Promise<SymbolInfo> {
    if (Date.now() - this.lastUpdate > this.ttl) {
      await this.refreshCache();
    }
    
    return this.cache.get(symbol) || this.fetchFromAPI(symbol);
  }

  private async refreshCache() {
    const info = await this.fetchExchangeInfo();
    this.cache.clear();
    info.symbols.forEach(s => this.cache.set(s.symbol, s));
    this.lastUpdate = Date.now();
  }
}
```

## UI Optimizasyonları

### P50/P95/P99 Toggle
```typescript
interface LatencyToggle {
  p50: number;
  p95: number;
  p99: number;
}

function LatencyCard({ data }: { data: LatencyToggle }) {
  const [selectedPercentile, setSelectedPercentile] = useState<'p50' | 'p95' | 'p99'>('p95');
  
  return (
    <div>
      <div className="flex space-x-2">
        {(['p50', 'p95', 'p99'] as const).map(p => (
          <button
            key={p}
            onClick={() => setSelectedPercentile(p)}
            className={selectedPercentile === p ? 'bg-blue-500' : 'bg-gray-200'}
          >
            {p.toUpperCase()}
          </button>
        ))}
      </div>
      <div className="text-2xl font-bold">
        {data[selectedPercentile]}ms
      </div>
    </div>
  );
}
```

### Burn-Rate Görselleştirme
```typescript
function BurnRateChart({ data }: { data: BurnRateData[] }) {
  return (
    <div className="space-y-2">
      <h3>Error Budget Burn Rate</h3>
      <div className="h-32 bg-gray-100 rounded">
        {/* Chart implementation */}
      </div>
      <div className="text-sm text-gray-600">
        Current burn rate: {data[0]?.rate || 0}% per hour
      </div>
    </div>
  );
}
```

### Exemplar ile Trace-ID
```typescript
interface ExemplarData {
  traceId: string;
  spanId: string;
  timestamp: number;
  value: number;
}

function ExemplarTable({ exemplars }: { exemplars: ExemplarData[] }) {
  return (
    <table>
      <thead>
        <tr>
          <th>Trace ID</th>
          <th>Span ID</th>
          <th>Timestamp</th>
          <th>Value</th>
        </tr>
      </thead>
      <tbody>
        {exemplars.map((ex, i) => (
          <tr key={i}>
            <td className="font-mono text-xs">{ex.traceId}</td>
            <td className="font-mono text-xs">{ex.spanId}</td>
            <td>{new Date(ex.timestamp).toISOString()}</td>
            <td>{ex.value}ms</td>
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

## Executor Heap Profil

### 60 Dakika Soak Test
```typescript
import { performance } from 'perf_hooks';
import { writeFileSync } from 'fs';

class HeapProfiler {
  private startTime = Date.now();
  private samples: any[] = [];
  
  start() {
    setInterval(() => {
      const memUsage = process.memoryUsage();
      this.samples.push({
        timestamp: Date.now(),
        rss: memUsage.rss,
        heapTotal: memUsage.heapTotal,
        heapUsed: memUsage.heapUsed,
        external: memUsage.external
      });
    }, 10000); // 10s intervals
  }
  
  generateReport() {
    const report = {
      duration: Date.now() - this.startTime,
      samples: this.samples,
      summary: this.calculateSummary()
    };
    
    writeFileSync('heap-profile.json', JSON.stringify(report, null, 2));
  }
  
  private calculateSummary() {
    const heapUsed = this.samples.map(s => s.heapUsed);
    return {
      min: Math.min(...heapUsed),
      max: Math.max(...heapUsed),
      avg: heapUsed.reduce((a, b) => a + b, 0) / heapUsed.length,
      trend: this.calculateTrend(heapUsed)
    };
  }
}
```

### Prom-Client Re-use
```typescript
import { register, collectDefaultMetrics } from 'prom-client';

// Singleton pattern for prom-client
class MetricsRegistry {
  private static instance: MetricsRegistry;
  private registry = register;
  
  static getInstance(): MetricsRegistry {
    if (!MetricsRegistry.instance) {
      MetricsRegistry.instance = new MetricsRegistry();
    }
    return MetricsRegistry.instance;
  }
  
  constructor() {
    collectDefaultMetrics({ register: this.registry });
  }
  
  getRegistry() {
    return this.registry;
  }
}
```

## BIST Takvim Otomasyonu

### Yarım Gün/Tatil Sync
```typescript
import { DateTime } from 'luxon';

class BISTCalendar {
  private holidays = new Set<string>();
  private halfDays = new Set<string>();
  
  async syncCalendar() {
    // BIST resmi takviminden çek
    const response = await fetch('https://api.bist.com.tr/calendar');
    const calendar = await response.json();
    
    calendar.holidays.forEach((date: string) => {
      this.holidays.add(date);
    });
    
    calendar.halfDays.forEach((date: string) => {
      this.halfDays.add(date);
    });
  }
  
  isHoliday(date: DateTime): boolean {
    return this.holidays.has(date.toISODate()!);
  }
  
  isHalfDay(date: DateTime): boolean {
    return this.halfDays.has(date.toISODate()!);
  }
  
  getSessionHours(date: DateTime): { start: string; end: string } {
    if (this.isHoliday(date)) {
      return { start: '00:00', end: '00:00' }; // Kapalı
    }
    
    if (this.isHalfDay(date)) {
      return { start: '09:30', end: '12:50' }; // Yarım gün
    }
    
    return { start: '09:30', end: '18:00' }; // Normal gün
  }
}
```

### Read-Only Freeze Saatleri
```typescript
class ReadOnlyFreeze {
  private freezeHours = [
    { start: '18:00', end: '09:30' }, // Gece
    { start: '12:00', end: '13:00' }  // Öğle arası
  ];
  
  isFreezeTime(date: DateTime): boolean {
    const time = date.toFormat('HH:mm');
    
    return this.freezeHours.some(period => 
      time >= period.start && time <= period.end
    );
  }
  
  getFreezeReason(date: DateTime): string {
    if (this.isFreezeTime(date)) {
      return 'Read-only freeze period';
    }
    return '';
  }
}
```

## DoD (Definition of Done)

### Performans Kriterleri
- [ ] P95 aynı kalır veya iyileşir
- [ ] 429 ve INVALID_NONCE alarm frekansı %50 azalır
- [ ] CPU/heap stabil (60 dk soak test)
- [ ] Memory leak yok (heap profiler)
- [ ] Connection reuse aktif

### Güvenlik Kriterleri
- [ ] Circuit breaker test edildi
- [ ] Bulkhead isolation çalışıyor
- [ ] Error handling iyileştirildi
- [ ] Rate limiting optimize edildi

### Monitoring Kriterleri
- [ ] P50/P95/P99 toggle UI'da
- [ ] Burn-rate görselleştirme aktif
- [ ] Exemplar trace-id entegrasyonu
- [ ] Heap profiler raporu hazır

### Operasyonel Kriterleri
- [ ] BIST takvim otomasyonu aktif
- [ ] Read-only freeze saatleri çalışıyor
- [ ] Cache TTL/refresh mekanizması
- [ ] DNS ipv4first optimize

## Test Senaryoları

### Network Optimizasyon Testi
1. Connection reuse testi (100 request)
2. Keep-alive testi (sürekli bağlantı)
3. DNS resolution testi (ipv4first)

### Circuit Breaker Testi
1. Error threshold testi
2. Half-open state testi
3. Recovery testi

### Heap Profil Testi
1. 60 dk soak test
2. Memory leak kontrolü
3. GC pressure analizi

### Cache Testi
1. TTL expiration testi
2. Refresh mekanizması testi
3. Cache hit/miss oranı

## Rollout Planı

### Phase 1: Network Optimizasyon
- HTTP keep-alive
- DNS ipv4first
- Connection reuse

### Phase 2: Circuit Breaker
- Opossum entegrasyonu
- Bulkhead isolation
- Error handling

### Phase 3: Cache & UI
- ExchangeInfo cache
- P50/P95/P99 toggle
- Burn-rate visualization

### Phase 4: Monitoring
- Heap profiler
- Exemplar trace-id
- BIST takvim otomasyonu

## Success Metrics

### Performans
- P95 latency: ≤ 1000ms (mevcut)
- CPU usage: %20 azalma
- Memory usage: %15 azalma
- Connection count: %50 azalma

### Güvenilirlik
- Error rate: %50 azalma
- Circuit breaker trips: < 5/gün
- Cache hit rate: > 90%
- Uptime: 99.9%

### Operasyonel
- Alert frequency: %50 azalma
- Manual intervention: %30 azalma
- Response time: %25 iyileşme
- Resource utilization: %20 iyileşme
