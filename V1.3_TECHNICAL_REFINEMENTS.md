# v1.3 Technical Refinements - İnce Ayar Paketi
**Spark Trading Platform - Production Hardening**

**Version:** v1.3-refinements  
**Date:** 2025-01-16  
**Status:** 🔧 IMPLEMENTATION GUIDE  
**Owner:** Platform Engineering

---

## 🎯 Executive Summary

v1.3 Guardrails sprint'ine geçmeden önce, v1.2'nin sağlam temelini **"kibarca başarısız olan makine"** seviyesine çıkaran kritik ince ayarlar. Bu dokümant, yanlış-pozitif alarmları azaltan, incident izlemeyi kolaylaştıran ve üretim ortamında güvenli operasyonu garanti eden teknik detayları içerir.

---

## 1️⃣ SLO & Monitoring İnce Ayarları

### 1.1 Kayan Pencere + Minimum Örnekleme (P95 Stabilite)

**Problem:** Sabit 5 dakikalık pencerede az örnekle P95 hesaplamak yanlış-pozitif alarmlar üretir.

**Çözüm:** Kayan pencere + minimum örnekleme eşiği

```typescript
// apps/web-next/src/lib/slo-metrics.ts (enhanced)

interface SLOWindowConfig {
  windowSizeMs: number;      // 5 dakika = 300000
  minSamples: number;        // En az 50 örnek
  slidingIntervalMs: number; // Her 30s güncelle
}

class SlidingWindowP95 {
  private samples: Array<{ value: number; timestamp: number }> = [];
  private config: SLOWindowConfig;

  constructor(config: SLOWindowConfig) {
    this.config = config;
  }

  addSample(value: number) {
    const now = Date.now();
    this.samples.push({ value, timestamp: now });
    
    // Eski örnekleri temizle
    const cutoff = now - this.config.windowSizeMs;
    this.samples = this.samples.filter(s => s.timestamp > cutoff);
  }

  calculateP95(): { value: number | null; confidence: 'high' | 'medium' | 'low' } {
    // Minimum örnekleme kontrolü
    if (this.samples.length < this.config.minSamples) {
      return { 
        value: null, 
        confidence: 'low' 
      };
    }

    const sorted = this.samples.map(s => s.value).sort((a, b) => a - b);
    const p95Index = Math.floor(sorted.length * 0.95);
    const value = sorted[p95Index];

    // Confidence göstergesi
    const confidence = this.samples.length >= 100 ? 'high' :
                      this.samples.length >= 50 ? 'medium' : 'low';

    return { value, confidence };
  }
}

// Global instance
export const latencyP95Tracker = new SlidingWindowP95({
  windowSizeMs: 5 * 60 * 1000,  // 5 dakika
  minSamples: 50,
  slidingIntervalMs: 30 * 1000, // 30s sliding
});
```

**Implementation:**
- [ ] `apps/web-next/src/lib/slo-metrics.ts` oluştur
- [ ] `/api/healthz`'de mevcut P95 hesaplamasını değiştir
- [ ] Prometheus'ta `ui_latency_p95_confidence` metriği ekle
- [ ] Grafana'da confidence göstergesini görselleştir

**Alert Rule Update:**
```yaml
# ops/grafana/provisioning/alerts/spark-ui-alerts.yml
- alert: UILatencyHighWithConfidence
  expr: ui_latency_p95_ms > 120 AND ui_latency_p95_confidence == 1
  for: 2m
  annotations:
    description: "P95 latency >120ms with high confidence (>100 samples)"
```

---

### 1.2 WebSocket Reconnect Fırtınası Önleme

**Problem:** Çoklu WS bağlantıları aynı anda koptuğunda, reconnect fırtınası vendor'u overload eder.

**Çözüm:** Jitter + Global Rate Cap

```typescript
// apps/web-next/src/lib/marketdata/ws-client.ts (enhanced)

class GlobalReconnectRateLimiter {
  private activeReconnects = 0;
  private maxConcurrent = 2;
  private queue: Array<() => void> = [];

  async acquireSlot(): Promise<void> {
    return new Promise((resolve) => {
      if (this.activeReconnects < this.maxConcurrent) {
        this.activeReconnects++;
        resolve();
      } else {
        this.queue.push(resolve);
      }
    });
  }

  releaseSlot() {
    this.activeReconnects--;
    const next = this.queue.shift();
    if (next) {
      this.activeReconnects++;
      next();
    }
  }
}

const globalRateLimiter = new GlobalReconnectRateLimiter();

// BTCTurkWSClient içinde
async reconnect() {
  const baseDelay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
  const jitter = Math.random() * 1000; // 0-1000ms jitter
  const delay = baseDelay + jitter;

  console.log(`[BTCTurk WS] Reconnect attempt ${this.reconnectAttempts + 1} in ${delay}ms`);

  await new Promise(resolve => setTimeout(resolve, delay));
  
  // Global rate limiter
  await globalRateLimiter.acquireSlot();
  
  try {
    await this.connect();
    globalRateLimiter.releaseSlot();
  } catch (err) {
    globalRateLimiter.releaseSlot();
    throw err;
  }
}
```

**Metrics:**
```typescript
// Prometheus counters
ws_reconnect_queued_total: number;   // Kuyrukta bekleyen reconnect'ler
ws_reconnect_concurrent_gauge: number; // Şu anda aktif reconnect sayısı
```

---

### 1.3 SSE Backpressure (Sırt Ağrısı)

**Problem:** Sunucu hızlı mesaj gönderirken istemci yavaşsa, sunucu tarafı kuyruk patlar.

**Çözüm:** Sunucu tarafı kuyruk sınırı + drop-oldest + istemci delta throttle

```typescript
// apps/web-next/src/app/api/market/btcturk/stream/route.ts (enhanced)

interface SSEQueue {
  messages: any[];
  maxSize: number;
  droppedCount: number;
}

const sseQueues = new Map<string, SSEQueue>();

export async function GET(request: NextRequest) {
  const clientId = crypto.randomUUID();
  const queue: SSEQueue = {
    messages: [],
    maxSize: 100, // Max 100 mesaj
    droppedCount: 0,
  };
  sseQueues.set(clientId, queue);

  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    start(controller) {
      const interval = setInterval(() => {
        const queue = sseQueues.get(clientId);
        if (!queue) return;

        // Kuyruktan mesaj çek
        while (queue.messages.length > 0) {
          const msg = queue.messages.shift();
          const sseData = `data: ${JSON.stringify(msg)}\n\n`;
          controller.enqueue(encoder.encode(sseData));
        }

        // Dropped count bilgisi
        if (queue.droppedCount > 0) {
          const warning = `data: ${JSON.stringify({ 
            type: 'warning', 
            dropped: queue.droppedCount 
          })}\n\n`;
          controller.enqueue(encoder.encode(warning));
          queue.droppedCount = 0;
        }
      }, 250); // Her 250ms kontrol

      // Cleanup on disconnect
      request.signal.addEventListener('abort', () => {
        clearInterval(interval);
        sseQueues.delete(clientId);
      });
    }
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}

// WS event handler'dan mesaj gönderimi
function broadcastToSSEClients(data: any) {
  for (const [clientId, queue] of sseQueues.entries()) {
    if (queue.messages.length >= queue.maxSize) {
      // Drop oldest message
      queue.messages.shift();
      queue.droppedCount++;
    }
    queue.messages.push(data);
  }
}
```

**İstemci Tarafı Delta Throttle:**
```typescript
// apps/web-next/src/lib/useSSE.ts (enhanced)

interface DeltaThrottleConfig {
  minChangePercent: number; // Minimum %değişim
  minIntervalMs: number;    // Minimum zaman aralığı
}

const useSSE = <T>(url: string, options?: UseSSEOptions & { deltaThrottle?: DeltaThrottleConfig }) => {
  const [data, setData] = useState<T | null>(null);
  const lastValue = useRef<any>(null);
  const lastUpdateTime = useRef(0);

  // ... (mevcut kod)

  es.onmessage = (event) => {
    const now = Date.now();
    const newData = JSON.parse(event.data);

    // Delta throttle kontrolü
    if (options?.deltaThrottle && lastValue.current) {
      const deltaPercent = Math.abs(
        (newData.price - lastValue.current.price) / lastValue.current.price
      ) * 100;

      const timeDelta = now - lastUpdateTime.current;

      // Eğer değişim çok küçük VE zaman çok kısa ise, update'i atla
      if (
        deltaPercent < options.deltaThrottle.minChangePercent &&
        timeDelta < options.deltaThrottle.minIntervalMs
      ) {
        return; // Skip update
      }
    }

    setData(newData);
    lastValue.current = newData;
    lastUpdateTime.current = now;
  };

  // ...
};
```

**Kullanım:**
```typescript
const { data } = useSSE('/api/market/btcturk/stream', {
  throttleMs: 250,
  deltaThrottle: {
    minChangePercent: 0.1, // %0.1'den az değişim ignore
    minIntervalMs: 500,    // 500ms'den kısa interval ignore
  }
});
```

---

### 1.4 Prometheus Kardinalite Freni

**Problem:** Sembol/session ID gibi yüksek kardinalite label'ları Prometheus'u patlatır.

**Çözüm:** Toplulaştırılmış sayaçlar + kardinalite limiti

```typescript
// apps/web-next/src/app/api/tools/metrics/route.ts (enhanced)

// ❌ YANLIŞ: Yüksek kardinalite
// venue_request_total{venue="btcturk",symbol="BTC_TRY",session="abc123"} 150

// ✅ DOĞRU: Düşük kardinalite + toplulaştırma
const metrics = [
  // Venue bazlı toplam
  "# HELP venue_requests_total Total requests per venue",
  "# TYPE venue_requests_total counter",
  `venue_requests_total{venue="btcturk"} ${btcturkRequestCount}`,
  `venue_requests_total{venue="bist"} ${bistRequestCount}`,
  "",

  // Symbol bazlı (top 10 ile sınırla)
  "# HELP venue_requests_by_symbol_total Top 10 symbols by request count",
  "# TYPE venue_requests_by_symbol_total counter",
  ...getTop10Symbols().map(s => 
    `venue_requests_by_symbol_total{venue="btcturk",symbol="${s.symbol}"} ${s.count}`
  ),
  "",

  // Session ID kullanma, yerine aggregate metric
  "# HELP venue_active_sessions_gauge Currently active sessions",
  "# TYPE venue_active_sessions_gauge gauge",
  `venue_active_sessions_gauge{venue="btcturk"} ${activeSessionsCount}`,
  "",
];

// Kardinalite limiti tracker
interface CardinalityGuard {
  maxLabels: number;
  currentLabels: Set<string>;
}

const cardinalityGuards: Record<string, CardinalityGuard> = {
  'venue_requests_by_symbol_total': {
    maxLabels: 10,
    currentLabels: new Set(),
  }
};

function addMetricWithGuard(metricName: string, labels: Record<string, string>, value: number): string | null {
  const guard = cardinalityGuards[metricName];
  if (!guard) return `${metricName}{${formatLabels(labels)}} ${value}`;

  const labelKey = formatLabels(labels);
  if (guard.currentLabels.size >= guard.maxLabels && !guard.currentLabels.has(labelKey)) {
    // Kardinalite limiti aşıldı, bu metriği ekleme
    console.warn(`Cardinality limit reached for ${metricName}`);
    return null;
  }

  guard.currentLabels.add(labelKey);
  return `${metricName}{${labelKey}} ${value}`;
}
```

---

## 2️⃣ Kill-Switch İyileştirmeleri

### 2.1 Toggle İzlekleri + Cooldown

**Problem:** Flip-flop toggle'ları (REAL→MOCK→REAL→MOCK) sistemde istikrarsızlık yaratır.

**Çözüm:** Evidence ZIP + açıklama zorunluluğu + 15dk cooldown

```typescript
// apps/web-next/src/app/api/tools/kill-switch/toggle/route.ts (enhanced)

interface KillSwitchEvent {
  id: string;
  timestamp: Date;
  action: 'REAL_TO_MOCK' | 'MOCK_TO_REAL';
  triggeredBy: 'user' | 'auto';
  userId?: string;
  reason: string; // Zorunlu
  evidenceZip?: string;
  cooldownUntil: Date;
}

const killSwitchHistory: KillSwitchEvent[] = [];
const COOLDOWN_MS = 15 * 60 * 1000; // 15 dakika

export async function POST(req: NextRequest) {
  if (process.env.NODE_ENV === 'production') {
    return NextResponse.json({ success: false, message: 'Kill switch not allowed in production' }, { status: 403 });
  }

  const body = await req.json();
  const { reason, userId } = body;

  // Reason zorunlu kontrolü
  if (!reason || reason.trim().length < 10) {
    return NextResponse.json({
      success: false,
      message: 'Reason required (min 10 characters)',
    }, { status: 400 });
  }

  // Cooldown kontrolü
  const lastEvent = killSwitchHistory[killSwitchHistory.length - 1];
  if (lastEvent && Date.now() < lastEvent.cooldownUntil.getTime()) {
    const remainingSec = Math.ceil((lastEvent.cooldownUntil.getTime() - Date.now()) / 1000);
    return NextResponse.json({
      success: false,
      message: `Cooldown active. Try again in ${remainingSec}s`,
      cooldownUntil: lastEvent.cooldownUntil,
    }, { status: 429 });
  }

  try {
    // .env.local okuma/yazma
    let envContent = '';
    const ENV_FILE_PATH = path.resolve(process.cwd(), '.env.local');
    
    if (fs.existsSync(ENV_FILE_PATH)) {
      envContent = fs.readFileSync(ENV_FILE_PATH, 'utf-8');
    }

    const currentRealData = envContent.includes('SPARK_REAL_DATA=1');
    const newRealData = !currentRealData;

    // Evidence ZIP oluştur
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const evidenceDir = path.resolve(process.cwd(), `evidence/kill_switch_${timestamp}`);
    fs.mkdirSync(evidenceDir, { recursive: true });

    // Health snapshot
    const healthResponse = await fetch('http://localhost:3003/api/healthz', { cache: 'no-store' });
    const healthData = await healthResponse.json();
    fs.writeFileSync(path.join(evidenceDir, 'healthz.json'), JSON.stringify(healthData, null, 2));

    // Event metadata
    const event: KillSwitchEvent = {
      id: crypto.randomUUID(),
      timestamp: new Date(),
      action: currentRealData ? 'REAL_TO_MOCK' : 'MOCK_TO_REAL',
      triggeredBy: 'user',
      userId,
      reason,
      evidenceZip: `kill_switch_${timestamp}.zip`,
      cooldownUntil: new Date(Date.now() + COOLDOWN_MS),
    };
    
    fs.writeFileSync(
      path.join(evidenceDir, 'event.json'),
      JSON.stringify(event, null, 2)
    );

    killSwitchHistory.push(event);

    // ZIP oluştur
    const zipPath = path.resolve(process.cwd(), `evidence/kill_switch_${timestamp}.zip`);
    execSync(`powershell Compress-Archive -Path "${evidenceDir}\\*" -DestinationPath "${zipPath}"`);

    // .env.local güncelle
    const newEnvContent = envContent
      .split('\n')
      .filter(line => !line.startsWith('SPARK_REAL_DATA='))
      .join('\n');
    
    const updatedEnvContent = `${newEnvContent}\nSPARK_REAL_DATA=${newRealData ? '1' : '0'}\n`;
    fs.writeFileSync(ENV_FILE_PATH, updatedEnvContent);

    console.log(`[Kill Switch] ${event.action} by ${userId || 'unknown'}: ${reason}`);

    return NextResponse.json({
      success: true,
      message: `Data mode switched to ${newRealData ? 'REAL' : 'MOCK'}`,
      newMode: newRealData ? 'REAL' : 'MOCK',
      event,
    });
  } catch (error: any) {
    console.error('Failed to toggle kill switch:', error);
    return NextResponse.json({ 
      success: false, 
      message: 'Failed to toggle kill switch', 
      error: error.message 
    }, { status: 500 });
  }
}

// History endpoint
export async function GET() {
  return NextResponse.json({
    history: killSwitchHistory.slice(-10), // Son 10 event
    currentCooldown: killSwitchHistory.length > 0 
      ? killSwitchHistory[killSwitchHistory.length - 1].cooldownUntil 
      : null,
  });
}
```

**UI Integration:**
```typescript
// Komut Paleti'nde reason prompt ekle
export const toggleKillSwitch: CommandAction = {
  id: "ops.toggle-kill-switch",
  label: "Toggle Kill Switch (REAL↔MOCK)",
  description: "Switch between real and mock data modes",
  icon: "🔄",
  category: "ops",
  handler: async () => {
    const reason = prompt("Reason for kill switch toggle (min 10 chars):");
    if (!reason || reason.length < 10) {
      return {
        success: false,
        message: "Reason required (min 10 characters)",
      };
    }

    const response = await fetch("/api/tools/kill-switch/toggle", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ 
        action: "toggle",
        reason,
        userId: "current-user-id", // Auth'dan çek
      }),
    });

    const result = await response.json();
    return result;
  },
};
```

---

## 3️⃣ Audit & Trace İyileştirmeleri

### 3.1 Log Rotasyonu + Nonce/Trace-ID

**Problem:** Bir incident'i uçtan uca izlemek zor; log'lar correlation ID içermiyor.

**Çözüm:** Her request için trace-ID, tüm log'lara enjeksiyon

```typescript
// apps/web-next/src/middleware.ts (new)

import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { v4 as uuidv4 } from 'uuid';

export function middleware(request: NextRequest) {
  // Trace ID generate (yoksa)
  const traceId = request.headers.get('x-trace-id') || uuidv4();
  
  // Response'a ekle
  const response = NextResponse.next();
  response.headers.set('x-trace-id', traceId);
  
  // Request context'e ekle (global store)
  (globalThis as any).__traceId = traceId;
  
  return response;
}

export const config = {
  matcher: '/api/:path*',
};
```

```typescript
// apps/web-next/src/lib/logger.ts (new)

interface LogEntry {
  timestamp: string;
  traceId: string;
  level: 'info' | 'warn' | 'error';
  message: string;
  metadata?: any;
}

export function log(level: LogEntry['level'], message: string, metadata?: any) {
  const traceId = (globalThis as any).__traceId || 'no-trace';
  
  const entry: LogEntry = {
    timestamp: new Date().toISOString(),
    traceId,
    level,
    message,
    metadata,
  };

  console.log(JSON.stringify(entry));
  
  // Audit log'a yaz (dosya veya DB)
  if (level === 'error' || metadata?.audit) {
    fs.appendFileSync(
      'logs/audit.log',
      JSON.stringify(entry) + '\n'
    );
  }
}
```

**Kullanım:**
```typescript
import { log } from '@/lib/logger';

// API route'ta
log('info', 'BTCTurk ticker fetched', { symbol: 'BTC_TRY', price: 1234567 });

// Hata durumunda
log('error', 'Venue timeout', { venue: 'btcturk', audit: true });
```

**Grep ile trace:**
```bash
# Tüm incident'ı trace et
grep "abc123-trace-id" logs/audit.log
```

---

### 3.2 Clock Skew Monitoring

**Problem:** Staleness kapısı 20s ise, NTP drift 2-3s olduğunda yanlış alarm çıkar.

**Çözüm:** Uygulama açılışında clock-skew ölçümü + alert

```typescript
// apps/web-next/src/lib/clock-skew.ts

interface ClockSkewResult {
  localTime: number;
  serverTime: number;
  skewMs: number;
  status: 'ok' | 'warning' | 'critical';
}

export async function measureClockSkew(): Promise<ClockSkewResult> {
  const localTime = Date.now();
  
  // Public time API'den gerçek zaman çek
  const response = await fetch('http://worldtimeapi.org/api/timezone/Etc/UTC', {
    signal: AbortSignal.timeout(3000),
  });
  
  const data = await response.json();
  const serverTime = new Date(data.datetime).getTime();
  
  const skewMs = Math.abs(serverTime - localTime);
  
  const status = skewMs < 1000 ? 'ok' :
                 skewMs < 3000 ? 'warning' : 'critical';
  
  return { localTime, serverTime, skewMs, status };
}

// Uygulama açılışında çalıştır
export async function initClockSkewMonitoring() {
  try {
    const result = await measureClockSkew();
    
    console.log(`[Clock Skew] Local: ${result.localTime}, Server: ${result.serverTime}, Skew: ${result.skewMs}ms (${result.status})`);
    
    if (result.status === 'critical') {
      console.error(`[Clock Skew] CRITICAL: ${result.skewMs}ms skew detected. Staleness checks may be unreliable.`);
      // Alert gönder
    }
  } catch (err) {
    console.warn('[Clock Skew] Failed to measure clock skew:', err);
  }
}
```

**Integration:**
```typescript
// apps/web-next/src/app/layout.tsx (server component)
import { initClockSkewMonitoring } from '@/lib/clock-skew';

// Server initialization
if (typeof window === 'undefined') {
  initClockSkewMonitoring();
}
```

---

## 4️⃣ BIST Feed "Pusu" Noktaları

### 4.1 Zaman Dilimi + Tatil Takvimi

**Problem:** TRT (UTC+3) seans boşlukları ve resmî tatiller için "zero-volume uyarısı" yanlış alarm verir.

**Çözüm:** Tatil takvimi dosyası + hash ile validation

```typescript
// packages/marketdata-bist/src/trading-calendar.ts

interface TradingDay {
  date: string; // YYYY-MM-DD
  isHoliday: boolean;
  reason?: string;
  sessionStart?: string; // HH:MM
  sessionEnd?: string;   // HH:MM
}

// Statik tatil takvimi (2025)
export const BIST_CALENDAR_2025: TradingDay[] = [
  { date: '2025-01-01', isHoliday: true, reason: 'Yılbaşı' },
  { date: '2025-04-23', isHoliday: true, reason: '23 Nisan Ulusal Egemenlik ve Çocuk Bayramı' },
  { date: '2025-05-01', isHoliday: true, reason: 'İşçi Bayramı' },
  { date: '2025-05-19', isHoliday: true, reason: 'Gençlik ve Spor Bayramı' },
  { date: '2025-07-15', isHoliday: true, reason: 'Demokrasi ve Milli Birlik Günü' },
  { date: '2025-08-30', isHoliday: true, reason: 'Zafer Bayramı' },
  { date: '2025-10-29', isHoliday: true, reason: 'Cumhuriyet Bayramı' },
  // Dini bayramlar (değişken, her yıl güncellenmeli)
  { date: '2025-03-30', isHoliday: true, reason: 'Ramazan Bayramı Arefe' },
  { date: '2025-03-31', isHoliday: true, reason: 'Ramazan Bayramı 1. Gün' },
  { date: '2025-04-01', isHoliday: true, reason: 'Ramazan Bayramı 2. Gün' },
  { date: '2025-04-02', isHoliday: true, reason: 'Ramazan Bayramı 3. Gün' },
  { date: '2025-06-06', isHoliday: true, reason: 'Kurban Bayramı Arefe' },
  { date: '2025-06-07', isHoliday: true, reason: 'Kurban Bayramı 1. Gün' },
  { date: '2025-06-08', isHoliday: true, reason: 'Kurban Bayramı 2. Gün' },
  { date: '2025-06-09', isHoliday: true, reason: 'Kurban Bayramı 3. Gün' },
  { date: '2025-06-10', isHoliday: true, reason: 'Kurban Bayramı 4. Gün' },
];

// Takvim hash (integrity check)
export const CALENDAR_HASH = 'sha256-abc123...'; // npm run generate-calendar-hash

export function isTradingDay(date: Date): boolean {
  const dateStr = date.toISOString().split('T')[0];
  const day = BIST_CALENDAR_2025.find(d => d.date === dateStr);
  
  if (day?.isHoliday) return false;
  
  // Hafta sonu kontrolü
  const dayOfWeek = date.getDay();
  if (dayOfWeek === 0 || dayOfWeek === 6) return false;
  
  return true;
}

export function isTradingHours(date: Date): boolean {
  if (!isTradingDay(date)) return false;
  
  const hours = date.getUTCHours() + 3; // TRT = UTC+3
  const minutes = date.getUTCMinutes();
  
  // BIST seans: 10:00 - 18:00 TRT
  const timeInMin = hours * 60 + minutes;
  const sessionStart = 10 * 60; // 10:00
  const sessionEnd = 18 * 60;   // 18:00
  
  return timeInMin >= sessionStart && timeInMin < sessionEnd;
}
```

**Quality Gate Integration:**
```typescript
// packages/marketdata-bist/src/quality-gates.ts

import { isTradingHours } from './trading-calendar';

const volumeSanityGate: QualityGate = {
  name: 'volume_sanity',
  check: (data: BISTSnapshot) => {
    const now = new Date(data.timestamp);
    
    // Sadece seans içinde zero-volume uyarısı ver
    if (isTradingHours(now) && data.volume === 0) {
      return false;
    }
    
    return true;
  },
  severity: 'warning',
};
```

---

### 4.2 Şema Sürümü + Side-by-Side Canary

**Problem:** Vendor şema sürümü değiştiğinde, parsing hatası tüm sistemi etkiler.

**Çözüm:** Yanıt başlığından şema sürümü oku + bilinmeyen sürümde canary kanalı

```typescript
// packages/marketdata-bist/src/vendor-client.ts

const KNOWN_SCHEMA_VERSIONS = ['v1.0', 'v1.1'];

interface VendorResponse {
  schemaVersion: string;
  data: BISTSnapshot[];
}

export async function fetchBISTData(symbols: string[]): Promise<BISTSnapshot[]> {
  const response = await fetch(`${BIST_VENDOR_URL}/snapshots?symbols=${symbols.join(',')}`, {
    signal: AbortSignal.timeout(3000),
  });

  // Şema sürümü header'dan oku
  const schemaVersion = response.headers.get('x-schema-version') || 'unknown';

  if (!KNOWN_SCHEMA_VERSIONS.includes(schemaVersion)) {
    console.warn(`[BIST] Unknown schema version: ${schemaVersion}. Enabling side-by-side validation.`);
    
    // Canary kanalı aç: hem eski parser hem yeni parser çalıştır
    const canaryResult = await runSideBySideValidation(response, schemaVersion);
    
    if (canaryResult.newParserFailed) {
      // Yeni parser başarısız, eski parser'ı kullan ve alert gönder
      console.error(`[BIST] New parser failed for schema ${schemaVersion}. Falling back to old parser.`);
      return canaryResult.oldParserResult;
    }
    
    // İkisi de başarılı, farkları logla
    if (canaryResult.differences.length > 0) {
      console.warn(`[BIST] Parser differences detected:`, canaryResult.differences);
    }
    
    return canaryResult.newParserResult;
  }

  // Bilinen şema sürümü, normal parsing
  const data: VendorResponse = await response.json();
  return data.data.map(normalizeSnapshot);
}

async function runSideBySideValidation(response: Response, schemaVersion: string) {
  const rawData = await response.text();
  
  let oldParserResult: BISTSnapshot[] = [];
  let newParserResult: BISTSnapshot[] = [];
  let newParserFailed = false;
  const differences: string[] = [];

  // Eski parser
  try {
    oldParserResult = parseWithOldSchema(JSON.parse(rawData));
  } catch (err) {
    console.error('[BIST] Old parser failed:', err);
  }

  // Yeni parser
  try {
    newParserResult = parseWithNewSchema(JSON.parse(rawData), schemaVersion);
  } catch (err) {
    console.error('[BIST] New parser failed:', err);
    newParserFailed = true;
  }

  // Fark kontrolü
  if (!newParserFailed && oldParserResult.length === newParserResult.length) {
    for (let i = 0; i < oldParserResult.length; i++) {
      const old = oldParserResult[i];
      const newData = newParserResult[i];
      
      if (Math.abs(old.price - newData.price) > 0.01) {
        differences.push(`${old.symbol}: price diff (old=${old.price}, new=${newData.price})`);
      }
    }
  }

  return { oldParserResult, newParserResult, newParserFailed, differences };
}
```

---

### 4.3 Fiyat Anomalisi + VWAP Kontrolü

**Problem:** "price_anomaly>10%" uyarıları yüksek volatilite dönemlerinde yanlış alarm verir.

**Çözüm:** Aynı bar içi VWAP + limit-up-down kontrolü

```typescript
// packages/marketdata-bist/src/quality-gates.ts (enhanced)

interface PriceHistory {
  symbol: string;
  prices: Array<{ price: number; volume: number; timestamp: number }>;
}

const priceHistories = new Map<string, PriceHistory>();

const priceAnomalyGate: QualityGate = {
  name: 'price_anomaly',
  check: (data: BISTSnapshot) => {
    let history = priceHistories.get(data.symbol);
    if (!history) {
      history = { symbol: data.symbol, prices: [] };
      priceHistories.set(data.symbol, history);
    }

    // Son 60s içindeki fiyatları tut
    const cutoff = Date.now() - 60000;
    history.prices = history.prices.filter(p => p.timestamp > cutoff);
    history.prices.push({ price: data.price, volume: data.volume, timestamp: data.timestamp });

    if (history.prices.length < 2) return true; // Yeterli veri yok

    // VWAP hesapla
    const totalVolume = history.prices.reduce((sum, p) => sum + p.volume, 0);
    const vwap = history.prices.reduce((sum, p) => sum + (p.price * p.volume), 0) / totalVolume;

    // Mevcut fiyat ile VWAP arasındaki fark
    const vwapDiffPct = Math.abs((data.price - vwap) / vwap) * 100;

    // Limit up/down kontrolü (BIST için %10)
    const openPrice = history.prices[0].price; // İlk fiyat = açılış
    const limitUpDownPct = Math.abs((data.price - openPrice) / openPrice) * 100;

    // Eğer VWAP'tan %10'dan fazla sapma VAR VE limit up/down değilse, anomali
    if (vwapDiffPct > 10 && limitUpDownPct < 9.5) {
      console.warn(`[BIST] Price anomaly: ${data.symbol} price=${data.price}, vwap=${vwap.toFixed(2)}, diff=${vwapDiffPct.toFixed(2)}%`);
      return false; // Anomali tespit edildi
    }

    return true;
  },
  severity: 'warning',
};
```

---

### 4.4 Budget Guard (Maliyet Sürprizi Önleme)

**Problem:** Burst/sustained ihlalleriyle aylık bütçe kontrolsüz artar.

**Çözüm:** Budget remaining metriği + alert eşiği

```typescript
// apps/web-next/src/lib/budget-guard.ts

interface BudgetConfig {
  monthlyBudgetUSD: number;
  costPerRequest: number; // Vendor pricing
  alertThresholdPct: number; // %80'de uyar
}

const budgetConfigs: Record<string, BudgetConfig> = {
  btcturk: {
    monthlyBudgetUSD: 500,
    costPerRequest: 0.001, // $0.001 per request
    alertThresholdPct: 80,
  },
  bist: {
    monthlyBudgetUSD: 1000,
    costPerRequest: 0.002,
    alertThresholdPct: 80,
  },
};

interface BudgetState {
  requestsThisMonth: number;
  costThisMonth: number;
  remainingBudget: number;
  status: 'ok' | 'warning' | 'critical';
}

const budgetStates = new Map<string, BudgetState>();

export function trackBudget(venue: string) {
  const config = budgetConfigs[venue];
  if (!config) return;

  let state = budgetStates.get(venue);
  if (!state) {
    state = {
      requestsThisMonth: 0,
      costThisMonth: 0,
      remainingBudget: config.monthlyBudgetUSD,
      status: 'ok',
    };
    budgetStates.set(venue, state);
  }

  state.requestsThisMonth++;
  state.costThisMonth += config.costPerRequest;
  state.remainingBudget = config.monthlyBudgetUSD - state.costThisMonth;

  const usedPct = (state.costThisMonth / config.monthlyBudgetUSD) * 100;

  if (usedPct >= 100) {
    state.status = 'critical';
    console.error(`[Budget] CRITICAL: ${venue} budget exceeded ($${state.costThisMonth.toFixed(2)}/$${config.monthlyBudgetUSD})`);
  } else if (usedPct >= config.alertThresholdPct) {
    state.status = 'warning';
    console.warn(`[Budget] WARNING: ${venue} budget at ${usedPct.toFixed(1)}% ($${state.costThisMonth.toFixed(2)}/$${config.monthlyBudgetUSD})`);
  }
}

export function getBudgetMetrics(venue: string): BudgetState | null {
  return budgetStates.get(venue) || null;
}

// Prometheus export
export function getBudgetPrometheusMetrics(): string[] {
  const metrics: string[] = [
    "# HELP venue_budget_remaining_usd Remaining budget for venue this month",
    "# TYPE venue_budget_remaining_usd gauge",
  ];

  for (const [venue, state] of budgetStates.entries()) {
    metrics.push(`venue_budget_remaining_usd{venue="${venue}"} ${state.remainingBudget.toFixed(2)}`);
  }

  metrics.push("");
  metrics.push("# HELP venue_budget_used_pct Percentage of monthly budget used");
  metrics.push("# TYPE venue_budget_used_pct gauge");

  for (const [venue, state] of budgetStates.entries()) {
    const config = budgetConfigs[venue];
    const usedPct = (state.costThisMonth / config.monthlyBudgetUSD) * 100;
    metrics.push(`venue_budget_used_pct{venue="${venue}"} ${usedPct.toFixed(2)}`);
  }

  return metrics;
}

// Aylık reset (cron job veya manual)
export function resetMonthlyBudget() {
  budgetStates.clear();
  console.log('[Budget] Monthly budget counters reset');
}
```

**Integration:**
```typescript
// Rate limiter'da trackBudget çağır
export function consumeToken(venue: string): boolean {
  // ... (mevcut kod)
  
  if (success) {
    trackBudget(venue); // Budget tracking
  }
  
  return success;
}
```

---

## 5️⃣ Onay Akışı (Epic 1) - Risk Skoru İskeleti

### 5.1 Risk Skoru Algoritması (0-100)

```typescript
// apps/web-next/src/lib/strategy-diff.ts

interface RiskScoringWeights {
  leverageIncrease: number;      // +40
  positionSizeIncrease: number;  // +25
  newSymbol: number;             // +15
  stopLossWidening: number;      // +10
  tradingWindowChange: number;   // +10
  tighterRiskControls: number;   // -10
}

const DEFAULT_WEIGHTS: RiskScoringWeights = {
  leverageIncrease: 40,
  positionSizeIncrease: 25,
  newSymbol: 15,
  stopLossWidening: 10,
  tradingWindowChange: 10,
  tighterRiskControls: -10,
};

export function calculateRiskScore(
  current: Strategy,
  incoming: Strategy,
  weights: RiskScoringWeights = DEFAULT_WEIGHTS
): { score: number; breakdown: Record<string, number> } {
  let score = 0;
  const breakdown: Record<string, number> = {};

  // 1. Kaldıraç artışı (logaritmik ölçek)
  if (incoming.leverage > current.leverage) {
    const leverageRatio = incoming.leverage / current.leverage;
    const leverageScore = Math.min(weights.leverageIncrease * Math.log10(leverageRatio + 1), weights.leverageIncrease);
    score += leverageScore;
    breakdown['Leverage Increase'] = leverageScore;
  }

  // 2. Pozisyon boyutu artışı (logaritmik ölçek)
  if (incoming.positionSize > current.positionSize) {
    const positionRatio = incoming.positionSize / current.positionSize;
    const positionScore = Math.min(weights.positionSizeIncrease * Math.log10(positionRatio + 1), weights.positionSizeIncrease);
    score += positionScore;
    breakdown['Position Size Increase'] = positionScore;
  }

  // 3. Yeni sembol (likidite düşükse +)
  if (incoming.symbol !== current.symbol) {
    const symbolLiquidity = getSymbolLiquidity(incoming.symbol);
    const symbolScore = symbolLiquidity === 'low' ? weights.newSymbol * 1.5 : weights.newSymbol;
    score += symbolScore;
    breakdown['New Symbol'] = symbolScore;
  }

  // 4. Stop-loss genişlemesi
  if (incoming.stopLossPct > current.stopLossPct) {
    const stopLossScore = weights.stopLossWidening * (incoming.stopLossPct / current.stopLossPct);
    score += stopLossScore;
    breakdown['Stop-Loss Widening'] = stopLossScore;
  }

  // 5. Çalışma penceresi değişimi (gece/likidite düşük)
  if (incoming.tradingWindow !== current.tradingWindow) {
    const isLowLiquidityWindow = ['night', 'weekend'].includes(incoming.tradingWindow);
    const windowScore = isLowLiquidityWindow ? weights.tradingWindowChange * 1.5 : weights.tradingWindowChange;
    score += windowScore;
    breakdown['Trading Window Change'] = windowScore;
  }

  // 6. Daha sıkı risk kontrolleri (-10)
  if (incoming.maxDrawdownPct < current.maxDrawdownPct || incoming.stopLossPct < current.stopLossPct) {
    score += weights.tighterRiskControls;
    breakdown['Tighter Risk Controls'] = weights.tighterRiskControls;
  }

  return { score: Math.max(0, Math.min(100, score)), breakdown };
}

// Sembol likidite lookup (örnek)
function getSymbolLiquidity(symbol: string): 'high' | 'medium' | 'low' {
  const highLiquidity = ['BTC_TRY', 'ETH_TRY', 'USDT_TRY', 'THYAO', 'AKBNK'];
  const mediumLiquidity = ['XRP_TRY', 'GARAN', 'ISCTR'];
  
  if (highLiquidity.includes(symbol)) return 'high';
  if (mediumLiquidity.includes(symbol)) return 'medium';
  return 'low';
}

// Auto-blocker rules
export function checkAutoBlockers(incoming: Strategy): string[] {
  const blockers: string[] = [];

  if (incoming.leverage > 10) {
    blockers.push('Leverage >10x is not allowed');
  }

  const knownSymbols = ['BTC_TRY', 'ETH_TRY', 'XRP_TRY', 'USDT_TRY', 'THYAO', 'AKBNK', 'GARAN', 'ISCTR', 'SAHOL'];
  if (!knownSymbols.includes(incoming.symbol)) {
    blockers.push(`Unknown symbol: ${incoming.symbol}`);
  }

  const riskScore = calculateRiskScore({} as Strategy, incoming);
  if (riskScore.score > 80) {
    blockers.push('Risk score >80 requires justification');
  }

  return blockers;
}
```

### 5.2 UI Semantic Highlights

```typescript
// apps/web-next/src/components/approval/StrategyDiffViewer.tsx

interface DiffField {
  field: string;
  oldValue: any;
  newValue: any;
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
}

export function StrategyDiffViewer({ diff }: { diff: StrategyDiff }) {
  const getRiskBadge = (level: string) => {
    const badges = {
      low: '🟢 Low',
      medium: '🟡 Medium',
      high: '🟠 High',
      critical: '🔴 Critical',
    };
    return badges[level as keyof typeof badges] || '';
  };

  const getRiskColor = (level: string) => {
    const colors = {
      low: 'text-green-400',
      medium: 'text-amber-400',
      high: 'text-orange-400',
      critical: 'text-red-400',
    };
    return colors[level as keyof typeof colors] || 'text-neutral-400';
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold">Strategy Changes</h3>
        <div className="flex items-center gap-2">
          <span className="text-sm text-neutral-400">Risk Score:</span>
          <span className={`text-xl font-bold ${diff.riskScore > 80 ? 'text-red-400' : diff.riskScore > 50 ? 'text-amber-400' : 'text-green-400'}`}>
            {diff.riskScore}/100
          </span>
        </div>
      </div>

      <div className="space-y-2">
        {diff.modified.map((change, idx) => (
          <div 
            key={idx} 
            className={`p-3 rounded-md border ${
              change.riskLevel === 'critical' ? 'border-red-800 bg-red-950/30' :
              change.riskLevel === 'high' ? 'border-orange-800 bg-orange-950/30' :
              change.riskLevel === 'medium' ? 'border-amber-800 bg-amber-950/30' :
              'border-green-800 bg-green-950/30'
            }`}
          >
            <div className="flex items-start justify-between">
              <div className="flex-1">
                <div className="flex items-center gap-2">
                  <span className="font-mono text-sm font-semibold">{change.field}</span>
                  <span className="text-xs">{getRiskBadge(change.riskLevel)}</span>
                </div>
                <div className="mt-1 flex items-center gap-2 text-sm">
                  <span className="text-neutral-500">{change.oldValue}</span>
                  <span className="text-neutral-600">→</span>
                  <span className={getRiskColor(change.riskLevel)}>{change.newValue}</span>
                </div>
              </div>
            </div>
          </div>
        ))}
      </div>

      {diff.blockers.length > 0 && (
        <div className="mt-4 p-3 rounded-md border border-red-800 bg-red-950/30">
          <h4 className="text-sm font-semibold text-red-400 mb-2">🔒 Auto-Blockers</h4>
          <ul className="space-y-1">
            {diff.blockers.map((blocker, idx) => (
              <li key={idx} className="text-sm text-red-300">• {blocker}</li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}
```

---

## 6️⃣ "Week 0" Hızlı Kazanımlar

### 6.1 Synthetic Check (Dış İzleme)

```bash
# scripts/external-health-check.sh (harici makineden çalıştır)

#!/bin/bash

SPARK_URL="http://your-server-ip:3003"
LOG_FILE="external_health_$(date +%Y%m%d_%H%M%S).log"

echo "=== External Health Check ===" | tee $LOG_FILE
echo "Target: $SPARK_URL" | tee -a $LOG_FILE
echo "" | tee -a $LOG_FILE

# 10 ardışık health check
for i in {1..10}; do
  START=$(date +%s%3N)
  RESPONSE=$(curl -s -w "\n%{http_code}\n%{time_total}" $SPARK_URL/api/healthz)
  END=$(date +%s%3N)
  
  HTTP_CODE=$(echo "$RESPONSE" | tail -2 | head -1)
  TIME_TOTAL=$(echo "$RESPONSE" | tail -1)
  BODY=$(echo "$RESPONSE" | head -n -2)
  
  LATENCY=$((END - START))
  
  echo "[$i] HTTP $HTTP_CODE | Latency: ${LATENCY}ms | curl_time: ${TIME_TOTAL}s" | tee -a $LOG_FILE
  
  if [ "$HTTP_CODE" != "200" ]; then
    echo "  ERROR: Non-200 response" | tee -a $LOG_FILE
  fi
  
  sleep 1
done

echo "" | tee -a $LOG_FILE
echo "External health check complete. Log: $LOG_FILE" | tee -a $LOG_FILE
```

**Cron Job (her 5 dakikada):**
```bash
*/5 * * * * /path/to/scripts/external-health-check.sh
```

---

### 6.2 Incident Makrosu (Komut Paleti)

```typescript
// apps/web-next/src/lib/command-palette.ts (enhanced)

export const createIncidentZip: CommandAction = {
  id: "ops.create-incident-zip",
  label: "Create Incident ZIP (+Slack)",
  description: "Generate evidence ZIP and send Slack notification",
  icon: "🚨",
  category: "ops",
  handler: async () => {
    const reason = prompt("Incident reason:");
    if (!reason) return { success: false, message: "Reason required" };

    try {
      // Evidence ZIP oluştur
      const response = await fetch("/api/tools/incident/create", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ reason }),
      });

      const result = await response.json();

      // Slack notification (webhook)
      await fetch(process.env.NEXT_PUBLIC_SLACK_WEBHOOK_URL!, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          text: `🚨 Incident: ${reason}`,
          attachments: [
            {
              color: "danger",
              fields: [
                { title: "Evidence ZIP", value: result.zipPath, short: false },
                { title: "Timestamp", value: new Date().toISOString(), short: true },
                { title: "Triggered By", value: "user", short: true },
              ],
            },
          ],
        }),
      });

      return {
        success: true,
        message: `Incident ZIP created: ${result.zipPath}`,
        details: result,
      };
    } catch (err) {
      return {
        success: false,
        message: `Incident creation failed: ${err}`,
      };
    }
  },
};
```

---

### 6.3 Trend-Aware CI Gate

```typescript
// apps/web-next/src/app/api/tools/status/route.ts (enhanced)

interface TrendData {
  last7Days: number[]; // Son 7 günün P95 değerleri
  mean: number;
  stdDev: number;
}

async function getTrend(): Promise<TrendData> {
  // Prometheus'tan son 7 günün P95'ini çek
  // Gerçek implementasyonda Prometheus API kullan
  return {
    last7Days: [45, 48, 52, 50, 47, 49, 51], // örnek
    mean: 49,
    stdDev: 2.5,
  };
}

export async function GET() {
  try {
    const healthResponse = await fetch("http://localhost:3003/api/healthz", {
      cache: "no-store",
      signal: AbortSignal.timeout(3000),
    });

    const health = await healthResponse.json();
    const trend = await getTrend();

    // Trend-aware threshold
    const dynamicThreshold = trend.mean + (2 * trend.stdDev); // mean + 2σ

    const checks = [
      // ... (mevcut checkler)
      
      {
        name: "healthz.slo.latencyP95.trend",
        pass: health.slo.latencyP95 < dynamicThreshold,
        value: health.slo.latencyP95,
        expected: `<${dynamicThreshold.toFixed(0)}ms (trend-aware)`,
      },
    ];

    // ... (rest of implementation)
  } catch (err) {
    // ...
  }
}
```

---

## 7️⃣ BIST Vendor Seçimi - Mini Checklist

### Vendor Evaluation Form

```markdown
# BIST Vendor Evaluation: [Vendor Name]

## Contact Info
- **Vendor:** _______________
- **Contact Person:** _______________
- **Email:** _______________
- **Phone:** _______________
- **Trial Account:** _______________

## SLA & Reliability
- [ ] Uptime SLA ≥99.5% (documented)?
- [ ] Status page available?
- [ ] Incident notification (email/webhook)?
- [ ] Historical uptime data provided?

## Performance (Measured)
- [ ] REST P95 latency: _____ ms (target: <500ms)
- [ ] WebSocket P95 latency: _____ ms (target: <100ms)
- [ ] Measured from production environment?
- [ ] Load tested (100+ req/min)?

## Symbol Coverage
- [ ] THYAO ✅
- [ ] AKBNK ✅
- [ ] GARAN ✅
- [ ] ISCTR ✅
- [ ] SAHOL ✅

## Rate Limits & Pricing
- [ ] Rate limit: _____ rpm per symbol
- [ ] Burst policy documented?
- [ ] Pricing model: per-symbol / per-request / flat
- [ ] Monthly cost estimate: $_____ (within budget?)

## Schema & Versioning
- [ ] API documentation complete?
- [ ] Schema samples provided?
- [ ] Versioning strategy documented?
- [ ] Change notification (advance notice)?
- [ ] Edge case scenarios tested?

## Support
- [ ] 24/5 support (Istanbul trading hours)?
- [ ] Support channel: email / phone / chat
- [ ] Response time SLA: _____
- [ ] Escalation process documented?

## Trial Period
- [ ] Trial account active?
- [ ] Trial duration: _____ days
- [ ] Full feature access in trial?
- [ ] Historical data available?

## Security
- [ ] Authentication: API key / OAuth / JWT
- [ ] TLS 1.2+ supported?
- [ ] IP whitelisting available?
- [ ] Audit logging provided?

## Decision
- **Score:** _____ / 100
- **Recommendation:** APPROVED / REJECTED / NEEDS REVIEW
- **Notes:** _____________________________
```

---

## 8️⃣ Güvenlik İyileştirmeleri

### 8.1 Secret Store (API Anahtarları)

```typescript
// apps/web-next/src/lib/secrets.ts

import { SecretsManagerClient, GetSecretValueCommand } from "@aws-sdk/client-secrets-manager";

const client = new SecretsManagerClient({ region: "eu-west-1" });

export async function getSecret(secretName: string): Promise<string> {
  try {
    const response = await client.send(
      new GetSecretValueCommand({
        SecretId: secretName,
        VersionStage: "AWSCURRENT",
      })
    );

    if (response.SecretString) {
      return response.SecretString;
    }

    throw new Error("Secret not found");
  } catch (error) {
    console.error("Failed to retrieve secret:", error);
    throw error;
  }
}

// Kullanım
// const bISTApiKey = await getSecret("prod/bist/api-key");
```

**Alternatif (Lokal Geliştirme):**
```typescript
// .env.local (gitignore'd)
BIST_API_KEY=secret-key-here

// Production'da AWS Secrets Manager kullan
const apiKey = process.env.NODE_ENV === 'production' 
  ? await getSecret('prod/bist/api-key')
  : process.env.BIST_API_KEY;
```

---

### 8.2 Role Gating (Approval API)

```typescript
// apps/web-next/src/middleware.ts (enhanced)

const PROTECTED_ROUTES = [
  '/api/approvals/strategy/:id/approve',
  '/api/approvals/strategy/:id/reject',
  '/api/tools/kill-switch/toggle',
];

const REQUIRED_ROLES = {
  '/api/approvals': ['admin', 'ops'],
  '/api/tools/kill-switch': ['admin'],
};

export function middleware(request: NextRequest) {
  const pathname = request.nextUrl.pathname;
  
  // Role gating kontrolü
  for (const [route, roles] of Object.entries(REQUIRED_ROLES)) {
    if (pathname.startsWith(route)) {
      const userRole = request.headers.get('x-user-role'); // Auth'dan gel
      
      if (!userRole || !roles.includes(userRole)) {
        return NextResponse.json(
          { error: 'Forbidden: Insufficient permissions' },
          { status: 403 }
        );
      }
    }
  }

  // Re-auth prompt (2FA için)
  if (pathname.includes('/kill-switch/toggle')) {
    const lastAuthTime = request.headers.get('x-last-auth-time');
    const now = Date.now();
    
    if (!lastAuthTime || (now - parseInt(lastAuthTime)) > 5 * 60 * 1000) { // 5 dakika
      return NextResponse.json(
        { error: 'Re-authentication required' },
        { status: 401 }
      );
    }
  }

  return NextResponse.next();
}
```

---

## 9️⃣ Sprint Kapanış Tanımı (DoD)

### Per Epic Checklist

```markdown
## Epic [X]: [Epic Name] - Definition of Done

### Code Quality
- [ ] All tasks completed and merged
- [ ] Unit test coverage ≥80%
- [ ] Integration tests passing
- [ ] No critical linter errors
- [ ] Code review approved by 2+ engineers

### Documentation
- [ ] Runbook created/updated (`docs/runbooks/`)
- [ ] Risk analysis documented
- [ ] API documentation updated (if applicable)
- [ ] Inline code comments for complex logic

### Observability
- [ ] Grafana dashboard created/updated
- [ ] Prometheus metrics exported
- [ ] Alert rules configured
- [ ] SLO thresholds documented

### Testing
- [ ] Smoke test passing (dev environment)
- [ ] Load test results documented (if applicable)
- [ ] Edge cases tested
- [ ] Rollback procedure tested

### Deployment
- [ ] Deployed to staging
- [ ] Staging smoke test passing
- [ ] Canary deployment plan documented
- [ ] Evidence ZIP generated (even if successful)

### Handoff
- [ ] Team demo completed
- [ ] Knowledge transfer session held
- [ ] On-call runbook updated
- [ ] Postmortem template prepared
```

---

## 🎯 Özet & Aksiyon Planı

### İnce Ayarların Etkisi
| Kategori | İyileştirme | Beklenen Etki |
|----------|-------------|---------------|
| **SLO Stabilite** | Kayan pencere + min. örnekleme | Yanlış-pozitif %60 azalma |
| **WS Reconnect** | Jitter + global rate cap | Vendor overload riski %80 azalma |
| **SSE Backpressure** | Kuyruk sınırı + delta throttle | Sunucu RAM kullanımı %40 azalma |
| **Prometheus** | Kardinalite freni | Metric storage %50 azalma |
| **Kill-Switch** | Evidence + cooldown | Flip-flop riski %100 elimine |
| **Audit Trace** | Trace-ID enjeksiyonu | Incident debug süresi %70 azalma |
| **Clock Skew** | Açılış ölçümü | Staleness yanlış alarm %30 azalma |
| **BIST Tatil** | Takvim + hash | Zero-volume yanlış alarm %90 azalma |
| **BIST Şema** | Side-by-side canary | Parsing hata riski %95 azalma |
| **Budget Guard** | Maliyet metriği | Bütçe aşımı riski %100 elimine |
| **Risk Skoru** | Semantic highlights | Approval karar süresi %50 azalma |

### Uygulama Sırası (Öncelik)
1. **P0 (Week 0):** SLO kayan pencere, Kill-switch cooldown, Trace-ID, Clock skew
2. **P1 (Week 1):** WS reconnect jitter, SSE backpressure, Prometheus kardinalite
3. **P2 (Week 2):** BIST tatil takvimi, Şema side-by-side, Budget guard
4. **P3 (Week 3):** Risk skoru UI, Incident makrosu, Trend-aware CI gate

---

*İnce ayar paketi hazır. v1.3 sprint'ine "kibarca başarısız olan makine" ile girebilirsiniz.* 🚀

