# v1.3 Altın Ayarlar - "Küçük Ama Kritik" İnce Ayarlar
**Spark Trading Platform - Production Hardening**

**Version:** v1.3-golden-tweaks  
**Date:** 2025-01-16  
**Status:** 🔧 READY TO IMPLEMENT

---

## 🎯 "Altın Ayarlar" Felsefesi

**Küçük ama altın değerinde** optimizasyonlar. Sistemin %90'ı zaten mükemmel; bu ayarlar son %10'u getiren, "sinsi köşe durumları"nı kap

atan parçalar.

---

## 1️⃣ Delta-Threshold: Sembol Duyarlı Ayar

### Problem
**Sabit %0.05 threshold**, yüksek fiyatlı sembollerexcellent ama düşük fiyatlı semboller için çok sıkı. Ucuz enstrümanlarda fazla sessizlik yaşanır.

### Çözüm: Fiyat Bandına Göre Ayarlanabilir Threshold

```typescript
// apps/web-next/src/lib/sse-delta-throttle.ts (enhanced)

interface SymbolConfig {
  symbol: string;
  tickSize: number;        // Minimum fiyat değişimi
  minChangePct: number;    // %değişim eşiği
}

// Sembol konfigürasyonları
const SYMBOL_CONFIGS: Record<string, SymbolConfig> = {
  'BTC_TRY': {
    symbol: 'BTC_TRY',
    tickSize: 1,           // 1 TRY minimum
    minChangePct: 0.05,    // %0.05
  },
  'ETH_TRY': {
    symbol: 'ETH_TRY',
    tickSize: 0.5,         // 0.5 TRY minimum
    minChangePct: 0.05,
  },
  'XRP_TRY': {
    symbol: 'XRP_TRY',
    tickSize: 0.0001,      // Düşük fiyat → tick size
    minChangePct: 0.1,     // %0.1 (daha gevşek)
  },
  'THYAO': {
    symbol: 'THYAO',
    tickSize: 0.02,        // BIST tick size
    minChangePct: 0.05,
  },
  'AKBNK': {
    symbol: 'AKBNK',
    tickSize: 0.02,
    minChangePct: 0.05,
  },
};

interface Tick {
  symbol: string;
  price: number;
  timestamp: number;
}

const lastEmittedTicks = new Map<string, Tick>();

/**
 * Sembol-duyarlı emit kararı
 */
export const shouldEmitTickSymbolAware = (tick: Tick): boolean => {
  const config = SYMBOL_CONFIGS[tick.symbol];
  if (!config) {
    // Bilinmeyen sembol için default behavior
    return shouldEmitTick({ price: tick.price, timestamp: tick.timestamp });
  }

  const lastTick = lastEmittedTicks.get(tick.symbol);
  if (!lastTick) {
    // İlk tick, emit et
    lastEmittedTicks.set(tick.symbol, tick);
    return true;
  }

  const dt = tick.timestamp - lastTick.timestamp;
  const dp = Math.abs(tick.price - lastTick.price);
  const pct = lastTick.price ? (dp / lastTick.price) : 1;

  // İki koşuldan biri sağlanırsa emit et:
  // 1. Zaman delta >250ms
  // 2. Fiyat değişimi > (tickSize OR minChangePct)
  const timeThreshold = dt > 250;
  const priceThresholdPct = pct > (config.minChangePct / 100);
  const priceThresholdAbs = dp > config.tickSize;

  const shouldEmit = timeThreshold || priceThresholdPct || priceThresholdAbs;

  if (shouldEmit) {
    lastEmittedTicks.set(tick.symbol, tick);
  }

  return shouldEmit;
};

/**
 * Prometheus metriği için skip count
 */
let skipCountBySymbol = new Map<string, number>();

export const getSkipCountBySymbol = (symbol: string): number => {
  return skipCountBySymbol.get(symbol) || 0;
};

export const resetSkipCounts = () => {
  skipCountBySymbol.clear();
};
```

**Kullanım:**
```typescript
// SSE stream handler'da
import { shouldEmitTickSymbolAware } from '@/lib/sse-delta-throttle';

// WS event → SSE broadcast
wsClient.on('ticker', (data) => {
  const tick = {
    symbol: data.symbol,
    price: data.price,
    timestamp: Date.now(),
  };

  if (shouldEmitTickSymbolAware(tick)) {
    broadcastToSSEClients(tick);
  } else {
    // Skip, delta threshold altı
    skipCountBySymbol.set(tick.symbol, (skipCountBySymbol.get(tick.symbol) || 0) + 1);
  }
});
```

**Expected Impact:**
- **XRP_TRY gibi düşük fiyatlılar:** Emit rate %30↑ (daha responsive)
- **BTC_TRY gibi yüksekler:** Emit rate korunur
- **Network traf** iği: Genel %20↓ (ortalama)

---

## 2️⃣ SSE Kuyruk Derinliği + Otomatik Throttle Ayarı

### Problem
SSE backpressure tetiklendiğinde, kuyruk sınırı sabit (100). Yüksek trafik dönemlerinde drop-oldest agresif; düşük trafikte kuyruk boşa harcanır.

### Çözüm: Otomatik Throttle Katsayısı (Kapalı Devre)

```typescript
// apps/web-next/src/app/api/market/btcturk/stream/route.ts (enhanced)

interface AdaptiveSSEQueue {
  messages: any[];
  maxSize: number;
  droppedCount: number;
  throttleCoefficient: number; // 1.0 = normal, 2.0 = 2× throttle
}

const sseQueues = new Map<string, AdaptiveSSEQueue>();

// Adaptive throttle logic
function adjustThrottleCoefficient(queue: AdaptiveSSEQueue) {
  const queueUtilization = queue.messages.length / queue.maxSize;

  // Kuyruk %80'in üzerindeyse, throttle'ı artır
  if (queueUtilization > 0.8 && queue.throttleCoefficient < 4.0) {
    queue.throttleCoefficient += 0.5;
    console.log(`[SSE] Throttle arttırıldı: ${queue.throttleCoefficient.toFixed(1)}x`);
  }

  // Kuyruk %40'ın altındaysa, throttle'ı azalt
  if (queueUtilization < 0.4 && queue.throttleCoefficient > 1.0) {
    queue.throttleCoefficient -= 0.25;
    console.log(`[SSE] Throttle azaltıldı: ${queue.throttleCoefficient.toFixed(1)}x`);
  }
}

export async function GET(request: NextRequest) {
  const clientId = crypto.randomUUID();
  const queue: AdaptiveSSEQueue = {
    messages: [],
    maxSize: 100,
    droppedCount: 0,
    throttleCoefficient: 1.0, // Başlangıç: normal
  };
  sseQueues.set(clientId, queue);

  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    start(controller) {
      const baseIntervalMs = 250; // Base throttle interval

      const interval = setInterval(() => {
        const queue = sseQueues.get(clientId);
        if (!queue) return;

        // Adaptive throttle ayarını yap
        adjustThrottleCoefficient(queue);

        // Throttle coefficient'e göre mesaj gönder
        const effectiveInterval = baseIntervalMs * queue.throttleCoefficient;
        
        // Kuyruktan mesaj çek (throttle'a göre)
        const messagesToSend = Math.max(1, Math.floor(queue.messages.length / queue.throttleCoefficient));
        
        for (let i = 0; i < messagesToSend && queue.messages.length > 0; i++) {
          const msg = queue.messages.shift();
          const sseData = `data: ${JSON.stringify(msg)}\n\n`;
          controller.enqueue(encoder.encode(sseData));
        }

        // Dropped count bilgisi
        if (queue.droppedCount > 0) {
          const warning = `data: ${JSON.stringify({ 
            type: 'warning', 
            dropped: queue.droppedCount,
            throttleCoefficient: queue.throttleCoefficient,
          })}\n\n`;
          controller.enqueue(encoder.encode(warning));
          queue.droppedCount = 0;
        }
      }, 250); // Her 250ms kontrol

      // Cleanup on disconnect
      request.signal.addEventListener('abort', () => {
        clearInterval(interval);
        sseQueues.delete(clientId);
      });
    }
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
```

**Prometheus Metrics:**
```typescript
// apps/web-next/src/app/api/tools/metrics/route.ts

// SSE queue depth gauge
metrics.push("# HELP sse_queue_depth_gauge Current SSE queue depth");
metrics.push("# TYPE sse_queue_depth_gauge gauge");
for (const [clientId, queue] of sseQueues.entries()) {
  metrics.push(`sse_queue_depth_gauge{client="${clientId}"} ${queue.messages.length}`);
}

// SSE throttle coefficient gauge
metrics.push("# HELP sse_throttle_coefficient_gauge Current throttle multiplier");
metrics.push("# TYPE sse_throttle_coefficient_gauge gauge");
for (const [clientId, queue] of sseQueues.entries()) {
  metrics.push(`sse_throttle_coefficient_gauge{client="${clientId}"} ${queue.throttleCoefficient}`);
}
```

**Grafana Alert:**
```yaml
# ops/grafana/provisioning/alerts/spark-ui-alerts.yml

- alert: SSEQueueDepthHigh
  expr: sse_queue_depth_gauge > 80
  for: 1m
  labels:
    severity: warning
    service: spark-ui
  annotations:
    summary: "SSE queue depth is high"
    description: "SSE queue depth is {{ $value }}, exceeding 80 (max 100)"
```

**Expected Impact:**
- **Yüksek trafik:** Throttle 4.0× → drop %80↓
- **Düşük trafik:** Throttle 1.0× → latency optimal
- **RAM kullanımı:** Kuyruk utilization %60-70'de stabil

---

## 3️⃣ Rate-Limit Telemetri Ayrımı (Burst vs Sustained)

### Problem
`venue_http_429_total` sayacı burst ve sustained violation'ları ayırt etmiyor. Adaptif backoff'un hangisine göre ayarlanacağı belirsiz.

### Çözüm: Burst ve Sustained Ayrı Sayaçlar

```typescript
// apps/web-next/src/lib/rate-limiter.ts (enhanced)

interface VenueRateLimitState {
  burstViolations: number;      // Son 10s içinde >5 429
  sustainedViolations: number;  // Son 1dk içinde >15 429
  adaptiveBackoffMultiplier: number; // 1.0 = normal, 2.0 = 2× backoff
  lastViolationTime: number;
}

const venueStates = new Map<string, VenueRateLimitState>();

// 429 violation tracking
const violation429History = new Map<string, number[]>(); // venue → [timestamp, ...]

export function record429Violation(venue: string) {
  const now = Date.now();
  
  // History'ye ekle
  if (!violation429History.has(venue)) {
    violation429History.set(venue, []);
  }
  violation429History.get(venue)!.push(now);
  
  // Eski kayıtları temizle (>1dk)
  const history = violation429History.get(venue)!;
  const cutoff = now - 60000;
  violation429History.set(venue, history.filter(t => t > cutoff));
  
  // State'i güncelle
  let state = venueStates.get(venue);
  if (!state) {
    state = {
      burstViolations: 0,
      sustainedViolations: 0,
      adaptiveBackoffMultiplier: 1.0,
      lastViolationTime: now,
    };
    venueStates.set(venue, state);
  }
  
  // Burst detection (son 10s içinde >5)
  const recentHistory = history.filter(t => t > now - 10000);
  if (recentHistory.length > 5) {
    state.burstViolations++;
    console.warn(`[Rate Limit] BURST violation: ${venue} (${recentHistory.length} in 10s)`);
  }
  
  // Sustained detection (son 1dk içinde >15)
  if (history.length > 15) {
    state.sustainedViolations++;
    console.error(`[Rate Limit] SUSTAINED violation: ${venue} (${history.length} in 1min)`);
    
    // Adaptive backoff artır
    if (state.adaptiveBackoffMultiplier < 4.0) {
      state.adaptiveBackoffMultiplier += 0.5;
      console.log(`[Rate Limit] Adaptive backoff arttı: ${state.adaptiveBackoffMultiplier.toFixed(1)}x`);
    }
  }
  
  state.lastViolationTime = now;
  
  // Metrics'e yansıt
  metrics.venue_http_429_burst_total++;
  if (history.length > 15) {
    metrics.venue_http_429_sustained_total++;
  }
}

// Adaptive backoff'u geri düşür (violation yoksa)
export function decayAdaptiveBackoff() {
  const now = Date.now();
  
  for (const [venue, state] of venueStates.entries()) {
    const timeSinceLastViolation = now - state.lastViolationTime;
    
    // 2 dakika violation yoksa backoff'u azalt
    if (timeSinceLastViolation > 120000 && state.adaptiveBackoffMultiplier > 1.0) {
      state.adaptiveBackoffMultiplier -= 0.25;
      console.log(`[Rate Limit] Adaptive backoff azaldı: ${venue} ${state.adaptiveBackoffMultiplier.toFixed(1)}x`);
    }
  }
}

// Periyodik decay (her 30s)
setInterval(decayAdaptiveBackoff, 30000);

// Prometheus metrics
export function getPrometheusMetrics(): string[] {
  const metrics: string[] = [
    "# HELP venue_http_429_burst_total Burst rate limit violations (>5 in 10s)",
    "# TYPE venue_http_429_burst_total counter",
  ];
  
  for (const [venue, state] of venueStates.entries()) {
    metrics.push(`venue_http_429_burst_total{venue="${venue}"} ${state.burstViolations}`);
  }
  
  metrics.push("");
  metrics.push("# HELP venue_http_429_sustained_total Sustained rate limit violations (>15 in 1min)");
  metrics.push("# TYPE venue_http_429_sustained_total counter");
  
  for (const [venue, state] of venueStates.entries()) {
    metrics.push(`venue_http_429_sustained_total{venue="${venue}"} ${state.sustainedViolations}`);
  }
  
  metrics.push("");
  metrics.push("# HELP venue_adaptive_backoff_multiplier Current adaptive backoff multiplier");
  metrics.push("# TYPE venue_adaptive_backoff_multiplier gauge");
  
  for (const [venue, state] of venueStates.entries()) {
    metrics.push(`venue_adaptive_backoff_multiplier{venue="${venue}"} ${state.adaptiveBackoffMultiplier}`);
  }
  
  return metrics;
}
```

**Grafana Alert:**
```yaml
# Burst alert (uyarı)
- alert: RateLimitBurstViolations
  expr: increase(venue_http_429_burst_total[5m]) > 3
  for: 0m
  labels:
    severity: warning
  annotations:
    summary: "Burst rate limit violations"
    description: "{{ $labels.venue }}: {{ $value }} burst violations in 5m"

# Sustained alert (kritik)
- alert: RateLimitSustainedViolations
  expr: increase(venue_http_429_sustained_total[10m]) > 1
  for: 0m
  labels:
    severity: critical
  annotations:
    summary: "Sustained rate limit violations"
    description: "{{ $labels.venue }}: Sustained violations detected, adaptive backoff active"
```

**Expected Impact:**
- **Burst violations:** Adaptif backoff %50↑ (kısa süre)
- **Sustained violations:** Adaptif backoff %200↑ (uzun süre)
- **Vendor SLA:** 429 rate %90↓

---

## 📊 "Altın Ayarlar" Etki Matrisi

| Ayar | Sorun | Çözüm | Expected Impact |
|------|-------|-------|-----------------|
| **Delta-Threshold Sembol Duyarlı** | Düşük fiyatlı semboller sessiz | Tick-size + %değişim hibrit | XRP_TRY emit +%30, network -% 20 |
| **SSE Adaptive Throttle** | Kuyruk overflow'da agresif drop | Otomatik throttle (1.0-4.0×) | Drop %80↓, latency optimize |
| **Rate-Limit Burst/Sustained** | 429'lar ayırt edilemiyor | Ayrı sayaç + adaptif backoff | Vendor 429 %90↓ |

---

## 🎯 Hafta 0 Kabul Kriterleri (Güncellenmiş)

### Code Implementation
- [ ] `sse-delta-throttle.ts` → Sembol-duyarlı threshold
- [ ] `stream/route.ts` → Adaptive throttle coefficient
- [ ] `rate-limiter.ts` → Burst/sustained ayrımı

### Metrics
- [ ] `sse_throttle_coefficient_gauge` (1.0-4.0)
- [ ] `sse_queue_depth_gauge` (0-100)
- [ ] `venue_http_429_burst_total`
- [ ] `venue_http_429_sustained_total`
- [ ] `venue_adaptive_backoff_multiplier`

### Validation
- [ ] XRP_TRY emit rate %30↑ (baseline'a göre)
- [ ] SSE queue depth %80'de plateau (overflow yok)
- [ ] Burst violations → backoff 1.5× (30s içinde)
- [ ] Sustained violations → backoff 2.0× (2dk içinde)

### Evidence
- [ ] Grafana dashboard: SSE queue depth + throttle timeline
- [ ] Grafana dashboard: Rate limit violations (burst/sustained)
- [ ] Alert test: SSEQueueDepthHigh tetikleme
- [ ] Alert test: RateLimitSustainedViolations tetikleme

---

## 🚀 Hızlı Uygulama (30 Dakika)

### Adım 1: Sembol-Duyarlı Delta Threshold (10 dk)
```bash
# Edit: apps/web-next/src/lib/sse-delta-throttle.ts
# Add: SYMBOL_CONFIGS + shouldEmitTickSymbolAware
# Test: XRP_TRY vs BTC_TRY emit rate comparison
```

### Adım 2: SSE Adaptive Throttle (10 dk)
```bash
# Edit: apps/web-next/src/app/api/market/btcturk/stream/route.ts
# Add: AdaptiveSSEQueue + adjustThrottleCoefficient
# Test: 10× flood → observe throttle coefficient increase
```

### Adım 3: Rate-Limit Burst/Sustained (10 dk)
```bash
# Edit: apps/web-next/src/lib/rate-limiter.ts
# Add: record429Violation + burst/sustained detection
# Test: Simulate 10× 429 in 10s → burst alarm
```

---

*Altın Ayarlar paketi hazır. Küçük ama kritik optimizasyonlar "kazaya meyilli evren"de fark yaratır.* 🏅

