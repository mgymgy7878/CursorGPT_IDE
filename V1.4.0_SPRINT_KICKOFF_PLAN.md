# 🧭 v1.4.0 Sprint Açılış Planı - Operasyon Klavuzu

**Milestone:** v1.4.0  
**Süre:** 4 hafta (2025-10-24 → 2025-11-21)  
**Hedef:** Platform Score 89/100 → 95/100  
**P0 İş Yükü:** 134 saat (~3-4 hafta, 3 developer)

---

## 🎯 Sprint Hedefleri

**Core Features (Must Have):**
- ✅ Database Layer (PostgreSQL + Prisma)
- ✅ Execution Engine (Order placement, risk guards)
- ✅ Backtest Engine (Historical simulation)
- ✅ BIST Real-Time Feed (Market data integration)

**Success Metrics:**
- Platform Score: **95/100**
- Test Coverage: **≥70%**
- API P95 Latency: **<200ms**
- Error Rate: **<1%**
- WS Staleness: **<30s**

---

## 📅 Gün 0-1: Kickoff & Guardrails

### Trunk-Based Flow Setup

**Branch Strategy:**
- `main` - Protected, requires PR + CI passing
- `feat/p0-database` - Database layer work
- `feat/p0-execution` - Execution engine work
- `feat/p0-backtest` - Backtest engine work
- `feat/p0-bist` - BIST feed integration

**Branch Protection (main):**
```bash
# Required checks
- unit-tests
- headers-check
- nginx-config-check
- e2e-tests
- summary

# Settings
- Require linear history: ✅
- Dismiss stale approvals: ✅
- Require status checks to pass: ✅
- Require branches to be up to date: ✅
```

### Secrets Management

**GitHub Environments:**
- `development` - Local/dev secrets
- `staging` - Staging env (future)
- `production` - Production secrets (future)

**Required Secrets:**
```bash
# Database
DATABASE_URL=postgresql://...

# Exchange APIs
BINANCE_API_KEY=...
BINANCE_SECRET=...
BTCTURK_API_KEY=...
BTCTURK_SECRET=...

# BIST (if licensed)
BIST_API_KEY=...
```

**Security:**
- ❌ Never in `.env` files committed to git
- ✅ GitHub Secrets only
- ✅ Runtime environment variables

### Observability SLO Targets

**Performance:**
- API P95 Latency: **<200ms**
- Database Query P95: **<50ms**
- Backtest (1 year hourly): **<10s**

**Reliability:**
- 5xx Error Rate: **<1%**
- WS Staleness: **<30s** (prime), **<120s** (degraded)
- Uptime: **≥99%**

**Data Quality:**
- BIST Staleness: **<30s**
- Position Sync Accuracy: **100%**
- Backtest Accuracy: **±0.1%**

### Prometheus Alerts

**Critical Alerts:**
```yaml
# alert.rules.yml

groups:
  - name: spark_core
    interval: 30s
    rules:
      - alert: SparkUpMissing
        expr: absent(spark_up)
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "Spark service down"
          
      - alert: HighErrorRate
        expr: rate(http_requests_total{code=~"5.."}[5m]) / rate(http_requests_total[5m]) > 0.01
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "High error rate (>1%)"
          
      - alert: WSStaleness
        expr: spark_ws_staleness_seconds > 30
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "WebSocket data stale (>30s)"
          
      - alert: HighLatency
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 0.2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "P95 latency >200ms"
```

---

## 📆 Hafta 1: Database Layer (P0, 22h)

### PR1: Prisma Setup & Schema

**Files:**
```
prisma/
  schema.prisma
  migrations/
    20251024_init/
      migration.sql
  seed.ts

docker-compose.yml (PostgreSQL service)
.env.example (DATABASE_URL template)
```

**Schema Models:**
```prisma
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  
  strategies Strategy[]
  backtests  Backtest[]
}

model Strategy {
  id          String   @id @default(cuid())
  name        String
  code        String   @db.Text
  params      Json
  status      String   @default("draft")
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  backtests   Backtest[]
  trades      Trade[]
  
  @@index([userId, status])
}

model Backtest {
  id          String   @id @default(cuid())
  strategyId  String
  strategy    Strategy @relation(fields: [strategyId], references: [id])
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  params      Json
  results     Json
  startDate   DateTime
  endDate     DateTime
  status      String   @default("pending")
  createdAt   DateTime @default(now())
  completedAt DateTime?
  
  @@index([strategyId, status])
  @@index([userId, createdAt])
}

model Trade {
  id         String   @id @default(cuid())
  strategyId String
  strategy   Strategy @relation(fields: [strategyId], references: [id])
  symbol     String
  side       String
  type       String
  price      Float
  quantity   Float
  commission Float    @default(0)
  pnl        Float?
  status     String
  exchange   String
  createdAt  DateTime @default(now())
  filledAt   DateTime?
  
  @@index([strategyId, createdAt])
  @@index([symbol, exchange])
}

model Position {
  id        String   @id @default(cuid())
  symbol    String
  side      String
  quantity  Float
  avgPrice  Float
  exchange  String
  updatedAt DateTime @updatedAt
  
  @@unique([symbol, exchange])
}

model AuditLog {
  id        String   @id @default(cuid())
  action    String
  actor     String
  payload   Json
  hash      String
  timestamp DateTime @default(now())
  
  @@index([action, timestamp])
}
```

**Commands:**
```bash
# Docker PostgreSQL
docker-compose up -d postgres

# Prisma setup
pnpm add -w prisma @prisma/client
pnpm exec prisma init
pnpm exec prisma migrate dev --name init
pnpm exec prisma generate
pnpm exec prisma db seed
```

**Evidence:**
- `evidence/db_migration_logs.txt`
- `evidence/db_schema_snapshot.sql`
- `evidence/db_seed_results.json`

**Tests:**
- Unit: Model validations
- Integration: CRUD operations
- E2E: Health check with DB connection

---

### PR2: PrismaClient Integration

**Files:**
```
services/executor/src/lib/db.ts
services/executor/src/config/database.ts
```

**Connection Pooling:**
```typescript
// services/executor/src/lib/db.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma = globalForPrisma.prisma || new PrismaClient({
  log: ['query', 'error', 'warn'],
  datasources: {
    db: {
      url: process.env.DATABASE_URL,
    },
  },
});

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}

// Connection pool config
// pglib defaults: max 10, idle timeout 10s
```

**Health Check:**
```typescript
// Add to /healthz endpoint
const dbHealth = await prisma.$queryRaw`SELECT 1`;
```

**Evidence:**
- Connection pool metrics
- Query performance logs

---

## 📆 Hafta 2: Execution Engine (P0, 42h)

### PR3: Order State Machine

**State Flow:**
```
pending → submitted → filled → settled
        ↓
    cancelled / rejected / expired
```

**Implementation:**
```typescript
// services/executor/src/execution/stateMachine.ts

export type OrderState = 
  | 'pending'
  | 'submitted'
  | 'filled'
  | 'settled'
  | 'cancelled'
  | 'rejected'
  | 'expired';

export async function transitionOrder(
  orderId: string,
  from: OrderState,
  to: OrderState,
  reason?: string
) {
  // Validate transition
  const validTransitions = {
    pending: ['submitted', 'cancelled'],
    submitted: ['filled', 'rejected', 'expired'],
    filled: ['settled'],
  };
  
  if (!validTransitions[from]?.includes(to)) {
    throw new Error(`Invalid transition: ${from} → ${to}`);
  }
  
  // Update in DB with audit
  await prisma.$transaction([
    prisma.trade.update({
      where: { id: orderId },
      data: { status: to },
    }),
    prisma.auditLog.create({
      data: {
        action: 'order_transition',
        actor: 'system',
        payload: { orderId, from, to, reason },
        hash: hashPayload({ orderId, from, to }),
      },
    }),
  ]);
}
```

**Evidence:**
- State transition diagram
- Audit log samples

---

### PR4: Risk Guardrails

**Risk Checks (Sequential):**
```typescript
// services/executor/src/execution/riskGuards.ts

export async function checkRiskLimits(order: OrderRequest): Promise<RiskCheck> {
  const checks: RiskCheck[] = [];
  
  // 1. Notional limit
  const notional = order.price * order.quantity;
  const MAX_NOTIONAL = 10000; // $10k per order
  
  if (notional > MAX_NOTIONAL) {
    return {
      pass: false,
      reason: 'notional_exceeded',
      detail: `${notional} > ${MAX_NOTIONAL}`,
      metric: 'spark_risk_block_total',
      labels: { reason: 'notional' },
    };
  }
  
  // 2. Exposure limit
  const positions = await prisma.position.findMany({
    where: { symbol: order.symbol },
  });
  
  const exposure = positions.reduce((sum, p) => sum + p.quantity * p.avgPrice, 0);
  const MAX_EXPOSURE = 50000; // $50k per symbol
  
  if (exposure + notional > MAX_EXPOSURE) {
    return {
      pass: false,
      reason: 'exposure_exceeded',
      detail: `${exposure + notional} > ${MAX_EXPOSURE}`,
      metric: 'spark_risk_block_total',
      labels: { reason: 'exposure' },
    };
  }
  
  // 3. Drawdown limit
  const recentTrades = await prisma.trade.findMany({
    where: {
      strategyId: order.strategyId,
      createdAt: { gte: new Date(Date.now() - 24 * 60 * 60 * 1000) },
    },
  });
  
  const totalPnL = recentTrades.reduce((sum, t) => sum + (t.pnl || 0), 0);
  const maxEquity = Math.max(0, ...recentTrades.map((t, i) => 
    recentTrades.slice(0, i + 1).reduce((s, x) => s + (x.pnl || 0), 0)
  ));
  
  const drawdown = maxEquity > 0 ? (maxEquity - totalPnL) / maxEquity : 0;
  const MAX_DRAWDOWN = 0.15; // 15%
  
  if (drawdown > MAX_DRAWDOWN) {
    return {
      pass: false,
      reason: 'drawdown_exceeded',
      detail: `${(drawdown * 100).toFixed(2)}% > ${MAX_DRAWDOWN * 100}%`,
      metric: 'spark_risk_block_total',
      labels: { reason: 'drawdown' },
    };
  }
  
  // 4. Kill switch
  const killSwitch = await prisma.auditLog.findFirst({
    where: { action: 'kill_switch', payload: { path: ['active'], equals: true } },
    orderBy: { timestamp: 'desc' },
  });
  
  if (killSwitch) {
    return {
      pass: false,
      reason: 'kill_switch_active',
      detail: 'Trading halted by kill switch',
      metric: 'spark_risk_killswitch_active',
      labels: {},
    };
  }
  
  return { pass: true };
}
```

**Metrics:**
```typescript
// Prometheus counters
incCounter('spark_risk_block_total', { reason: 'notional' });
incCounter('spark_risk_block_total', { reason: 'exposure' });
incCounter('spark_risk_block_total', { reason: 'drawdown' });
setGauge('spark_risk_killswitch_active', 1); // 1 = active, 0 = inactive
```

---

### PR5: Binance Integration + Idempotency

**Idempotency:**
```typescript
// services/executor/src/execution/idempotency.ts

export async function ensureIdempotent<T>(
  key: string,
  fn: () => Promise<T>
): Promise<T> {
  // Check if request already processed
  const existing = await prisma.auditLog.findFirst({
    where: {
      action: 'idempotent_request',
      hash: key,
    },
  });
  
  if (existing) {
    // Return cached result
    return existing.payload.result as T;
  }
  
  // Execute and cache
  const result = await fn();
  
  await prisma.auditLog.create({
    data: {
      action: 'idempotent_request',
      actor: 'system',
      payload: { key, result },
      hash: key,
    },
  });
  
  return result;
}
```

**Usage:**
```typescript
// POST /api/exec/order
export async function POST(req: Request) {
  const idempotencyKey = req.headers.get('X-Idempotency-Key');
  
  if (!idempotencyKey) {
    return NextResponse.json({ error: 'Missing X-Idempotency-Key' }, { status: 400 });
  }
  
  const result = await ensureIdempotent(idempotencyKey, async () => {
    return placeOrder(await req.json());
  });
  
  return NextResponse.json(result);
}
```

**Binance API:**
```typescript
// services/executor/src/exchange/binance.ts

import crypto from 'crypto';

export async function placeBinanceOrder(order: OrderRequest) {
  const timestamp = Date.now();
  const params = {
    symbol: order.symbol,
    side: order.side.toUpperCase(),
    type: order.type.toUpperCase(),
    quantity: order.quantity,
    timestamp,
  };
  
  if (order.price) {
    params.price = order.price;
  }
  
  // Signature
  const queryString = Object.entries(params)
    .map(([k, v]) => `${k}=${v}`)
    .join('&');
    
  const signature = crypto
    .createHmac('sha256', process.env.BINANCE_SECRET!)
    .update(queryString)
    .digest('hex');
  
  // Request with exponential backoff
  const response = await retryWithBackoff(async () => {
    return fetch(`https://api.binance.com/api/v3/order?${queryString}&signature=${signature}`, {
      method: 'POST',
      headers: {
        'X-MBX-APIKEY': process.env.BINANCE_API_KEY!,
      },
    });
  });
  
  return response.json();
}

async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries = 3
): Promise<T> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (err) {
      if (i === maxRetries - 1) throw err;
      
      const backoff = Math.min(1000 * Math.pow(2, i), 10000);
      const jitter = Math.random() * 500;
      
      await new Promise(r => setTimeout(r, backoff + jitter));
    }
  }
  
  throw new Error('Max retries exceeded');
}
```

**Paper Trading Mode:**
```typescript
// config
const PAPER_MODE = process.env.PAPER_TRADING === 'true';

if (PAPER_MODE) {
  // Simulate fill instead of real API call
  return {
    orderId: `paper_${Date.now()}`,
    status: 'FILLED',
    executedQty: order.quantity,
    price: order.price,
  };
}
```

**Evidence:**
- Paper mode trade logs
- Idempotency test results
- Binance API success rate metrics

**Tests:**
- Unit: State machine transitions, risk checks
- Integration: Idempotency with DB
- E2E: Create strategy → place order (paper) → verify position

---

## 📆 Hafta 3: Backtest Engine (P0, 42h)

### PR6: OHLCV Data Loader

**Implementation:**
```typescript
// services/analytics/src/backtest/dataLoader.ts

export async function loadHistoricalData(
  symbol: string,
  startDate: Date,
  endDate: Date,
  exchange: 'binance' | 'btcturk',
  interval: '1m' | '5m' | '15m' | '1h' | '4h' | '1d' = '1h'
): Promise<Candle[]> {
  // Check cache first
  const cacheKey = `${exchange}_${symbol}_${interval}_${startDate.toISOString()}_${endDate.toISOString()}`;
  const cached = await loadFromCache(cacheKey);
  
  if (cached) {
    return cached;
  }
  
  // Fetch from exchange
  const candles = exchange === 'binance' 
    ? await fetchBinanceKlines(symbol, startDate, endDate, interval)
    : await fetchBTCTurkOHLCV(symbol, startDate, endDate, interval);
  
  // Cache for future use
  await saveToCache(cacheKey, candles);
  
  return candles;
}
```

**File Cache:**
```typescript
// Simple JSON cache (v1.4, upgrade to Redis in v1.5)
const CACHE_DIR = './data/cache';

async function saveToCache(key: string, data: any) {
  const filename = `${CACHE_DIR}/${crypto.createHash('md5').update(key).digest('hex')}.json`;
  await fs.writeFile(filename, JSON.stringify(data));
}
```

---

### PR7: Event-Driven Simulator

**Kıstas Strateji (Oracle):**
```python
# tools/oracle/sma_crossover.py
import pandas as pd
import numpy as np

def sma_crossover_backtest(data, fast=10, slow=30, commission=0.001):
    """Reference implementation for validation"""
    df = pd.DataFrame(data)
    df['sma_fast'] = df['close'].rolling(fast).mean()
    df['sma_slow'] = df['close'].rolling(slow).mean()
    
    position = 0
    equity = 10000
    trades = []
    
    for i in range(1, len(df)):
        if df['sma_fast'][i] > df['sma_slow'][i] and position == 0:
            # Buy signal
            shares = equity / df['close'][i]
            cost = shares * df['close'][i] * (1 + commission)
            
            if cost <= equity:
                position = shares
                equity -= cost
                trades.append({
                    'timestamp': df['timestamp'][i],
                    'side': 'buy',
                    'price': df['close'][i],
                    'quantity': shares,
                })
                
        elif df['sma_fast'][i] < df['sma_slow'][i] and position > 0:
            # Sell signal
            proceeds = position * df['close'][i] * (1 - commission)
            equity += proceeds
            
            trades.append({
                'timestamp': df['timestamp'][i],
                'side': 'sell',
                'price': df['close'][i],
                'quantity': position,
            })
            
            position = 0
    
    # Calculate metrics
    final_equity = equity + position * df['close'].iloc[-1]
    total_return = (final_equity - 10000) / 10000
    
    # ... Sharpe, maxDD, etc.
    
    return {
        'metrics': { 'totalReturn': total_return, ... },
        'trades': trades,
    }
```

**TypeScript Validator:**
```typescript
// services/analytics/src/backtest/__tests__/oracle.test.ts

test('SMA crossover matches Python oracle', async () => {
  const data = loadTestData('btcusdt_2024_hourly.json');
  
  // Run TS backtest
  const tsResult = await runBacktest({
    strategyCode: SMA_CROSSOVER_CODE,
    symbol: 'BTCUSDT',
    ...
  });
  
  // Run Python oracle
  const oracleResult = execSync(`python tools/oracle/sma_crossover.py ${dataFile}`);
  const oracle = JSON.parse(oracleResult);
  
  // Compare (tolerance 0.1%)
  expect(Math.abs(tsResult.metrics.totalReturn - oracle.metrics.totalReturn)).toBeLessThan(0.001);
  expect(Math.abs(tsResult.metrics.sharpe - oracle.metrics.sharpe)).toBeLessThan(0.001);
});
```

**Evidence:**
- Oracle comparison results
- Equity curve chart
- Metrics accuracy report

---

### PR8: Job Queue & Persistence

**Simple In-Process Queue:**
```typescript
// services/analytics/src/backtest/queue.ts

const jobs = new Map<string, BacktestJob>();

export async function enqueueBacktest(config: BacktestConfig): Promise<string> {
  const jobId = `bt_${Date.now()}_${randomUUID().slice(0, 8)}`;
  
  // Create DB record
  const backtest = await prisma.backtest.create({
    data: {
      id: jobId,
      strategyId: config.strategyId,
      userId: config.userId,
      params: config.params,
      startDate: config.startDate,
      endDate: config.endDate,
      status: 'pending',
      results: {},
    },
  });
  
  // Queue job
  jobs.set(jobId, {
    id: jobId,
    config,
    status: 'pending',
    progress: 0,
  });
  
  // Process async
  processBacktest(jobId).catch(err => {
    console.error(`Backtest ${jobId} failed:`, err);
  });
  
  return jobId;
}

async function processBacktest(jobId: string) {
  const job = jobs.get(jobId);
  if (!job) return;
  
  // Update status
  job.status = 'running';
  await prisma.backtest.update({
    where: { id: jobId },
    data: { status: 'running' },
  });
  
  try {
    // Run backtest
    const result = await runBacktest(job.config);
    
    // Save results
    await prisma.backtest.update({
      where: { id: jobId },
      data: {
        status: 'completed',
        results: result as any,
        completedAt: new Date(),
      },
    });
    
    job.status = 'completed';
    job.progress = 100;
    
  } catch (err) {
    await prisma.backtest.update({
      where: { id: jobId },
      data: {
        status: 'failed',
        results: { error: err.message } as any,
      },
    });
    
    job.status = 'failed';
  }
}
```

**Evidence:**
- Job queue performance metrics
- Concurrent job handling test

---

## 📆 Hafta 4: BIST Feed (P0, 28h) & Sertleştirme

### PR9: BIST Provider Integration

**Provider Selection Matrix:**

| Provider | Cost | Latency | Coverage | License |
|----------|------|---------|----------|---------|
| BIST Official API | $$$ | Low | Full | Commercial |
| Matriks | $$ | Medium | Full | Licensed |
| Free/Delayed | Free | High (15min) | Limited | Public |

**Implementation (Polling):**
```typescript
// packages/marketdata-bist/src/provider.ts

export async function fetchBISTSnapshot(symbols: string[]) {
  const BASE_URL = process.env.BIST_API_URL || 'https://api.example.com/bist';
  
  const responses = await Promise.all(
    symbols.map(symbol => 
      fetch(`${BASE_URL}/ticker/${symbol}`, {
        headers: {
          'Authorization': `Bearer ${process.env.BIST_API_KEY}`,
        },
      }).then(r => r.json())
    )
  );
  
  return responses.map((data, i) => ({
    symbol: symbols[i],
    price: data.last,
    bid: data.bid,
    ask: data.ask,
    volume: data.volume,
    timestamp: Date.now(),
    source: 'bist',
  }));
}
```

**Symbol Mapping:**
```typescript
// packages/marketdata-common/src/symbolMap.ts

export const BIST_SYMBOLS = {
  'THYAO': 'Türk Hava Yolları',
  'AKBNK': 'Akbank',
  'GARAN': 'Garanti BBVA',
  'ISCTR': 'İş Bankası (C)',
  'YKBNK': 'Yapı Kredi',
  // ... more
};

export function normalizeBISTSymbol(input: string): string {
  const upper = input.toUpperCase().trim();
  return BIST_SYMBOLS[upper] ? upper : null;
}
```

**Staleness Monitoring:**
```typescript
// Last update tracking
let lastBISTUpdate = 0;

export function getBISTStaleness(): number {
  return Math.floor((Date.now() - lastBISTUpdate) / 1000);
}

// Prometheus gauge
setGauge('spark_bist_last_update_ts', lastBISTUpdate);
setGauge('spark_bist_staleness_seconds', getBISTStaleness());
```

**Evidence:**
- BIST provider comparison table
- Symbol mapping coverage
- Staleness metrics graph

---

## 🧪 Test Matrisi (Minimum Coverage)

### Unit Tests (≥70% coverage)

**Database:**
- ✅ Model validations
- ✅ Relation queries
- ✅ Transaction rollbacks

**Risk Guards:**
- ✅ Notional limit check
- ✅ Exposure calculation
- ✅ Drawdown computation
- ✅ Kill switch activation

**Order State Machine:**
- ✅ Valid transitions
- ✅ Invalid transition rejection
- ✅ Audit log creation

**Metrics Calculator:**
- ✅ Total return
- ✅ Sharpe ratio
- ✅ Max drawdown
- ✅ Win rate, profit factor

### Integration Tests

**Database:**
- ✅ Prisma CRUD operations
- ✅ Connection pooling
- ✅ Transaction handling

**Exchange Client:**
- ✅ Binance signature generation
- ✅ Retry with backoff
- ✅ Error handling

**Backtest Flow:**
- ✅ Data loader → simulator → metrics → DB
- ✅ Job queue processing
- ✅ Results retrieval

### E2E Tests (Playwright)

**Critical Paths:**

**1. Strategy Lifecycle:**
```typescript
test('Strategy create → backtest → deploy', async ({ page }) => {
  // Create strategy
  await page.goto('/strategy-lab');
  await page.fill('[data-testid="code-editor"]', SAMPLE_STRATEGY);
  await page.click('[data-testid="save-strategy"]');
  
  // Run backtest
  await page.click('[data-testid="run-backtest"]');
  await page.waitForSelector('[data-testid="equity-chart"]');
  
  // Verify metrics
  const sharpe = await page.textContent('[data-testid="metric-sharpe"]');
  expect(parseFloat(sharpe)).toBeGreaterThan(0);
  
  // Deploy (paper mode)
  await page.click('[data-testid="deploy-paper"]');
  await page.waitForSelector('[data-testid="running-status"]');
});
```

**2. Order Placement (Paper):**
```typescript
test('Place paper order → position visible', async ({ page }) => {
  await page.goto('/dashboard');
  
  // Trigger paper order via API
  const response = await page.request.post('/api/exec/order', {
    headers: {
      'X-Idempotency-Key': `test_${Date.now()}`,
    },
    data: {
      symbol: 'BTCUSDT',
      side: 'buy',
      type: 'market',
      quantity: 0.01,
      strategyId: 'test-strategy',
    },
  });
  
  expect(response.ok()).toBeTruthy();
  
  // Check portfolio
  await page.goto('/portfolio');
  await page.waitForSelector('[data-testid="position-BTCUSDT"]');
  
  const quantity = await page.textContent('[data-testid="quantity-BTCUSDT"]');
  expect(quantity).toContain('0.01');
});
```

**3. BIST Live Feed:**
```typescript
test('BIST data updates → staleness <30s', async ({ page }) => {
  await page.goto('/dashboard');
  
  // Wait for initial data
  await page.waitForSelector('[data-testid="market-THYAO"]');
  
  // Check staleness metric
  await page.goto('/observability');
  await page.waitForSelector('[data-testid="bist-staleness"]');
  
  const staleness = await page.textContent('[data-testid="bist-staleness"]');
  expect(parseFloat(staleness)).toBeLessThan(30);
});
```

---

## 🧯 Güvenlik & Operasyon Kontrol Listesi

### Secrets Management

**❌ Never:**
- Commit secrets to git
- Log secrets (even masked)
- Store in build artifacts
- Include in error messages

**✅ Always:**
- GitHub Secrets for CI/CD
- Environment-specific secrets
- Rotation every 90 days
- Audit access logs

### Rate Limiting & Retry

**NGINX Rate Limiting:**
```nginx
# Main nginx.conf (http block)
limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;
limit_req_zone $binary_remote_addr zone=ws_limit:10m rate=100r/s;

# In spark.conf
location /api/ {
    limit_req zone=api_limit burst=20 nodelay;
    # ...
}

location /ws/ {
    limit_req zone=ws_limit burst=50 nodelay;
    # ...
}
```

**Application Rate Limiting:**
```typescript
// services/executor/src/middleware/rateLimit.ts

import { RateLimiter } from 'limiter';

const exchangeLimiters = {
  binance: new RateLimiter({ tokensPerInterval: 1200, interval: 'minute' }),
  btcturk: new RateLimiter({ tokensPerInterval: 600, interval: 'minute' }),
};

export async function checkExchangeRateLimit(exchange: string) {
  const limiter = exchangeLimiters[exchange];
  const remaining = await limiter.removeTokens(1);
  
  if (remaining < 0) {
    throw new Error('Rate limit exceeded');
  }
}
```

### Audit Logging

**AuditLog Table:**
- `action` - Action type (order_place, strategy_start, etc.)
- `actor` - User/system identifier
- `payload` - Action details (JSON)
- `hash` - Payload hash for integrity
- `timestamp` - UTC timestamp

**Usage:**
```typescript
await prisma.auditLog.create({
  data: {
    action: 'order_place',
    actor: userId,
    payload: { orderId, symbol, side, quantity },
    hash: hashPayload({ orderId, symbol, side, quantity }),
    timestamp: new Date(),
  },
});
```

### Runbooks

**RUNBOOK_DB_FAILOVER.md:**
```markdown
## Database Failover Procedure

### Detection
- Alert: `ALERT DatabaseDown IF absent(pg_up) for 2m`
- Health check failing: `/healthz` returns 503

### Response
1. Check PostgreSQL container: `docker ps | grep postgres`
2. Check logs: `docker logs spark-postgres`
3. Restart if needed: `docker-compose restart postgres`
4. Verify: `psql $DATABASE_URL -c "SELECT 1"`

### Rollback
- If data corruption: Restore from backup
- Backup location: `backups/postgres/daily/`
- Restore: `pg_restore -d spark backup.dump`
```

**RUNBOOK_EXCHANGE_OUTAGE.md:**
```markdown
## Exchange API Outage

### Detection
- Alert: `ALERT ExchangeDown IF rate(exchange_api_errors_total[5m]) > 0.5`
- Orders failing with 503/timeout

### Response
1. Check exchange status page
2. Enable circuit breaker: `POST /api/tools/circuit-breaker?exchange=binance&state=open`
3. Switch to paper mode: `PAPER_TRADING=true`
4. Monitor recovery

### Rollback
- Close circuit breaker when recovered
- Resume real trading after 5min stability
```

**RUNBOOK_BIST_DEGRADED.md:**
```markdown
## BIST Feed Degraded

### Detection
- Alert: `ALERT BISTStaleness IF spark_bist_staleness_seconds > 120`
- UI shows "degraded" badge

### Response
1. Check BIST provider status
2. Check rate limiting: `grep "429" logs/marketdata.log`
3. Switch to fallback provider (if available)
4. Enable feature flag: `BIST_ENABLED=false` (graceful degradation)

### Recovery
- Monitor staleness metric
- Re-enable when `staleness < 30s` for 5min
```

---

## 📌 Takip & Yönetim

### GitHub Project (v2) Setup

**Board Name:** "Spark v1.4.0 Sprint"

**Columns:**
- 📋 Backlog
- 🏗️ In Progress
- 🧪 Testing
- 👀 Review
- ✅ Done

**Fields:**
- Priority: P0, P1, P2, P3
- Cycle: Week 1, Week 2, Week 3, Week 4
- Owner: Developer name
- Estimate: Hours
- Actual: Hours (tracked)

### PR Evidence Requirement

**Template (PR Description):**
```markdown
## Evidence

**Files:**
- `evidence/p0_database_migration_logs.txt`
- `evidence/p0_execution_paper_trade.json`
- `evidence/p0_backtest_oracle_comparison.csv`

**Screenshots:**
- Equity curve chart
- Position table with paper trades
- Metrics dashboard

**Metrics:**
- Test coverage: 78%
- CI run: All jobs passing
- Performance: P95 <150ms
```

### Haftalık Sağlık Özeti (Otomatik)

**Script:** `tools/weekly_health.sh`

```bash
#!/bin/bash
# Generate weekly health report

WEEK=$(date +%Y-W%U)
OUTPUT="evidence/weekly_health_${WEEK}.md"

echo "# Weekly Health Report - $WEEK" > $OUTPUT
echo "" >> $OUTPUT

# Metrics
echo "## Metrics" >> $OUTPUT
curl -s http://localhost:3003/api/public/metrics.prom | \
  grep -E "spark_(ws_staleness|api_latency|error_rate)" >> $OUTPUT

# Open Issues
echo "" >> $OUTPUT
echo "## Open Issues" >> $OUTPUT
gh issue list --milestone v1.4.0 --json number,title,labels | \
  jq -r '.[] | "- #\(.number): \(.title) [\(.labels[].name | join(", "))]"' >> $OUTPUT

# CI Status
echo "" >> $OUTPUT
echo "## CI Health" >> $OUTPUT
gh run list --limit 10 --json conclusion | \
  jq -r '.[] | .conclusion' | sort | uniq -c >> $OUTPUT

echo "✅ Report generated: $OUTPUT"
```

**Cron:**
```bash
# Run every Friday at 5PM
0 17 * * 5 /path/to/weekly_health.sh
```

---

## 📐 İskelet Dosya Ağaçları (v1.4.0)

### Database Layer

```
prisma/
├── schema.prisma              # Main schema
├── migrations/
│   └── 20251024_init/
│       └── migration.sql
└── seed.ts                    # Seed data

services/executor/src/
├── lib/
│   ├── db.ts                  # PrismaClient singleton
│   └── dbHealth.ts            # DB health checks
├── config/
│   └── database.ts            # Pool config
└── __tests__/
    └── db.test.ts             # DB integration tests
```

### Execution Engine

```
services/executor/src/
├── execution/
│   ├── orders.ts              # Order placement
│   ├── stateMachine.ts        # State transitions
│   ├── riskGuards.ts          # Risk checks
│   └── idempotency.ts         # Idempotency handler
├── exchange/
│   ├── binance.ts             # Binance client
│   ├── btcturk.ts             # BTCTurk client
│   └── retry.ts               # Retry with backoff
├── routes/
│   ├── order.ts               # POST /api/exec/order
│   ├── start.ts               # POST /api/exec/start
│   └── stop.ts                # POST /api/exec/stop
└── __tests__/
    ├── orders.test.ts         # Unit tests
    ├── riskGuards.test.ts     # Unit tests
    └── execution.e2e.test.ts  # E2E tests
```

### Backtest Engine

```
services/analytics/src/
├── backtest/
│   ├── dataLoader.ts          # OHLCV loader
│   ├── engine.ts              # Event simulator
│   ├── metrics.ts             # Metrics calculator
│   ├── queue.ts               # Job queue
│   └── oracle/
│       └── sma.py             # Reference implementation
├── cache/
│   └── fileCache.ts           # Simple file cache
└── __tests__/
    ├── dataLoader.test.ts     # Unit tests
    ├── engine.test.ts         # Unit tests
    ├── metrics.test.ts        # Unit tests
    └── oracle.test.ts         # Oracle comparison
```

### BIST Feed

```
packages/marketdata-bist/src/
├── provider.ts                # BIST API client
├── mapping.ts                 # Symbol mapping
├── rateLimit.ts               # Rate limiter
└── __tests__/
    └── provider.test.ts       # Unit tests

services/marketdata/src/
├── bist/
│   ├── poller.ts              # Polling scheduler
│   └── normalize.ts           # Data normalization
└── routes/
    └── bist.ts                # GET /bist/snapshot
```

---

## 📊 Definition of Ready (DoR)

**Checklist (Her P0 Issue İçin):**

- [ ] **Environment/Secrets tanımlı**
  - DATABASE_URL, API keys documented
  - GitHub Secrets configured
  
- [ ] **Acceptance Criteria yazıldı**
  - Given/When/Then format
  - Testable conditions
  
- [ ] **Test Planı hazır**
  - Minimum: 1 unit, 1 integration, (optional) 1 e2e
  - Coverage target: ≥70%
  
- [ ] **Dependencies çözümlü**
  - Blocking issues identified
  - Required services running
  
- [ ] **Estimate doğrulandı**
  - Hours estimated
  - Complexity understood

---

## ✅ Definition of Done (DoD)

**Checklist (Her PR İçin):**

- [ ] **Code Complete**
  - All acceptance criteria met
  - No TODO comments
  - TypeScript errors: 0
  
- [ ] **Tests Passing**
  - Unit tests: ≥70% coverage
  - Integration tests: Pass
  - E2E tests: Pass (if applicable)
  - CI: All jobs green
  
- [ ] **Metrics Added**
  - Prometheus metrics exported
  - docs/METRICS_CANARY.md updated
  - Grafana dashboard (if new metric type)
  
- [ ] **Evidence Collected**
  - Logs saved to `evidence/p0_<feature>_*.txt`
  - Screenshots (if UI change)
  - HTTP traces (if API change)
  
- [ ] **Documentation Updated**
  - Code comments (JSDoc)
  - API docs (if endpoint)
  - Runbook entry (if operational impact)
  
- [ ] **Runbook Entry**
  - Normal operation steps
  - Failure scenarios
  - Rollback plan
  
- [ ] **Code Reviewed**
  - At least 1 approval
  - All comments addressed
  - CI passing

---

## 🎯 Sprint Success Criteria

### Platform Score Target: 95/100

| Category | v1.3.1 | v1.4.0 Target | Delta |
|----------|---------|---------------|-------|
| **Infrastructure** | 100% | 100% | - |
| **Features** | 75% | 90% | +15% |
| **Code Quality** | 70% | 80% | +10% |
| **Testing** | 60% | 80% | +20% |
| **Documentation** | 95% | 95% | - |
| **Monitoring** | 90% | 95% | +5% |
| **Security** | 80% | 85% | +5% |
| **Overall** | **88%** | **95%** | **+7%** |

### Delivery Checklist

**End of Sprint:**
- [ ] All 4 P0 issues closed
- [ ] Test coverage ≥70%
- [ ] CI/CD all green
- [ ] Release notes draft
- [ ] Demo ready
- [ ] Production deployment plan

**Release Artifacts:**
- v1.4.0 tag
- Release notes
- Migration guide
- Deployment runbook

---

## 🚀 Quick Commands Reference

### Development

```bash
# Start all services
pnpm dev:up

# Database
docker-compose up -d postgres
pnpm exec prisma migrate dev
pnpm exec prisma studio

# Executor (with DB)
cd services/executor
DATABASE_URL="..." pnpm dev

# Run tests
pnpm -r test
pnpm --filter web-next test:e2e

# Smoke test
.\scripts\smoke_headers_prom.ps1 -Port 3003
```

### CI/CD

```bash
# Trigger workflow manually
gh workflow run headers-smoke.yml

# Watch CI
gh run watch

# Check latest
gh run list --limit 5
```

### Evidence Collection

```bash
# Capture logs
docker logs spark-postgres > evidence/db_startup.log
pnpm --filter executor dev 2>&1 | tee evidence/executor_startup.log

# Metrics snapshot
curl http://localhost:3003/api/public/metrics.prom > evidence/metrics_$(date +%Y%m%d).txt

# Health check
curl http://localhost:3003/api/healthz | jq > evidence/health_$(date +%Y%m%d).json
```

---

## 📚 Referanslar

**Technical Docs:**
- [Prisma Best Practices](https://www.prisma.io/docs/guides/performance-and-optimization)
- [Binance API](https://binance-docs.github.io/apidocs/)
- [BTCTurk API](https://docs.btcturk.com/)

**Project Docs:**
- [EYLEM_PLANI_HEMEN_BASLAT_2025_10_24.md](EYLEM_PLANI_HEMEN_BASLAT_2025_10_24.md) - Action plan with code
- [DETAYLI_PROJE_ANALIZ_2025_10_24.md](DETAYLI_PROJE_ANALIZ_2025_10_24.md) - Full analysis
- [docs/METRICS_CANARY.md](docs/METRICS_CANARY.md) - Metrics guide

**Issue Templates:**
- [.github/ISSUE_TEMPLATE/p0-database-layer.md](.github/ISSUE_TEMPLATE/p0-database-layer.md)
- [.github/ISSUE_TEMPLATE/p0-execution-engine.md](.github/ISSUE_TEMPLATE/p0-execution-engine.md)
- [.github/ISSUE_TEMPLATE/p0-backtest-engine.md](.github/ISSUE_TEMPLATE/p0-backtest-engine.md)
- [.github/ISSUE_TEMPLATE/p0-bist-feed.md](.github/ISSUE_TEMPLATE/p0-bist-feed.md)

---

## 🎉 Sprint Kickoff Ready!

**Status:** ✅ **READY TO START**

**Prepared:**
- ✅ 4 P0 issues created
- ✅ Milestone v1.4.0 (due: Nov 21)
- ✅ Labels organized
- ✅ Version management (v1.3.2-SNAPSHOT)
- ✅ DoR/DoD defined
- ✅ Test matrix documented
- ✅ Security checklist ready
- ✅ Runbook templates created

**Next Action:** Assign P0 issues to developers and begin Week 1!

---

*"Gözler ve kulaklar yerinde — Prometheus dili konuşuyor, NGINX kibarlıkla başlık atıyor, CI da 'evet' diyor. Şimdi veri katmanını indirip motoru takalım; sonra bu gemi gerçek dalgada hızlanacak!"* 🚀🌊

---

**Created:** 2025-10-24  
**Version:** 1.0.0  
**Maintainer:** AI Assistant (Claude 4.1 Opus)

