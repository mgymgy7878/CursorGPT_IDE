# v1.3 Guardrails Sprint Plan
**Spark Trading Platform**

**Version:** v1.3  
**Target Date:** T+2 weeks from v1.2 completion  
**Status:** 📋 PLANNING  
**Prerequisites:** ✅ v1.2 Real Canary PASS, SLO thresholds active

---

## 🎯 Sprint Goals

### Primary Objectives
1. **Model/Strategy Approval Flow** - Param-diff ve risk-skor UI (approve/deny)
2. **Auto-Degrade System** - Eşik ihlallerinde otomatik MOCK'a dönüş
3. **Rate-Limit Telemetry** - Burst & sustained ayrımı, 429 audit genişletmesi
4. **BIST Real Feed Transition** - Mock→Vendor geçiş planı ve data-quality guards

### Success Criteria
- ✅ Strategy deployment requires explicit approval with risk scoring
- ✅ System auto-degrades to MOCK after sustained SLO breaches
- ✅ Rate limit violations tracked with burst/sustained distinction
- ✅ BIST real feed integrated with quality gates and fallback

---

## 📦 Epic 1: Model/Strategy Approval Flow

### User Story
*As a platform operator, I need to review and approve strategy deployments with risk scoring, so I can prevent high-risk configurations from going live.*

### Technical Tasks

#### 1.1 Strategy Diff Engine
**Priority:** HIGH  
**Estimate:** 3 days

**Requirements:**
- Compare incoming strategy params with active strategy
- Generate structured diff (added, removed, modified fields)
- Highlight high-risk changes (leverage, position size, symbols)

**Implementation:**
```typescript
// apps/web-next/src/lib/strategy-diff.ts
interface StrategyDiff {
  added: Record<string, any>;
  removed: Record<string, any>;
  modified: Array<{
    field: string;
    oldValue: any;
    newValue: any;
    riskLevel: 'low' | 'medium' | 'high' | 'critical';
  }>;
  riskScore: number; // 0-100
  blockers: string[]; // Auto-reject reasons
}

export function calculateStrategyDiff(
  current: Strategy,
  incoming: Strategy
): StrategyDiff;
```

**Deliverables:**
- [ ] `strategy-diff.ts` library
- [ ] Unit tests for diff calculation
- [ ] Risk scoring algorithm (0-100 scale)
- [ ] Auto-blocker rules (e.g., leverage >10x, position >$10k)

---

#### 1.2 Approval API & Workflow
**Priority:** HIGH  
**Estimate:** 2 days

**Requirements:**
- Store pending strategy changes in approval queue
- Track approval status (pending, approved, rejected)
- Audit log for all approval decisions
- Auto-reject if blockers present

**Implementation:**
```typescript
// apps/web-next/src/app/api/approvals/strategy/route.ts
POST /api/approvals/strategy
{
  "strategyId": "str-123",
  "changes": { /* StrategyDiff */ },
  "requestedBy": "user-456",
  "reason": "Increase leverage for BTC position"
}

GET /api/approvals/strategy/:id
{
  "id": "apr-789",
  "status": "pending" | "approved" | "rejected",
  "changes": { /* StrategyDiff */ },
  "approvedBy": "admin-001",
  "approvedAt": "2025-01-20T10:30:00Z",
  "auditLog": [...]
}

POST /api/approvals/strategy/:id/approve
POST /api/approvals/strategy/:id/reject
```

**Deliverables:**
- [ ] Approval API routes
- [ ] Database schema for approval queue
- [ ] Audit logging integration
- [ ] Integration tests

---

#### 1.3 Approval UI
**Priority:** MEDIUM  
**Estimate:** 3 days

**Requirements:**
- Approval queue dashboard
- Strategy diff visualization (side-by-side comparison)
- Risk score display with color coding
- One-click approve/reject with reason
- Mobile-responsive layout

**Wireframe:**
```
┌─────────────────────────────────────────────────────┐
│  Strategy Approval Queue                            │
├─────────────────────────────────────────────────────┤
│  ┌───────────────────────────────────────────────┐  │
│  │ str-123 | BTC Scalping v2                    │  │
│  │ Risk Score: 65/100 🟡                        │  │
│  │ Changes: +leverage (5x→8x), +position (500→) │  │
│  │ [View Diff] [Approve] [Reject]               │  │
│  └───────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────┐  │
│  │ str-456 | ETH Mean Reversion                 │  │
│  │ Risk Score: 85/100 🔴 BLOCKED                │  │
│  │ Blockers: Leverage >10x, Unknown symbol      │  │
│  │ [View Details]                               │  │
│  └───────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
```

**Deliverables:**
- [ ] `ApprovalQueuePage.tsx`
- [ ] `StrategyDiffViewer.tsx` component
- [ ] `RiskScoreBadge.tsx` component
- [ ] Integration with approval API

---

## 📦 Epic 2: Auto-Degrade System

### User Story
*As a reliability engineer, I need the system to automatically degrade to MOCK data when SLO thresholds are breached for sustained periods, so we prevent cascading failures.*

### Technical Tasks

#### 2.1 SLO Breach Detector
**Priority:** HIGH  
**Estimate:** 2 days

**Requirements:**
- Track consecutive SLO breaches (sliding window)
- Distinguish transient spikes from sustained issues
- Configurable thresholds (e.g., 3 breaches in 5 minutes)
- Emit alerts before auto-degrade triggers

**Implementation:**
```typescript
// apps/web-next/src/lib/slo-breach-detector.ts
interface BreachDetectorConfig {
  windowSizeMin: number; // e.g., 5 minutes
  maxBreaches: number;   // e.g., 3 consecutive
  cooldownMin: number;   // e.g., 10 minutes before re-check
}

interface BreachEvent {
  metric: 'latencyP95' | 'errorRate' | 'staleness' | 'venueStaleness';
  value: number;
  threshold: number;
  timestamp: Date;
}

export class SLOBreachDetector {
  detectSustainedBreach(events: BreachEvent[]): boolean;
  shouldAutoDegrade(): boolean;
  resetCooldown(): void;
}
```

**Deliverables:**
- [ ] `slo-breach-detector.ts` library
- [ ] Sliding window breach tracking
- [ ] Unit tests with edge cases
- [ ] Integration with `/api/healthz`

---

#### 2.2 Auto-Degrade Controller
**Priority:** HIGH  
**Estimate:** 2 days

**Requirements:**
- Trigger kill-switch to MOCK when sustained breach detected
- Create incident evidence ZIP automatically
- Notify operators via alert channels
- Require manual approval to restore REAL mode
- Rate limit auto-degrade triggers (max 1/hour)

**Implementation:**
```typescript
// apps/web-next/src/lib/auto-degrade.ts
interface AutoDegradeEvent {
  triggeredAt: Date;
  reason: string;
  breaches: BreachEvent[];
  evidenceZip: string;
  status: 'active' | 'acknowledged' | 'resolved';
}

export async function triggerAutoDegrade(
  breaches: BreachEvent[]
): Promise<AutoDegradeEvent>;

export async function restoreRealMode(
  eventId: string,
  approvedBy: string
): Promise<void>;
```

**Deliverables:**
- [ ] `auto-degrade.ts` controller
- [ ] Integration with kill-switch API
- [ ] Automatic evidence ZIP generation
- [ ] Alert notification system
- [ ] Manual restore approval flow

---

#### 2.3 Auto-Degrade Dashboard
**Priority:** MEDIUM  
**Estimate:** 2 days

**Requirements:**
- Show current degrade status (REAL/MOCK/AUTO_DEGRADE)
- Display recent breach history (last 24h)
- Show active incidents with evidence links
- Manual override: "Restore to REAL" button (requires approval)
- Timeline visualization of degrades

**Deliverables:**
- [ ] `AutoDegradeStatus.tsx` component
- [ ] Breach history timeline
- [ ] Incident evidence viewer
- [ ] Manual restore workflow

---

## 📦 Epic 3: Rate-Limit Telemetry Enhancement

### User Story
*As a platform operator, I need detailed rate limit violation tracking with burst vs sustained distinction, so I can optimize API usage and prevent vendor throttling.*

### Technical Tasks

#### 3.1 Enhanced Rate Limiter
**Priority:** MEDIUM  
**Estimate:** 2 days

**Requirements:**
- Distinguish burst (sudden spike) vs sustained (continuous high load)
- Track per-endpoint and per-venue metrics
- Emit Prometheus counters for both burst and sustained violations
- Adaptive rate limiting (back off after repeated violations)

**Implementation:**
```typescript
// apps/web-next/src/lib/rate-limiter-v2.ts
interface RateLimitMetrics {
  burst_violations_total: number;
  sustained_violations_total: number;
  adaptive_backoff_active: boolean;
  current_limit_rpm: number;
}

export function trackBurstViolation(venue: string, endpoint: string): void;
export function trackSustainedViolation(venue: string, endpoint: string): void;
export function getAdaptiveLimit(venue: string): number;
```

**Deliverables:**
- [ ] Enhanced rate limiter with burst/sustained detection
- [ ] Adaptive backoff algorithm
- [ ] Prometheus metrics export
- [ ] Integration with existing rate limiter

---

#### 3.2 Rate Limit Audit Expansion
**Priority:** MEDIUM  
**Estimate:** 1 day

**Requirements:**
- Expand audit log with burst/sustained classification
- Include request context (endpoint, params, response time)
- Correlate violations with specific strategies
- Generate daily rate limit report

**Deliverables:**
- [ ] Enhanced audit log format
- [ ] Daily rate limit report generator
- [ ] Correlation with strategy IDs

---

#### 3.3 Rate Limit Dashboard
**Priority:** LOW  
**Estimate:** 2 days

**Requirements:**
- Real-time rate limit usage per venue
- Burst vs sustained violation charts
- Adaptive backoff status indicators
- Per-strategy rate limit consumption

**Deliverables:**
- [ ] `RateLimitDashboard.tsx` page
- [ ] Usage charts (time series)
- [ ] Violation breakdown by type

---

## 📦 Epic 4: BIST Real Feed Transition

### User Story
*As a data operations engineer, I need to transition from mock BIST data to real vendor feed with quality gates and fallback, so we have accurate Turkish equity market data.*

### Technical Tasks

#### 4.1 BIST Vendor Integration
**Priority:** HIGH  
**Estimate:** 4 days

**Requirements:**
- Integrate with real BIST data vendor (TBD: specify vendor)
- Implement vendor-specific protocol (REST/WS/FIX)
- Handle authentication and session management
- Implement reconnect logic with exponential backoff

**Vendor Selection Criteria:**
- Latency <500ms for REST, <100ms for WS
- Uptime SLA >99.5%
- Support for THYAO, AKBNK, GARAN, ISCTR, SAHOL (top 5)
- Pricing within budget

**Deliverables:**
- [ ] Vendor selection and contract
- [ ] BIST vendor client library
- [ ] Authentication module
- [ ] Connection stability tests

---

#### 4.2 BIST Data Quality Gates
**Priority:** HIGH  
**Estimate:** 2 days

**Requirements:**
- Validate incoming data against schema
- Check staleness (<30s requirement)
- Detect anomalies (price spikes >10%, volume spikes >5x)
- Auto-fallback to mock if quality gates fail
- Alert on quality gate violations

**Implementation:**
```typescript
// packages/marketdata-bist/src/quality-gates.ts
interface QualityGate {
  name: string;
  check: (data: BISTSnapshot) => boolean;
  severity: 'warning' | 'critical';
}

const QUALITY_GATES: QualityGate[] = [
  {
    name: 'schema_validation',
    check: (data) => validateSchema(data),
    severity: 'critical',
  },
  {
    name: 'staleness_check',
    check: (data) => Date.now() - data.timestamp < 30000,
    severity: 'critical',
  },
  {
    name: 'price_anomaly',
    check: (data) => Math.abs(data.priceChange) < 0.1,
    severity: 'warning',
  },
];

export function runQualityGates(data: BISTSnapshot): {
  passed: boolean;
  failures: string[];
};
```

**Deliverables:**
- [ ] Quality gate framework
- [ ] Schema validation rules
- [ ] Anomaly detection algorithms
- [ ] Auto-fallback logic

---

#### 4.3 BIST Canary Deployment
**Priority:** HIGH  
**Estimate:** 2 days

**Requirements:**
- Phased rollout: 10% → 50% → 100% traffic to real feed
- Side-by-side comparison (real vs mock) for validation
- SLO monitoring specific to BIST feed
- Rollback plan if quality gates fail repeatedly

**Deliverables:**
- [ ] Canary deployment script
- [ ] Side-by-side comparison report
- [ ] BIST-specific SLO dashboard
- [ ] Rollback automation

---

#### 4.4 BIST Documentation & Runbook
**Priority:** MEDIUM  
**Estimate:** 1 day

**Requirements:**
- Vendor integration guide
- Quality gate configuration
- Troubleshooting guide
- Escalation procedures

**Deliverables:**
- [ ] `BIST_VENDOR_INTEGRATION.md`
- [ ] `BIST_QUALITY_GATES.md`
- [ ] `BIST_TROUBLESHOOTING.md`

---

## 📅 Sprint Timeline (2 Weeks)

### Week 1: Foundation & Core Features
```
Day 1-2:   Strategy Diff Engine (1.1)
Day 3-4:   Approval API & Workflow (1.2)
Day 5:     SLO Breach Detector (2.1)
Day 6-7:   Auto-Degrade Controller (2.2)
```

### Week 2: UI & Integration
```
Day 8-10:  Approval UI (1.3) + Auto-Degrade Dashboard (2.3)
Day 11-12: Enhanced Rate Limiter (3.1) + BIST Vendor Integration (4.1)
Day 13:    BIST Quality Gates (4.2)
Day 14:    Integration Testing + Documentation
```

---

## 🎯 Definition of Done

### Per Epic
- [ ] All technical tasks completed
- [ ] Unit tests passing (>80% coverage)
- [ ] Integration tests passing
- [ ] Documentation written
- [ ] Code review approved
- [ ] Deployed to staging
- [ ] Smoke tests passing

### Sprint Completion
- [ ] All epics meet DoD
- [ ] Canary deployment successful
- [ ] Evidence ZIP generated
- [ ] Ops report published
- [ ] Team demo completed
- [ ] Retrospective held

---

## 🚨 Risk Assessment

### High Risks
1. **BIST Vendor Integration**
   - *Risk:* Vendor API instability or downtime
   - *Mitigation:* Mock fallback, multi-vendor evaluation, contract SLA

2. **Auto-Degrade False Positives**
   - *Risk:* System degrades unnecessarily during transient issues
   - *Mitigation:* Tunable thresholds, cooldown periods, alert before degrade

3. **Approval Workflow Bottleneck**
   - *Risk:* Manual approvals slow down deployments
   - *Mitigation:* Auto-approve for low-risk changes, priority queue

### Medium Risks
1. **Rate Limit Adaptive Logic**
   - *Risk:* Over-aggressive backoff reduces throughput
   - *Mitigation:* Configurable backoff params, real-time monitoring

2. **Quality Gate Tuning**
   - *Risk:* Too strict gates cause frequent fallbacks
   - *Mitigation:* Phased rollout, side-by-side validation

---

## 📊 Success Metrics

### Quantitative
- **Strategy Approval:** 100% of high-risk changes reviewed
- **Auto-Degrade:** <1 false positive per week
- **Rate Limit:** <5% burst violations, <1% sustained violations
- **BIST Quality:** 99.9% data quality pass rate

### Qualitative
- **Operator Confidence:** Positive feedback on approval UI
- **System Stability:** No unplanned degrades during business hours
- **Documentation:** All runbooks complete and accurate

---

## 🔗 Dependencies

### External
- BIST vendor selection and contract (blocking Epic 4)
- Prometheus/Grafana updates for new metrics (blocking Epic 3)

### Internal
- v1.2 SLO thresholds stable for 1 week (blocking Epic 2)
- Database schema changes approved (blocking Epic 1)

---

## 📝 Notes

- **Epic 1 (Approval Flow)** is highest priority for compliance
- **Epic 2 (Auto-Degrade)** enhances reliability but can slip to v1.4 if needed
- **Epic 4 (BIST)** is critical for Turkish market coverage
- **Epic 3 (Rate Limit)** is nice-to-have, can be deprioritized

---

*Sprint Plan prepared for v1.3 Guardrails*  
*Target: T+2 weeks from v1.2 completion*  
*Next: BIST Real Feed Risk Analysis*

